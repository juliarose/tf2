// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steamdatagram_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterPingReply {
    // message fields
    client_timestamp: ::std::option::Option<u32>,
    pub latency_datacenter_ids: ::std::vec::Vec<u32>,
    pub latency_ping_ms: ::std::vec::Vec<u32>,
    your_public_ip: ::std::option::Option<u32>,
    server_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    client_cookie: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    pub route_exceptions: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply {
        <CMsgSteamDatagramRouterPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply {
    pub fn new() -> CMsgSteamDatagramRouterPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 1;


    pub fn get_client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }
    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // repeated fixed32 latency_datacenter_ids = 2;


    pub fn get_latency_datacenter_ids(&self) -> &[u32] {
        &self.latency_datacenter_ids
    }
    pub fn clear_latency_datacenter_ids(&mut self) {
        self.latency_datacenter_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_latency_datacenter_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.latency_datacenter_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latency_datacenter_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latency_datacenter_ids
    }

    // Take field
    pub fn take_latency_datacenter_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latency_datacenter_ids, ::std::vec::Vec::new())
    }

    // repeated uint32 latency_ping_ms = 3;


    pub fn get_latency_ping_ms(&self) -> &[u32] {
        &self.latency_ping_ms
    }
    pub fn clear_latency_ping_ms(&mut self) {
        self.latency_ping_ms.clear();
    }

    // Param is passed by value, moved
    pub fn set_latency_ping_ms(&mut self, v: ::std::vec::Vec<u32>) {
        self.latency_ping_ms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latency_ping_ms(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latency_ping_ms
    }

    // Take field
    pub fn take_latency_ping_ms(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latency_ping_ms, ::std::vec::Vec::new())
    }

    // optional fixed32 your_public_ip = 4;


    pub fn get_your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }
    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 5;


    pub fn get_server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 6;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 7;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;


    pub fn get_client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }
    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 9;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;


    pub fn get_route_exceptions(&self) -> &[CMsgSteamDatagramRouterPingReply_RouteException] {
        &self.route_exceptions
    }
    pub fn clear_route_exceptions(&mut self) {
        self.route_exceptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_exceptions(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException>) {
        self.route_exceptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_exceptions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException> {
        &mut self.route_exceptions
    }

    // Take field
    pub fn take_route_exceptions(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException> {
        ::std::mem::replace(&mut self.route_exceptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply {
    fn is_initialized(&self) -> bool {
        for v in &self.route_exceptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.latency_datacenter_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.latency_ping_ms)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_cookie = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_exceptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_timestamp {
            my_size += 5;
        }
        if !self.latency_datacenter_ids.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.latency_datacenter_ids.len() * 4) as u32) + (self.latency_datacenter_ids.len() * 4) as u32;
        }
        if !self.latency_ping_ms.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.latency_ping_ms);
        }
        if let Some(v) = self.your_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.server_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_cookie {
            my_size += 5;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_exceptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(1, v)?;
        }
        if !self.latency_datacenter_ids.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.latency_datacenter_ids.len() * 4) as u32)?;
            for v in &self.latency_datacenter_ids {
                os.write_fixed32_no_tag(*v)?;
            };
        }
        if !self.latency_ping_ms.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.latency_ping_ms))?;
            for v in &self.latency_ping_ms {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(9, v)?;
        }
        for v in &self.route_exceptions {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterPingReply {
        CMsgSteamDatagramRouterPingReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_timestamp",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.client_timestamp },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "latency_datacenter_ids",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_datacenter_ids },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_datacenter_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "latency_ping_ms",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_ping_ms },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_ip",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_ip },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_time",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.server_time },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.server_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.challenge },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_cookie",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.client_cookie },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_cookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramRouterPingReply_RouteException>>(
                "route_exceptions",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.route_exceptions },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.route_exceptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply>(
                "CMsgSteamDatagramRouterPingReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterPingReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterPingReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterPingReply {
    fn clear(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
        self.latency_datacenter_ids.clear();
        self.latency_ping_ms.clear();
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.route_exceptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterPingReply_RouteException {
    // message fields
    data_center_id: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    penalty: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply_RouteException {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply_RouteException {
        <CMsgSteamDatagramRouterPingReply_RouteException as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply_RouteException {
    pub fn new() -> CMsgSteamDatagramRouterPingReply_RouteException {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty = 3;


    pub fn get_penalty(&self) -> u32 {
        self.penalty.unwrap_or(0)
    }
    pub fn clear_penalty(&mut self) {
        self.penalty = ::std::option::Option::None;
    }

    pub fn has_penalty(&self) -> bool {
        self.penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty(&mut self, v: u32) {
        self.penalty = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply_RouteException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.penalty {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterPingReply_RouteException {
        CMsgSteamDatagramRouterPingReply_RouteException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "data_center_id",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.data_center_id },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.flags },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "penalty",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.penalty },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.penalty },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply_RouteException>(
                "CMsgSteamDatagramRouterPingReply.RouteException",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply_RouteException {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterPingReply_RouteException> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterPingReply_RouteException::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterPingReply_RouteException {
    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.penalty = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterPingReply_RouteException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply_RouteException {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverPing {
    // message fields
    legacy_client_session: ::std::option::Option<u32>,
    client_steam_id: ::std::option::Option<u64>,
    client_timestamp: ::std::option::Option<u32>,
    router_timestamp: ::std::option::Option<u32>,
    router_gameserver_latency: ::std::option::Option<u32>,
    seq_number_router: ::std::option::Option<u32>,
    seq_number_e2e: ::std::option::Option<u32>,
    relay_session_id: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPing {
    fn default() -> &'a CMsgSteamDatagramGameserverPing {
        <CMsgSteamDatagramGameserverPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPing {
    pub fn new() -> CMsgSteamDatagramGameserverPing {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_client_session = 1;


    pub fn get_legacy_client_session(&self) -> u32 {
        self.legacy_client_session.unwrap_or(0)
    }
    pub fn clear_legacy_client_session(&mut self) {
        self.legacy_client_session = ::std::option::Option::None;
    }

    pub fn has_legacy_client_session(&self) -> bool {
        self.legacy_client_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_session(&mut self, v: u32) {
        self.legacy_client_session = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 2;


    pub fn get_client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }
    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_timestamp = 3;


    pub fn get_client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }
    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;


    pub fn get_router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }
    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;


    pub fn get_router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }
    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_router = 6;


    pub fn get_seq_number_router(&self) -> u32 {
        self.seq_number_router.unwrap_or(0)
    }
    pub fn clear_seq_number_router(&mut self) {
        self.seq_number_router = ::std::option::Option::None;
    }

    pub fn has_seq_number_router(&self) -> bool {
        self.seq_number_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_router(&mut self, v: u32) {
        self.seq_number_router = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_e2e = 7;


    pub fn get_seq_number_e2e(&self) -> u32 {
        self.seq_number_e2e.unwrap_or(0)
    }
    pub fn clear_seq_number_e2e(&mut self) {
        self.seq_number_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_number_e2e(&self) -> bool {
        self.seq_number_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_e2e(&mut self, v: u32) {
        self.seq_number_e2e = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 9;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_client_session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.client_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.router_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.router_gameserver_latency = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_number_router = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_number_e2e = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_session {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.client_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_number_router {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_number_e2e {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_client_session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_number_router {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.seq_number_e2e {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverPing {
        CMsgSteamDatagramGameserverPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_client_session",
                |m: &CMsgSteamDatagramGameserverPing| { &m.legacy_client_session },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.legacy_client_session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "client_steam_id",
                |m: &CMsgSteamDatagramGameserverPing| { &m.client_steam_id },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_timestamp",
                |m: &CMsgSteamDatagramGameserverPing| { &m.client_timestamp },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.client_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "router_timestamp",
                |m: &CMsgSteamDatagramGameserverPing| { &m.router_timestamp },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.router_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "router_gameserver_latency",
                |m: &CMsgSteamDatagramGameserverPing| { &m.router_gameserver_latency },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.router_gameserver_latency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_number_router",
                |m: &CMsgSteamDatagramGameserverPing| { &m.seq_number_router },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.seq_number_router },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_number_e2e",
                |m: &CMsgSteamDatagramGameserverPing| { &m.seq_number_e2e },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.seq_number_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramGameserverPing| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramGameserverPing| { &m.connection_id },
                |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverPing>(
                "CMsgSteamDatagramGameserverPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPing {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverPing::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverPing {
    fn clear(&mut self) {
        self.legacy_client_session = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.client_timestamp = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seq_number_router = ::std::option::Option::None;
        self.seq_number_e2e = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRelayToRelayPing {
    // message fields
    request_timestamp: ::std::option::Option<u32>,
    request_date: ::std::option::Option<u32>,
    my_pop_id: ::std::option::Option<u32>,
    your_pop_id: ::std::option::Option<u32>,
    checksum: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRelayToRelayPing {
    fn default() -> &'a CMsgSteamDatagramRelayToRelayPing {
        <CMsgSteamDatagramRelayToRelayPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRelayToRelayPing {
    pub fn new() -> CMsgSteamDatagramRelayToRelayPing {
        ::std::default::Default::default()
    }

    // optional fixed32 request_timestamp = 1;


    pub fn get_request_timestamp(&self) -> u32 {
        self.request_timestamp.unwrap_or(0)
    }
    pub fn clear_request_timestamp(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
    }

    pub fn has_request_timestamp(&self) -> bool {
        self.request_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_timestamp(&mut self, v: u32) {
        self.request_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 request_date = 2;


    pub fn get_request_date(&self) -> u32 {
        self.request_date.unwrap_or(0)
    }
    pub fn clear_request_date(&mut self) {
        self.request_date = ::std::option::Option::None;
    }

    pub fn has_request_date(&self) -> bool {
        self.request_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_date(&mut self, v: u32) {
        self.request_date = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_pop_id = 3;


    pub fn get_my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }
    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 4;


    pub fn get_your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }
    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 checksum = 5;


    pub fn get_checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }
    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRelayToRelayPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.request_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.request_date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_pop_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_pop_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.checksum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.request_date {
            my_size += 5;
        }
        if let Some(v) = self.my_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.checksum {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.request_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRelayToRelayPing {
        CMsgSteamDatagramRelayToRelayPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "request_timestamp",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_timestamp },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "request_date",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_date },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_pop_id",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.my_pop_id },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.my_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_pop_id",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.your_pop_id },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.your_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "checksum",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.checksum },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.checksum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRelayToRelayPing>(
                "CMsgSteamDatagramRelayToRelayPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRelayToRelayPing {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRelayToRelayPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRelayToRelayPing::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRelayToRelayPing {
    fn clear(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
        self.request_date = ::std::option::Option::None;
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRelayToRelayPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRelayToRelayPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramSessionCryptInfo {
    // message fields
    key_type: ::std::option::Option<CMsgSteamDatagramSessionCryptInfo_EKeyType>,
    key_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nonce: ::std::option::Option<u64>,
    is_snp: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfo {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfo {
        <CMsgSteamDatagramSessionCryptInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfo {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfo {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;


    pub fn get_key_type(&self) -> CMsgSteamDatagramSessionCryptInfo_EKeyType {
        self.key_type.unwrap_or(CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID)
    }
    pub fn clear_key_type(&mut self) {
        self.key_type = ::std::option::Option::None;
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: CMsgSteamDatagramSessionCryptInfo_EKeyType) {
        self.key_type = ::std::option::Option::Some(v);
    }

    // optional bytes key_data = 2;


    pub fn get_key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key_data(&mut self) {
        self.key_data.clear();
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data.set_default();
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 nonce = 3;


    pub fn get_nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // optional bool is_snp = 4;


    pub fn get_is_snp(&self) -> bool {
        self.is_snp.unwrap_or(false)
    }
    pub fn clear_is_snp(&mut self) {
        self.is_snp = ::std::option::Option::None;
    }

    pub fn has_is_snp(&self) -> bool {
        self.is_snp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_snp(&mut self, v: bool) {
        self.is_snp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.key_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_snp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.nonce {
            my_size += 9;
        }
        if let Some(v) = self.is_snp {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.key_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.nonce {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.is_snp {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfo {
        CMsgSteamDatagramSessionCryptInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgSteamDatagramSessionCryptInfo_EKeyType>>(
                "key_type",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_type },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key_data",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_data },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "nonce",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.nonce },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_snp",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.is_snp },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.is_snp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfo>(
                "CMsgSteamDatagramSessionCryptInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramSessionCryptInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramSessionCryptInfo::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramSessionCryptInfo {
    fn clear(&mut self) {
        self.key_type = ::std::option::Option::None;
        self.key_data.clear();
        self.nonce = ::std::option::Option::None;
        self.is_snp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramSessionCryptInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
    INVALID = 0,
    CURVE25519 = 1,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramSessionCryptInfo_EKeyType> {
        match value {
            0 => ::std::option::Option::Some(CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID),
            1 => ::std::option::Option::Some(CMsgSteamDatagramSessionCryptInfo_EKeyType::CURVE25519),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramSessionCryptInfo_EKeyType] = &[
            CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID,
            CMsgSteamDatagramSessionCryptInfo_EKeyType::CURVE25519,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfo_EKeyType>("CMsgSteamDatagramSessionCryptInfo.EKeyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramSessionCryptInfo_EKeyType {
}

impl ::std::default::Default for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn default() -> Self {
        CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramSessionCryptInfoSigned {
    // message fields
    info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfoSigned {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfoSigned {
        <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfoSigned {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        ::std::default::Default::default()
    }

    // optional bytes info = 1;


    pub fn get_info(&self) -> &[u8] {
        match self.info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::vec::Vec<u8> {
        self.info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfoSigned {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        CMsgSteamDatagramSessionCryptInfoSigned::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "info",
                |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.info },
                |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.signature },
                |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfoSigned>(
                "CMsgSteamDatagramSessionCryptInfoSigned",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfoSigned {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramSessionCryptInfoSigned> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramSessionCryptInfoSigned::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramSessionCryptInfoSigned {
    fn clear(&mut self) {
        self.info.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramSessionCryptInfoSigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfoSigned {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverSessionRequest {
    // message fields
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    challenge_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    network_config_version: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionRequest {
        <CMsgSteamDatagramGameserverSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionRequest {
    pub fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes ticket = 1;


    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 challenge_time = 3;


    pub fn get_challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }
    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 5;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 6;


    pub fn get_network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }
    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 7;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.challenge_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_config_version = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.challenge_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ticket.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.challenge_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        CMsgSteamDatagramGameserverSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ticket",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.ticket },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.ticket },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "challenge_time",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge_time },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_config_version",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.network_config_version },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.network_config_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverSessionRequest>(
                "CMsgSteamDatagramGameserverSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverSessionRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverSessionRequest {
    fn clear(&mut self) {
        self.ticket.clear();
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverSessionEstablished {
    // message fields
    connection_id: ::std::option::Option<u32>,
    gameserver_steam_id: ::std::option::Option<u64>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    legacy_relay_session_id: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionEstablished {
        <CMsgSteamDatagramGameserverSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionEstablished {
    pub fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 3;


    pub fn get_gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }
    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 4;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_relay_session_id = 5;


    pub fn get_legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }
    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 6;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionEstablished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gameserver_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_relay_session_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        CMsgSteamDatagramGameserverSessionEstablished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gameserver_steam_id",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.gameserver_steam_id },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.gameserver_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_relay_session_id",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.legacy_relay_session_id },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.legacy_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seq_num_r2c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverSessionEstablished>(
                "CMsgSteamDatagramGameserverSessionEstablished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionEstablished {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverSessionEstablished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverSessionEstablished::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverSessionEstablished {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionEstablished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoSessionRelayToClient {
    // message fields
    legacy_relay_session_id: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    your_public_ip: ::std::option::Option<u32>,
    server_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToClient {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToClient {
        <CMsgSteamDatagramNoSessionRelayToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToClient {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_relay_session_id = 1;


    pub fn get_legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }
    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 7;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 2;


    pub fn get_your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }
    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 3;


    pub fn get_server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.your_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.server_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        CMsgSteamDatagramNoSessionRelayToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_relay_session_id",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.legacy_relay_session_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.legacy_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.connection_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_ip",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.your_public_ip },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.your_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_time",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.server_time },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.server_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.challenge },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.seconds_until_shutdown },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoSessionRelayToClient>(
                "CMsgSteamDatagramNoSessionRelayToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoSessionRelayToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoSessionRelayToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoSessionRelayToClient {
    fn clear(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoSessionRelayToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoSessionRelayToServer {
    // message fields
    relay_session_id: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    kludge_pad: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToServer {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToServer {
        <CMsgSteamDatagramNoSessionRelayToServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToServer {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToServer {
        ::std::default::Default::default()
    }

    // optional uint32 relay_session_id = 1;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;


    pub fn get_kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }
    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.kludge_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.kludge_pad {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToServer {
        CMsgSteamDatagramNoSessionRelayToServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramNoSessionRelayToServer| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToServer| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramNoSessionRelayToServer| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToServer| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramNoSessionRelayToServer| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToServer| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "kludge_pad",
                |m: &CMsgSteamDatagramNoSessionRelayToServer| { &m.kludge_pad },
                |m: &mut CMsgSteamDatagramNoSessionRelayToServer| { &mut m.kludge_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoSessionRelayToServer>(
                "CMsgSteamDatagramNoSessionRelayToServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToServer {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoSessionRelayToServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoSessionRelayToServer::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoSessionRelayToServer {
    fn clear(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoSessionRelayToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDiagnostic {
    // message fields
    severity: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDiagnostic {
    fn default() -> &'a CMsgSteamDatagramDiagnostic {
        <CMsgSteamDatagramDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDiagnostic {
    pub fn new() -> CMsgSteamDatagramDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 severity = 1;


    pub fn get_severity(&self) -> u32 {
        self.severity.unwrap_or(0)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: u32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDiagnostic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.severity {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDiagnostic {
        CMsgSteamDatagramDiagnostic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "severity",
                |m: &CMsgSteamDatagramDiagnostic| { &m.severity },
                |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CMsgSteamDatagramDiagnostic| { &m.text },
                |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDiagnostic>(
                "CMsgSteamDatagramDiagnostic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDiagnostic {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDiagnostic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDiagnostic::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDiagnostic {
    fn clear(&mut self) {
        self.severity = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDiagnostic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState {
    // message fields
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState {
    fn default() -> &'a CMsgSteamDatagramDataCenterState {
        <CMsgSteamDatagramDataCenterState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState {
    pub fn new() -> CMsgSteamDatagramDataCenterState {
        ::std::default::Default::default()
    }

    // repeated .CMsgSteamDatagramDataCenterState.DataCenter data_centers = 1;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramDataCenterState_DataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState {
    fn is_initialized(&self) -> bool {
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data_centers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState {
        CMsgSteamDatagramDataCenterState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_DataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramDataCenterState| { &m.data_centers },
                |m: &mut CMsgSteamDatagramDataCenterState| { &mut m.data_centers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState>(
                "CMsgSteamDatagramDataCenterState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState {
    fn clear(&mut self) {
        self.data_centers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState_Server {
    // message fields
    address: ::protobuf::SingularField<::std::string::String>,
    ping_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState_Server {
    fn default() -> &'a CMsgSteamDatagramDataCenterState_Server {
        <CMsgSteamDatagramDataCenterState_Server as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState_Server {
    pub fn new() -> CMsgSteamDatagramDataCenterState_Server {
        ::std::default::Default::default()
    }

    // optional string address = 1;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_ms = 2;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState_Server {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState_Server {
        CMsgSteamDatagramDataCenterState_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &CMsgSteamDatagramDataCenterState_Server| { &m.address },
                |m: &mut CMsgSteamDatagramDataCenterState_Server| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramDataCenterState_Server| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramDataCenterState_Server| { &mut m.ping_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState_Server>(
                "CMsgSteamDatagramDataCenterState.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState_Server {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState_Server::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState_Server {
    fn clear(&mut self) {
        self.address.clear();
        self.ping_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState_DataCenter {
    // message fields
    code: ::protobuf::SingularField<::std::string::String>,
    pub server_sample: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>,
    pub relay_sample: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState_DataCenter {
    fn default() -> &'a CMsgSteamDatagramDataCenterState_DataCenter {
        <CMsgSteamDatagramDataCenterState_DataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState_DataCenter {
    pub fn new() -> CMsgSteamDatagramDataCenterState_DataCenter {
        ::std::default::Default::default()
    }

    // optional string code = 1;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgSteamDatagramDataCenterState.Server server_sample = 2;


    pub fn get_server_sample(&self) -> &[CMsgSteamDatagramDataCenterState_Server] {
        &self.server_sample
    }
    pub fn clear_server_sample(&mut self) {
        self.server_sample.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_sample(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>) {
        self.server_sample = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_sample(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        &mut self.server_sample
    }

    // Take field
    pub fn take_server_sample(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        ::std::mem::replace(&mut self.server_sample, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramDataCenterState.Server relay_sample = 3;


    pub fn get_relay_sample(&self) -> &[CMsgSteamDatagramDataCenterState_Server] {
        &self.relay_sample
    }
    pub fn clear_relay_sample(&mut self) {
        self.relay_sample.clear();
    }

    // Param is passed by value, moved
    pub fn set_relay_sample(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>) {
        self.relay_sample = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relay_sample(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        &mut self.relay_sample
    }

    // Take field
    pub fn take_relay_sample(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        ::std::mem::replace(&mut self.relay_sample, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState_DataCenter {
    fn is_initialized(&self) -> bool {
        for v in &self.server_sample {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relay_sample {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.server_sample)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relay_sample)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.server_sample {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relay_sample {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.server_sample {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relay_sample {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState_DataCenter {
        CMsgSteamDatagramDataCenterState_DataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.code },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_Server>>(
                "server_sample",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.server_sample },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.server_sample },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_Server>>(
                "relay_sample",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.relay_sample },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.relay_sample },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState_DataCenter>(
                "CMsgSteamDatagramDataCenterState.DataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState_DataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState_DataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState_DataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState_DataCenter {
    fn clear(&mut self) {
        self.code.clear();
        self.server_sample.clear();
        self.relay_sample.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState_DataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState_DataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramLinkInstantaneousStats {
    // message fields
    out_packets_per_sec_x10: ::std::option::Option<u32>,
    out_bytes_per_sec: ::std::option::Option<u32>,
    in_packets_per_sec_x10: ::std::option::Option<u32>,
    in_bytes_per_sec: ::std::option::Option<u32>,
    ping_ms: ::std::option::Option<u32>,
    packets_dropped_pct: ::std::option::Option<u32>,
    packets_weird_sequence_pct: ::std::option::Option<u32>,
    peak_jitter_usec: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkInstantaneousStats {
    fn default() -> &'a CMsgSteamDatagramLinkInstantaneousStats {
        <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkInstantaneousStats {
    pub fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        ::std::default::Default::default()
    }

    // optional uint32 out_packets_per_sec_x10 = 1;


    pub fn get_out_packets_per_sec_x10(&self) -> u32 {
        self.out_packets_per_sec_x10.unwrap_or(0)
    }
    pub fn clear_out_packets_per_sec_x10(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_out_packets_per_sec_x10(&self) -> bool {
        self.out_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_packets_per_sec_x10(&mut self, v: u32) {
        self.out_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 out_bytes_per_sec = 2;


    pub fn get_out_bytes_per_sec(&self) -> u32 {
        self.out_bytes_per_sec.unwrap_or(0)
    }
    pub fn clear_out_bytes_per_sec(&mut self) {
        self.out_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_out_bytes_per_sec(&self) -> bool {
        self.out_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_bytes_per_sec(&mut self, v: u32) {
        self.out_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 in_packets_per_sec_x10 = 3;


    pub fn get_in_packets_per_sec_x10(&self) -> u32 {
        self.in_packets_per_sec_x10.unwrap_or(0)
    }
    pub fn clear_in_packets_per_sec_x10(&mut self) {
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_in_packets_per_sec_x10(&self) -> bool {
        self.in_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_packets_per_sec_x10(&mut self, v: u32) {
        self.in_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 in_bytes_per_sec = 4;


    pub fn get_in_bytes_per_sec(&self) -> u32 {
        self.in_bytes_per_sec.unwrap_or(0)
    }
    pub fn clear_in_bytes_per_sec(&mut self) {
        self.in_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_in_bytes_per_sec(&self) -> bool {
        self.in_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_bytes_per_sec(&mut self, v: u32) {
        self.in_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 5;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_dropped_pct = 6;


    pub fn get_packets_dropped_pct(&self) -> u32 {
        self.packets_dropped_pct.unwrap_or(0)
    }
    pub fn clear_packets_dropped_pct(&mut self) {
        self.packets_dropped_pct = ::std::option::Option::None;
    }

    pub fn has_packets_dropped_pct(&self) -> bool {
        self.packets_dropped_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_dropped_pct(&mut self, v: u32) {
        self.packets_dropped_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_weird_sequence_pct = 7;


    pub fn get_packets_weird_sequence_pct(&self) -> u32 {
        self.packets_weird_sequence_pct.unwrap_or(0)
    }
    pub fn clear_packets_weird_sequence_pct(&mut self) {
        self.packets_weird_sequence_pct = ::std::option::Option::None;
    }

    pub fn has_packets_weird_sequence_pct(&self) -> bool {
        self.packets_weird_sequence_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_weird_sequence_pct(&mut self, v: u32) {
        self.packets_weird_sequence_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 peak_jitter_usec = 8;


    pub fn get_peak_jitter_usec(&self) -> u32 {
        self.peak_jitter_usec.unwrap_or(0)
    }
    pub fn clear_peak_jitter_usec(&mut self) {
        self.peak_jitter_usec = ::std::option::Option::None;
    }

    pub fn has_peak_jitter_usec(&self) -> bool {
        self.peak_jitter_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peak_jitter_usec(&mut self, v: u32) {
        self.peak_jitter_usec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkInstantaneousStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.out_packets_per_sec_x10 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.out_bytes_per_sec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_packets_per_sec_x10 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_bytes_per_sec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packets_dropped_pct = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packets_weird_sequence_pct = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peak_jitter_usec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.out_packets_per_sec_x10 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.out_bytes_per_sec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_bytes_per_sec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_dropped_pct {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.peak_jitter_usec {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.out_packets_per_sec_x10 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.out_bytes_per_sec {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_bytes_per_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.packets_dropped_pct {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.peak_jitter_usec {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        CMsgSteamDatagramLinkInstantaneousStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "out_packets_per_sec_x10",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_packets_per_sec_x10 },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_packets_per_sec_x10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "out_bytes_per_sec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_bytes_per_sec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_bytes_per_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "in_packets_per_sec_x10",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_packets_per_sec_x10 },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_packets_per_sec_x10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "in_bytes_per_sec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_bytes_per_sec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_bytes_per_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packets_dropped_pct",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_dropped_pct },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_dropped_pct },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packets_weird_sequence_pct",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_weird_sequence_pct },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_weird_sequence_pct },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "peak_jitter_usec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.peak_jitter_usec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.peak_jitter_usec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramLinkInstantaneousStats>(
                "CMsgSteamDatagramLinkInstantaneousStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkInstantaneousStats {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramLinkInstantaneousStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramLinkInstantaneousStats::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramLinkInstantaneousStats {
    fn clear(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
        self.out_bytes_per_sec = ::std::option::Option::None;
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
        self.in_bytes_per_sec = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packets_dropped_pct = ::std::option::Option::None;
        self.packets_weird_sequence_pct = ::std::option::Option::None;
        self.peak_jitter_usec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramLinkInstantaneousStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkInstantaneousStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramLinkLifetimeStats {
    // message fields
    packets_sent: ::std::option::Option<u64>,
    kb_sent: ::std::option::Option<u64>,
    packets_recv: ::std::option::Option<u64>,
    kb_recv: ::std::option::Option<u64>,
    packets_recv_sequenced: ::std::option::Option<u64>,
    packets_recv_dropped: ::std::option::Option<u64>,
    packets_recv_out_of_order: ::std::option::Option<u64>,
    packets_recv_duplicate: ::std::option::Option<u64>,
    packets_recv_lurch: ::std::option::Option<u64>,
    quality_histogram_100: ::std::option::Option<u32>,
    quality_histogram_99: ::std::option::Option<u32>,
    quality_histogram_97: ::std::option::Option<u32>,
    quality_histogram_95: ::std::option::Option<u32>,
    quality_histogram_90: ::std::option::Option<u32>,
    quality_histogram_75: ::std::option::Option<u32>,
    quality_histogram_50: ::std::option::Option<u32>,
    quality_histogram_1: ::std::option::Option<u32>,
    quality_histogram_dead: ::std::option::Option<u32>,
    quality_ntile_2nd: ::std::option::Option<u32>,
    quality_ntile_5th: ::std::option::Option<u32>,
    quality_ntile_25th: ::std::option::Option<u32>,
    quality_ntile_50th: ::std::option::Option<u32>,
    ping_histogram_25: ::std::option::Option<u32>,
    ping_histogram_50: ::std::option::Option<u32>,
    ping_histogram_75: ::std::option::Option<u32>,
    ping_histogram_100: ::std::option::Option<u32>,
    ping_histogram_125: ::std::option::Option<u32>,
    ping_histogram_150: ::std::option::Option<u32>,
    ping_histogram_200: ::std::option::Option<u32>,
    ping_histogram_300: ::std::option::Option<u32>,
    ping_histogram_max: ::std::option::Option<u32>,
    ping_ntile_5th: ::std::option::Option<u32>,
    ping_ntile_50th: ::std::option::Option<u32>,
    ping_ntile_75th: ::std::option::Option<u32>,
    ping_ntile_95th: ::std::option::Option<u32>,
    ping_ntile_98th: ::std::option::Option<u32>,
    jitter_histogram_negligible: ::std::option::Option<u32>,
    jitter_histogram_1: ::std::option::Option<u32>,
    jitter_histogram_2: ::std::option::Option<u32>,
    jitter_histogram_5: ::std::option::Option<u32>,
    jitter_histogram_10: ::std::option::Option<u32>,
    jitter_histogram_20: ::std::option::Option<u32>,
    txspeed_max: ::std::option::Option<u32>,
    txspeed_histogram_16: ::std::option::Option<u32>,
    txspeed_histogram_32: ::std::option::Option<u32>,
    txspeed_histogram_64: ::std::option::Option<u32>,
    txspeed_histogram_128: ::std::option::Option<u32>,
    txspeed_histogram_256: ::std::option::Option<u32>,
    txspeed_histogram_512: ::std::option::Option<u32>,
    txspeed_histogram_1024: ::std::option::Option<u32>,
    txspeed_histogram_max: ::std::option::Option<u32>,
    txspeed_ntile_5th: ::std::option::Option<u32>,
    txspeed_ntile_50th: ::std::option::Option<u32>,
    txspeed_ntile_75th: ::std::option::Option<u32>,
    txspeed_ntile_95th: ::std::option::Option<u32>,
    txspeed_ntile_98th: ::std::option::Option<u32>,
    rxspeed_max: ::std::option::Option<u32>,
    rxspeed_histogram_16: ::std::option::Option<u32>,
    rxspeed_histogram_32: ::std::option::Option<u32>,
    rxspeed_histogram_64: ::std::option::Option<u32>,
    rxspeed_histogram_128: ::std::option::Option<u32>,
    rxspeed_histogram_256: ::std::option::Option<u32>,
    rxspeed_histogram_512: ::std::option::Option<u32>,
    rxspeed_histogram_1024: ::std::option::Option<u32>,
    rxspeed_histogram_max: ::std::option::Option<u32>,
    rxspeed_ntile_5th: ::std::option::Option<u32>,
    rxspeed_ntile_50th: ::std::option::Option<u32>,
    rxspeed_ntile_75th: ::std::option::Option<u32>,
    rxspeed_ntile_95th: ::std::option::Option<u32>,
    rxspeed_ntile_98th: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkLifetimeStats {
    fn default() -> &'a CMsgSteamDatagramLinkLifetimeStats {
        <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkLifetimeStats {
    pub fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        ::std::default::Default::default()
    }

    // optional uint64 packets_sent = 3;


    pub fn get_packets_sent(&self) -> u64 {
        self.packets_sent.unwrap_or(0)
    }
    pub fn clear_packets_sent(&mut self) {
        self.packets_sent = ::std::option::Option::None;
    }

    pub fn has_packets_sent(&self) -> bool {
        self.packets_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_sent(&mut self, v: u64) {
        self.packets_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_sent = 4;


    pub fn get_kb_sent(&self) -> u64 {
        self.kb_sent.unwrap_or(0)
    }
    pub fn clear_kb_sent(&mut self) {
        self.kb_sent = ::std::option::Option::None;
    }

    pub fn has_kb_sent(&self) -> bool {
        self.kb_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_sent(&mut self, v: u64) {
        self.kb_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv = 5;


    pub fn get_packets_recv(&self) -> u64 {
        self.packets_recv.unwrap_or(0)
    }
    pub fn clear_packets_recv(&mut self) {
        self.packets_recv = ::std::option::Option::None;
    }

    pub fn has_packets_recv(&self) -> bool {
        self.packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv(&mut self, v: u64) {
        self.packets_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_recv = 6;


    pub fn get_kb_recv(&self) -> u64 {
        self.kb_recv.unwrap_or(0)
    }
    pub fn clear_kb_recv(&mut self) {
        self.kb_recv = ::std::option::Option::None;
    }

    pub fn has_kb_recv(&self) -> bool {
        self.kb_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_recv(&mut self, v: u64) {
        self.kb_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_sequenced = 7;


    pub fn get_packets_recv_sequenced(&self) -> u64 {
        self.packets_recv_sequenced.unwrap_or(0)
    }
    pub fn clear_packets_recv_sequenced(&mut self) {
        self.packets_recv_sequenced = ::std::option::Option::None;
    }

    pub fn has_packets_recv_sequenced(&self) -> bool {
        self.packets_recv_sequenced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_sequenced(&mut self, v: u64) {
        self.packets_recv_sequenced = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_dropped = 8;


    pub fn get_packets_recv_dropped(&self) -> u64 {
        self.packets_recv_dropped.unwrap_or(0)
    }
    pub fn clear_packets_recv_dropped(&mut self) {
        self.packets_recv_dropped = ::std::option::Option::None;
    }

    pub fn has_packets_recv_dropped(&self) -> bool {
        self.packets_recv_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_dropped(&mut self, v: u64) {
        self.packets_recv_dropped = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order = 9;


    pub fn get_packets_recv_out_of_order(&self) -> u64 {
        self.packets_recv_out_of_order.unwrap_or(0)
    }
    pub fn clear_packets_recv_out_of_order(&mut self) {
        self.packets_recv_out_of_order = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order(&self) -> bool {
        self.packets_recv_out_of_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order(&mut self, v: u64) {
        self.packets_recv_out_of_order = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_duplicate = 10;


    pub fn get_packets_recv_duplicate(&self) -> u64 {
        self.packets_recv_duplicate.unwrap_or(0)
    }
    pub fn clear_packets_recv_duplicate(&mut self) {
        self.packets_recv_duplicate = ::std::option::Option::None;
    }

    pub fn has_packets_recv_duplicate(&self) -> bool {
        self.packets_recv_duplicate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_duplicate(&mut self, v: u64) {
        self.packets_recv_duplicate = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_lurch = 11;


    pub fn get_packets_recv_lurch(&self) -> u64 {
        self.packets_recv_lurch.unwrap_or(0)
    }
    pub fn clear_packets_recv_lurch(&mut self) {
        self.packets_recv_lurch = ::std::option::Option::None;
    }

    pub fn has_packets_recv_lurch(&self) -> bool {
        self.packets_recv_lurch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_lurch(&mut self, v: u64) {
        self.packets_recv_lurch = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_100 = 21;


    pub fn get_quality_histogram_100(&self) -> u32 {
        self.quality_histogram_100.unwrap_or(0)
    }
    pub fn clear_quality_histogram_100(&mut self) {
        self.quality_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_100(&self) -> bool {
        self.quality_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_100(&mut self, v: u32) {
        self.quality_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_99 = 22;


    pub fn get_quality_histogram_99(&self) -> u32 {
        self.quality_histogram_99.unwrap_or(0)
    }
    pub fn clear_quality_histogram_99(&mut self) {
        self.quality_histogram_99 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_99(&self) -> bool {
        self.quality_histogram_99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_99(&mut self, v: u32) {
        self.quality_histogram_99 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_97 = 23;


    pub fn get_quality_histogram_97(&self) -> u32 {
        self.quality_histogram_97.unwrap_or(0)
    }
    pub fn clear_quality_histogram_97(&mut self) {
        self.quality_histogram_97 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_97(&self) -> bool {
        self.quality_histogram_97.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_97(&mut self, v: u32) {
        self.quality_histogram_97 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_95 = 24;


    pub fn get_quality_histogram_95(&self) -> u32 {
        self.quality_histogram_95.unwrap_or(0)
    }
    pub fn clear_quality_histogram_95(&mut self) {
        self.quality_histogram_95 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_95(&self) -> bool {
        self.quality_histogram_95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_95(&mut self, v: u32) {
        self.quality_histogram_95 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_90 = 25;


    pub fn get_quality_histogram_90(&self) -> u32 {
        self.quality_histogram_90.unwrap_or(0)
    }
    pub fn clear_quality_histogram_90(&mut self) {
        self.quality_histogram_90 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_90(&self) -> bool {
        self.quality_histogram_90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_90(&mut self, v: u32) {
        self.quality_histogram_90 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_75 = 26;


    pub fn get_quality_histogram_75(&self) -> u32 {
        self.quality_histogram_75.unwrap_or(0)
    }
    pub fn clear_quality_histogram_75(&mut self) {
        self.quality_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_75(&self) -> bool {
        self.quality_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_75(&mut self, v: u32) {
        self.quality_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_50 = 27;


    pub fn get_quality_histogram_50(&self) -> u32 {
        self.quality_histogram_50.unwrap_or(0)
    }
    pub fn clear_quality_histogram_50(&mut self) {
        self.quality_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_50(&self) -> bool {
        self.quality_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_50(&mut self, v: u32) {
        self.quality_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_1 = 28;


    pub fn get_quality_histogram_1(&self) -> u32 {
        self.quality_histogram_1.unwrap_or(0)
    }
    pub fn clear_quality_histogram_1(&mut self) {
        self.quality_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_1(&self) -> bool {
        self.quality_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_1(&mut self, v: u32) {
        self.quality_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_dead = 29;


    pub fn get_quality_histogram_dead(&self) -> u32 {
        self.quality_histogram_dead.unwrap_or(0)
    }
    pub fn clear_quality_histogram_dead(&mut self) {
        self.quality_histogram_dead = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_dead(&self) -> bool {
        self.quality_histogram_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_dead(&mut self, v: u32) {
        self.quality_histogram_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_2nd = 30;


    pub fn get_quality_ntile_2nd(&self) -> u32 {
        self.quality_ntile_2nd.unwrap_or(0)
    }
    pub fn clear_quality_ntile_2nd(&mut self) {
        self.quality_ntile_2nd = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_2nd(&self) -> bool {
        self.quality_ntile_2nd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_2nd(&mut self, v: u32) {
        self.quality_ntile_2nd = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_5th = 31;


    pub fn get_quality_ntile_5th(&self) -> u32 {
        self.quality_ntile_5th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_5th(&mut self) {
        self.quality_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_5th(&self) -> bool {
        self.quality_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_5th(&mut self, v: u32) {
        self.quality_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_25th = 32;


    pub fn get_quality_ntile_25th(&self) -> u32 {
        self.quality_ntile_25th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_25th(&mut self) {
        self.quality_ntile_25th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_25th(&self) -> bool {
        self.quality_ntile_25th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_25th(&mut self, v: u32) {
        self.quality_ntile_25th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_50th = 33;


    pub fn get_quality_ntile_50th(&self) -> u32 {
        self.quality_ntile_50th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_50th(&mut self) {
        self.quality_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_50th(&self) -> bool {
        self.quality_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_50th(&mut self, v: u32) {
        self.quality_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_25 = 41;


    pub fn get_ping_histogram_25(&self) -> u32 {
        self.ping_histogram_25.unwrap_or(0)
    }
    pub fn clear_ping_histogram_25(&mut self) {
        self.ping_histogram_25 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_25(&self) -> bool {
        self.ping_histogram_25.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_25(&mut self, v: u32) {
        self.ping_histogram_25 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_50 = 42;


    pub fn get_ping_histogram_50(&self) -> u32 {
        self.ping_histogram_50.unwrap_or(0)
    }
    pub fn clear_ping_histogram_50(&mut self) {
        self.ping_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_50(&self) -> bool {
        self.ping_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_50(&mut self, v: u32) {
        self.ping_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_75 = 43;


    pub fn get_ping_histogram_75(&self) -> u32 {
        self.ping_histogram_75.unwrap_or(0)
    }
    pub fn clear_ping_histogram_75(&mut self) {
        self.ping_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_75(&self) -> bool {
        self.ping_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_75(&mut self, v: u32) {
        self.ping_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_100 = 44;


    pub fn get_ping_histogram_100(&self) -> u32 {
        self.ping_histogram_100.unwrap_or(0)
    }
    pub fn clear_ping_histogram_100(&mut self) {
        self.ping_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_100(&self) -> bool {
        self.ping_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_100(&mut self, v: u32) {
        self.ping_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_125 = 45;


    pub fn get_ping_histogram_125(&self) -> u32 {
        self.ping_histogram_125.unwrap_or(0)
    }
    pub fn clear_ping_histogram_125(&mut self) {
        self.ping_histogram_125 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_125(&self) -> bool {
        self.ping_histogram_125.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_125(&mut self, v: u32) {
        self.ping_histogram_125 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_150 = 46;


    pub fn get_ping_histogram_150(&self) -> u32 {
        self.ping_histogram_150.unwrap_or(0)
    }
    pub fn clear_ping_histogram_150(&mut self) {
        self.ping_histogram_150 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_150(&self) -> bool {
        self.ping_histogram_150.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_150(&mut self, v: u32) {
        self.ping_histogram_150 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_200 = 47;


    pub fn get_ping_histogram_200(&self) -> u32 {
        self.ping_histogram_200.unwrap_or(0)
    }
    pub fn clear_ping_histogram_200(&mut self) {
        self.ping_histogram_200 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_200(&self) -> bool {
        self.ping_histogram_200.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_200(&mut self, v: u32) {
        self.ping_histogram_200 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_300 = 48;


    pub fn get_ping_histogram_300(&self) -> u32 {
        self.ping_histogram_300.unwrap_or(0)
    }
    pub fn clear_ping_histogram_300(&mut self) {
        self.ping_histogram_300 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_300(&self) -> bool {
        self.ping_histogram_300.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_300(&mut self, v: u32) {
        self.ping_histogram_300 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_max = 49;


    pub fn get_ping_histogram_max(&self) -> u32 {
        self.ping_histogram_max.unwrap_or(0)
    }
    pub fn clear_ping_histogram_max(&mut self) {
        self.ping_histogram_max = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_max(&self) -> bool {
        self.ping_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_max(&mut self, v: u32) {
        self.ping_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_5th = 50;


    pub fn get_ping_ntile_5th(&self) -> u32 {
        self.ping_ntile_5th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_5th(&mut self) {
        self.ping_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_5th(&self) -> bool {
        self.ping_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_5th(&mut self, v: u32) {
        self.ping_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_50th = 51;


    pub fn get_ping_ntile_50th(&self) -> u32 {
        self.ping_ntile_50th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_50th(&mut self) {
        self.ping_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_50th(&self) -> bool {
        self.ping_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_50th(&mut self, v: u32) {
        self.ping_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_75th = 52;


    pub fn get_ping_ntile_75th(&self) -> u32 {
        self.ping_ntile_75th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_75th(&mut self) {
        self.ping_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_75th(&self) -> bool {
        self.ping_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_75th(&mut self, v: u32) {
        self.ping_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_95th = 53;


    pub fn get_ping_ntile_95th(&self) -> u32 {
        self.ping_ntile_95th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_95th(&mut self) {
        self.ping_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_95th(&self) -> bool {
        self.ping_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_95th(&mut self, v: u32) {
        self.ping_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_98th = 54;


    pub fn get_ping_ntile_98th(&self) -> u32 {
        self.ping_ntile_98th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_98th(&mut self) {
        self.ping_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_98th(&self) -> bool {
        self.ping_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_98th(&mut self, v: u32) {
        self.ping_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_negligible = 61;


    pub fn get_jitter_histogram_negligible(&self) -> u32 {
        self.jitter_histogram_negligible.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_negligible(&mut self) {
        self.jitter_histogram_negligible = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_negligible(&self) -> bool {
        self.jitter_histogram_negligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_negligible(&mut self, v: u32) {
        self.jitter_histogram_negligible = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_1 = 62;


    pub fn get_jitter_histogram_1(&self) -> u32 {
        self.jitter_histogram_1.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_1(&mut self) {
        self.jitter_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_1(&self) -> bool {
        self.jitter_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_1(&mut self, v: u32) {
        self.jitter_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_2 = 63;


    pub fn get_jitter_histogram_2(&self) -> u32 {
        self.jitter_histogram_2.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_2(&mut self) {
        self.jitter_histogram_2 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_2(&self) -> bool {
        self.jitter_histogram_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_2(&mut self, v: u32) {
        self.jitter_histogram_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_5 = 64;


    pub fn get_jitter_histogram_5(&self) -> u32 {
        self.jitter_histogram_5.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_5(&mut self) {
        self.jitter_histogram_5 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_5(&self) -> bool {
        self.jitter_histogram_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_5(&mut self, v: u32) {
        self.jitter_histogram_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_10 = 65;


    pub fn get_jitter_histogram_10(&self) -> u32 {
        self.jitter_histogram_10.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_10(&mut self) {
        self.jitter_histogram_10 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_10(&self) -> bool {
        self.jitter_histogram_10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_10(&mut self, v: u32) {
        self.jitter_histogram_10 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_20 = 66;


    pub fn get_jitter_histogram_20(&self) -> u32 {
        self.jitter_histogram_20.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_20(&mut self) {
        self.jitter_histogram_20 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_20(&self) -> bool {
        self.jitter_histogram_20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_20(&mut self, v: u32) {
        self.jitter_histogram_20 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_max = 67;


    pub fn get_txspeed_max(&self) -> u32 {
        self.txspeed_max.unwrap_or(0)
    }
    pub fn clear_txspeed_max(&mut self) {
        self.txspeed_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_max(&self) -> bool {
        self.txspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_max(&mut self, v: u32) {
        self.txspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_16 = 68;


    pub fn get_txspeed_histogram_16(&self) -> u32 {
        self.txspeed_histogram_16.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_16(&mut self) {
        self.txspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_16(&self) -> bool {
        self.txspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_16(&mut self, v: u32) {
        self.txspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_32 = 69;


    pub fn get_txspeed_histogram_32(&self) -> u32 {
        self.txspeed_histogram_32.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_32(&mut self) {
        self.txspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_32(&self) -> bool {
        self.txspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_32(&mut self, v: u32) {
        self.txspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_64 = 70;


    pub fn get_txspeed_histogram_64(&self) -> u32 {
        self.txspeed_histogram_64.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_64(&mut self) {
        self.txspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_64(&self) -> bool {
        self.txspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_64(&mut self, v: u32) {
        self.txspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_128 = 71;


    pub fn get_txspeed_histogram_128(&self) -> u32 {
        self.txspeed_histogram_128.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_128(&mut self) {
        self.txspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_128(&self) -> bool {
        self.txspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_128(&mut self, v: u32) {
        self.txspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_256 = 72;


    pub fn get_txspeed_histogram_256(&self) -> u32 {
        self.txspeed_histogram_256.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_256(&mut self) {
        self.txspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_256(&self) -> bool {
        self.txspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_256(&mut self, v: u32) {
        self.txspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_512 = 73;


    pub fn get_txspeed_histogram_512(&self) -> u32 {
        self.txspeed_histogram_512.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_512(&mut self) {
        self.txspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_512(&self) -> bool {
        self.txspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_512(&mut self, v: u32) {
        self.txspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_1024 = 74;


    pub fn get_txspeed_histogram_1024(&self) -> u32 {
        self.txspeed_histogram_1024.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_1024(&mut self) {
        self.txspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_1024(&self) -> bool {
        self.txspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_1024(&mut self, v: u32) {
        self.txspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_max = 75;


    pub fn get_txspeed_histogram_max(&self) -> u32 {
        self.txspeed_histogram_max.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_max(&mut self) {
        self.txspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_max(&self) -> bool {
        self.txspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_max(&mut self, v: u32) {
        self.txspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_5th = 76;


    pub fn get_txspeed_ntile_5th(&self) -> u32 {
        self.txspeed_ntile_5th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_5th(&mut self) {
        self.txspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_5th(&self) -> bool {
        self.txspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_5th(&mut self, v: u32) {
        self.txspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_50th = 77;


    pub fn get_txspeed_ntile_50th(&self) -> u32 {
        self.txspeed_ntile_50th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_50th(&mut self) {
        self.txspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_50th(&self) -> bool {
        self.txspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_50th(&mut self, v: u32) {
        self.txspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_75th = 78;


    pub fn get_txspeed_ntile_75th(&self) -> u32 {
        self.txspeed_ntile_75th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_75th(&mut self) {
        self.txspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_75th(&self) -> bool {
        self.txspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_75th(&mut self, v: u32) {
        self.txspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_95th = 79;


    pub fn get_txspeed_ntile_95th(&self) -> u32 {
        self.txspeed_ntile_95th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_95th(&mut self) {
        self.txspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_95th(&self) -> bool {
        self.txspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_95th(&mut self, v: u32) {
        self.txspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_98th = 80;


    pub fn get_txspeed_ntile_98th(&self) -> u32 {
        self.txspeed_ntile_98th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_98th(&mut self) {
        self.txspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_98th(&self) -> bool {
        self.txspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_98th(&mut self, v: u32) {
        self.txspeed_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_max = 81;


    pub fn get_rxspeed_max(&self) -> u32 {
        self.rxspeed_max.unwrap_or(0)
    }
    pub fn clear_rxspeed_max(&mut self) {
        self.rxspeed_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_max(&self) -> bool {
        self.rxspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_max(&mut self, v: u32) {
        self.rxspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_16 = 82;


    pub fn get_rxspeed_histogram_16(&self) -> u32 {
        self.rxspeed_histogram_16.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_16(&mut self) {
        self.rxspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_16(&self) -> bool {
        self.rxspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_16(&mut self, v: u32) {
        self.rxspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_32 = 83;


    pub fn get_rxspeed_histogram_32(&self) -> u32 {
        self.rxspeed_histogram_32.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_32(&mut self) {
        self.rxspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_32(&self) -> bool {
        self.rxspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_32(&mut self, v: u32) {
        self.rxspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_64 = 84;


    pub fn get_rxspeed_histogram_64(&self) -> u32 {
        self.rxspeed_histogram_64.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_64(&mut self) {
        self.rxspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_64(&self) -> bool {
        self.rxspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_64(&mut self, v: u32) {
        self.rxspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_128 = 85;


    pub fn get_rxspeed_histogram_128(&self) -> u32 {
        self.rxspeed_histogram_128.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_128(&mut self) {
        self.rxspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_128(&self) -> bool {
        self.rxspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_128(&mut self, v: u32) {
        self.rxspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_256 = 86;


    pub fn get_rxspeed_histogram_256(&self) -> u32 {
        self.rxspeed_histogram_256.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_256(&mut self) {
        self.rxspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_256(&self) -> bool {
        self.rxspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_256(&mut self, v: u32) {
        self.rxspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_512 = 87;


    pub fn get_rxspeed_histogram_512(&self) -> u32 {
        self.rxspeed_histogram_512.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_512(&mut self) {
        self.rxspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_512(&self) -> bool {
        self.rxspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_512(&mut self, v: u32) {
        self.rxspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_1024 = 88;


    pub fn get_rxspeed_histogram_1024(&self) -> u32 {
        self.rxspeed_histogram_1024.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_1024(&mut self) {
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_1024(&self) -> bool {
        self.rxspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_1024(&mut self, v: u32) {
        self.rxspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_max = 89;


    pub fn get_rxspeed_histogram_max(&self) -> u32 {
        self.rxspeed_histogram_max.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_max(&mut self) {
        self.rxspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_max(&self) -> bool {
        self.rxspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_max(&mut self, v: u32) {
        self.rxspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_5th = 90;


    pub fn get_rxspeed_ntile_5th(&self) -> u32 {
        self.rxspeed_ntile_5th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_5th(&mut self) {
        self.rxspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_5th(&self) -> bool {
        self.rxspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_5th(&mut self, v: u32) {
        self.rxspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_50th = 91;


    pub fn get_rxspeed_ntile_50th(&self) -> u32 {
        self.rxspeed_ntile_50th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_50th(&mut self) {
        self.rxspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_50th(&self) -> bool {
        self.rxspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_50th(&mut self, v: u32) {
        self.rxspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_75th = 92;


    pub fn get_rxspeed_ntile_75th(&self) -> u32 {
        self.rxspeed_ntile_75th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_75th(&mut self) {
        self.rxspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_75th(&self) -> bool {
        self.rxspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_75th(&mut self, v: u32) {
        self.rxspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_95th = 93;


    pub fn get_rxspeed_ntile_95th(&self) -> u32 {
        self.rxspeed_ntile_95th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_95th(&mut self) {
        self.rxspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_95th(&self) -> bool {
        self.rxspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_95th(&mut self, v: u32) {
        self.rxspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_98th = 94;


    pub fn get_rxspeed_ntile_98th(&self) -> u32 {
        self.rxspeed_ntile_98th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_98th(&mut self) {
        self.rxspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_98th(&self) -> bool {
        self.rxspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_98th(&mut self, v: u32) {
        self.rxspeed_ntile_98th = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkLifetimeStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_sent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kb_sent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kb_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_sequenced = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_dropped = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_out_of_order = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_duplicate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_lurch = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_100 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_99 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_97 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_95 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_90 = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_75 = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_50 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_1 = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_dead = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_2nd = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_5th = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_25th = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_50th = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_25 = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_50 = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_75 = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_100 = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_125 = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_150 = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_200 = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_300 = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_max = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_5th = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_50th = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_75th = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_95th = ::std::option::Option::Some(tmp);
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_98th = ::std::option::Option::Some(tmp);
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_negligible = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_1 = ::std::option::Option::Some(tmp);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_2 = ::std::option::Option::Some(tmp);
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_5 = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_10 = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_20 = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_max = ::std::option::Option::Some(tmp);
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_16 = ::std::option::Option::Some(tmp);
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_32 = ::std::option::Option::Some(tmp);
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_64 = ::std::option::Option::Some(tmp);
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_128 = ::std::option::Option::Some(tmp);
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_256 = ::std::option::Option::Some(tmp);
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_512 = ::std::option::Option::Some(tmp);
                },
                74 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_1024 = ::std::option::Option::Some(tmp);
                },
                75 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_max = ::std::option::Option::Some(tmp);
                },
                76 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_5th = ::std::option::Option::Some(tmp);
                },
                77 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_50th = ::std::option::Option::Some(tmp);
                },
                78 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_75th = ::std::option::Option::Some(tmp);
                },
                79 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_95th = ::std::option::Option::Some(tmp);
                },
                80 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_98th = ::std::option::Option::Some(tmp);
                },
                81 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_max = ::std::option::Option::Some(tmp);
                },
                82 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_16 = ::std::option::Option::Some(tmp);
                },
                83 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_32 = ::std::option::Option::Some(tmp);
                },
                84 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_64 = ::std::option::Option::Some(tmp);
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_128 = ::std::option::Option::Some(tmp);
                },
                86 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_256 = ::std::option::Option::Some(tmp);
                },
                87 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_512 = ::std::option::Option::Some(tmp);
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_1024 = ::std::option::Option::Some(tmp);
                },
                89 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_max = ::std::option::Option::Some(tmp);
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_5th = ::std::option::Option::Some(tmp);
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_50th = ::std::option::Option::Some(tmp);
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_75th = ::std::option::Option::Some(tmp);
                },
                93 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_95th = ::std::option::Option::Some(tmp);
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_98th = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packets_sent {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kb_sent {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kb_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_sequenced {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_dropped {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_out_of_order {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_duplicate {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_lurch {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_100 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_99 {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_97 {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_95 {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_90 {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_75 {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_50 {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_1 {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_dead {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_2nd {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_5th {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_25th {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_50th {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_25 {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_50 {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_75 {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_100 {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_125 {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_150 {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_200 {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_300 {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_max {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_5th {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_50th {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_75th {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_95th {
            my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_98th {
            my_size += ::protobuf::rt::value_size(54, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_negligible {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_1 {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_2 {
            my_size += ::protobuf::rt::value_size(63, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_5 {
            my_size += ::protobuf::rt::value_size(64, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_10 {
            my_size += ::protobuf::rt::value_size(65, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_20 {
            my_size += ::protobuf::rt::value_size(66, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_max {
            my_size += ::protobuf::rt::value_size(67, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_16 {
            my_size += ::protobuf::rt::value_size(68, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_32 {
            my_size += ::protobuf::rt::value_size(69, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_64 {
            my_size += ::protobuf::rt::value_size(70, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_128 {
            my_size += ::protobuf::rt::value_size(71, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_256 {
            my_size += ::protobuf::rt::value_size(72, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_512 {
            my_size += ::protobuf::rt::value_size(73, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            my_size += ::protobuf::rt::value_size(74, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_max {
            my_size += ::protobuf::rt::value_size(75, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_5th {
            my_size += ::protobuf::rt::value_size(76, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_50th {
            my_size += ::protobuf::rt::value_size(77, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_75th {
            my_size += ::protobuf::rt::value_size(78, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_95th {
            my_size += ::protobuf::rt::value_size(79, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_98th {
            my_size += ::protobuf::rt::value_size(80, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_max {
            my_size += ::protobuf::rt::value_size(81, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            my_size += ::protobuf::rt::value_size(82, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            my_size += ::protobuf::rt::value_size(83, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            my_size += ::protobuf::rt::value_size(84, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            my_size += ::protobuf::rt::value_size(85, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            my_size += ::protobuf::rt::value_size(86, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            my_size += ::protobuf::rt::value_size(87, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            my_size += ::protobuf::rt::value_size(88, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_max {
            my_size += ::protobuf::rt::value_size(89, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            my_size += ::protobuf::rt::value_size(90, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            my_size += ::protobuf::rt::value_size(91, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            my_size += ::protobuf::rt::value_size(92, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            my_size += ::protobuf::rt::value_size(93, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            my_size += ::protobuf::rt::value_size(94, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packets_sent {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.kb_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.packets_recv {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.kb_recv {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.packets_recv_sequenced {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.packets_recv_dropped {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.packets_recv_duplicate {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.packets_recv_lurch {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.quality_histogram_100 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.quality_histogram_99 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.quality_histogram_97 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.quality_histogram_95 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.quality_histogram_90 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.quality_histogram_75 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.quality_histogram_50 {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.quality_histogram_1 {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.quality_histogram_dead {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.quality_ntile_2nd {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.quality_ntile_5th {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.quality_ntile_25th {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.quality_ntile_50th {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ping_histogram_25 {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ping_histogram_50 {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.ping_histogram_75 {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.ping_histogram_100 {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.ping_histogram_125 {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.ping_histogram_150 {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.ping_histogram_200 {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.ping_histogram_300 {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.ping_histogram_max {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.ping_ntile_5th {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.ping_ntile_50th {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.ping_ntile_75th {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.ping_ntile_95th {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.ping_ntile_98th {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.jitter_histogram_negligible {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.jitter_histogram_1 {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.jitter_histogram_2 {
            os.write_uint32(63, v)?;
        }
        if let Some(v) = self.jitter_histogram_5 {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.jitter_histogram_10 {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.jitter_histogram_20 {
            os.write_uint32(66, v)?;
        }
        if let Some(v) = self.txspeed_max {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.txspeed_histogram_16 {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.txspeed_histogram_32 {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.txspeed_histogram_64 {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.txspeed_histogram_128 {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.txspeed_histogram_256 {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.txspeed_histogram_512 {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.txspeed_histogram_max {
            os.write_uint32(75, v)?;
        }
        if let Some(v) = self.txspeed_ntile_5th {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.txspeed_ntile_50th {
            os.write_uint32(77, v)?;
        }
        if let Some(v) = self.txspeed_ntile_75th {
            os.write_uint32(78, v)?;
        }
        if let Some(v) = self.txspeed_ntile_95th {
            os.write_uint32(79, v)?;
        }
        if let Some(v) = self.txspeed_ntile_98th {
            os.write_uint32(80, v)?;
        }
        if let Some(v) = self.rxspeed_max {
            os.write_uint32(81, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            os.write_uint32(82, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            os.write_uint32(83, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            os.write_uint32(84, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            os.write_uint32(88, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_max {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            os.write_uint32(93, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            os.write_uint32(94, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        CMsgSteamDatagramLinkLifetimeStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_sent",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_sent },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "kb_sent",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_sent },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "kb_recv",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_recv },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_sequenced",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_sequenced },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_sequenced },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_dropped",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_dropped },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_dropped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_out_of_order",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_out_of_order },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_out_of_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_duplicate",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_duplicate },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_duplicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_lurch",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_lurch },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_lurch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_100",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_100 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_100 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_99",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_99 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_99 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_97",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_97 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_97 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_95",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_95 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_95 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_90",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_90 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_90 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_75",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_75 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_75 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_50",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_50 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_1",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_1 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_dead",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_dead },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_2nd",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_2nd },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_2nd },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_25th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_25th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_25th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_25",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_25 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_25 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_50",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_50 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_75",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_75 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_75 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_100",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_100 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_100 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_125",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_125 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_125 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_150",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_150 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_150 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_200",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_200 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_200 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_300",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_300 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_300 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_98th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_negligible",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_negligible },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_negligible },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_1",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_1 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_2",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_2 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_5",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_5 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_10",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_10 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_20",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_20 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_20 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_16",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_16 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_32",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_32 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_32 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_64",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_64 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_128",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_128 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_128 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_256",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_256 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_512",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_512 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_512 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_1024",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_1024 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_1024 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_98th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_16",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_16 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_32",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_32 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_32 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_64",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_64 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_128",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_128 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_128 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_256",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_256 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_512",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_512 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_512 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_1024",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_1024 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_1024 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_98th },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramLinkLifetimeStats>(
                "CMsgSteamDatagramLinkLifetimeStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkLifetimeStats {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramLinkLifetimeStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramLinkLifetimeStats::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramLinkLifetimeStats {
    fn clear(&mut self) {
        self.packets_sent = ::std::option::Option::None;
        self.kb_sent = ::std::option::Option::None;
        self.packets_recv = ::std::option::Option::None;
        self.kb_recv = ::std::option::Option::None;
        self.packets_recv_sequenced = ::std::option::Option::None;
        self.packets_recv_dropped = ::std::option::Option::None;
        self.packets_recv_out_of_order = ::std::option::Option::None;
        self.packets_recv_duplicate = ::std::option::Option::None;
        self.packets_recv_lurch = ::std::option::Option::None;
        self.quality_histogram_100 = ::std::option::Option::None;
        self.quality_histogram_99 = ::std::option::Option::None;
        self.quality_histogram_97 = ::std::option::Option::None;
        self.quality_histogram_95 = ::std::option::Option::None;
        self.quality_histogram_90 = ::std::option::Option::None;
        self.quality_histogram_75 = ::std::option::Option::None;
        self.quality_histogram_50 = ::std::option::Option::None;
        self.quality_histogram_1 = ::std::option::Option::None;
        self.quality_histogram_dead = ::std::option::Option::None;
        self.quality_ntile_2nd = ::std::option::Option::None;
        self.quality_ntile_5th = ::std::option::Option::None;
        self.quality_ntile_25th = ::std::option::Option::None;
        self.quality_ntile_50th = ::std::option::Option::None;
        self.ping_histogram_25 = ::std::option::Option::None;
        self.ping_histogram_50 = ::std::option::Option::None;
        self.ping_histogram_75 = ::std::option::Option::None;
        self.ping_histogram_100 = ::std::option::Option::None;
        self.ping_histogram_125 = ::std::option::Option::None;
        self.ping_histogram_150 = ::std::option::Option::None;
        self.ping_histogram_200 = ::std::option::Option::None;
        self.ping_histogram_300 = ::std::option::Option::None;
        self.ping_histogram_max = ::std::option::Option::None;
        self.ping_ntile_5th = ::std::option::Option::None;
        self.ping_ntile_50th = ::std::option::Option::None;
        self.ping_ntile_75th = ::std::option::Option::None;
        self.ping_ntile_95th = ::std::option::Option::None;
        self.ping_ntile_98th = ::std::option::Option::None;
        self.jitter_histogram_negligible = ::std::option::Option::None;
        self.jitter_histogram_1 = ::std::option::Option::None;
        self.jitter_histogram_2 = ::std::option::Option::None;
        self.jitter_histogram_5 = ::std::option::Option::None;
        self.jitter_histogram_10 = ::std::option::Option::None;
        self.jitter_histogram_20 = ::std::option::Option::None;
        self.txspeed_max = ::std::option::Option::None;
        self.txspeed_histogram_16 = ::std::option::Option::None;
        self.txspeed_histogram_32 = ::std::option::Option::None;
        self.txspeed_histogram_64 = ::std::option::Option::None;
        self.txspeed_histogram_128 = ::std::option::Option::None;
        self.txspeed_histogram_256 = ::std::option::Option::None;
        self.txspeed_histogram_512 = ::std::option::Option::None;
        self.txspeed_histogram_1024 = ::std::option::Option::None;
        self.txspeed_histogram_max = ::std::option::Option::None;
        self.txspeed_ntile_5th = ::std::option::Option::None;
        self.txspeed_ntile_50th = ::std::option::Option::None;
        self.txspeed_ntile_75th = ::std::option::Option::None;
        self.txspeed_ntile_95th = ::std::option::Option::None;
        self.txspeed_ntile_98th = ::std::option::Option::None;
        self.rxspeed_max = ::std::option::Option::None;
        self.rxspeed_histogram_16 = ::std::option::Option::None;
        self.rxspeed_histogram_32 = ::std::option::Option::None;
        self.rxspeed_histogram_64 = ::std::option::Option::None;
        self.rxspeed_histogram_128 = ::std::option::Option::None;
        self.rxspeed_histogram_256 = ::std::option::Option::None;
        self.rxspeed_histogram_512 = ::std::option::Option::None;
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
        self.rxspeed_histogram_max = ::std::option::Option::None;
        self.rxspeed_ntile_5th = ::std::option::Option::None;
        self.rxspeed_ntile_50th = ::std::option::Option::None;
        self.rxspeed_ntile_75th = ::std::option::Option::None;
        self.rxspeed_ntile_95th = ::std::option::Option::None;
        self.rxspeed_ntile_98th = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramLinkLifetimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkLifetimeStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionQuality {
    // message fields
    pub instantaneous: ::protobuf::SingularPtrField<CMsgSteamDatagramLinkInstantaneousStats>,
    pub lifetime: ::protobuf::SingularPtrField<CMsgSteamDatagramLinkLifetimeStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionQuality {
    fn default() -> &'a CMsgSteamDatagramConnectionQuality {
        <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionQuality {
    pub fn new() -> CMsgSteamDatagramConnectionQuality {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1;


    pub fn get_instantaneous(&self) -> &CMsgSteamDatagramLinkInstantaneousStats {
        self.instantaneous.as_ref().unwrap_or_else(|| <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instantaneous(&mut self) {
        self.instantaneous.clear();
    }

    pub fn has_instantaneous(&self) -> bool {
        self.instantaneous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instantaneous(&mut self, v: CMsgSteamDatagramLinkInstantaneousStats) {
        self.instantaneous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instantaneous(&mut self) -> &mut CMsgSteamDatagramLinkInstantaneousStats {
        if self.instantaneous.is_none() {
            self.instantaneous.set_default();
        }
        self.instantaneous.as_mut().unwrap()
    }

    // Take field
    pub fn take_instantaneous(&mut self) -> CMsgSteamDatagramLinkInstantaneousStats {
        self.instantaneous.take().unwrap_or_else(|| CMsgSteamDatagramLinkInstantaneousStats::new())
    }

    // optional .CMsgSteamDatagramLinkLifetimeStats lifetime = 2;


    pub fn get_lifetime(&self) -> &CMsgSteamDatagramLinkLifetimeStats {
        self.lifetime.as_ref().unwrap_or_else(|| <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifetime(&mut self) {
        self.lifetime.clear();
    }

    pub fn has_lifetime(&self) -> bool {
        self.lifetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime(&mut self, v: CMsgSteamDatagramLinkLifetimeStats) {
        self.lifetime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifetime(&mut self) -> &mut CMsgSteamDatagramLinkLifetimeStats {
        if self.lifetime.is_none() {
            self.lifetime.set_default();
        }
        self.lifetime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifetime(&mut self) -> CMsgSteamDatagramLinkLifetimeStats {
        self.lifetime.take().unwrap_or_else(|| CMsgSteamDatagramLinkLifetimeStats::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionQuality {
    fn is_initialized(&self) -> bool {
        for v in &self.instantaneous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifetime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instantaneous)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifetime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instantaneous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instantaneous.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifetime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionQuality {
        CMsgSteamDatagramConnectionQuality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramLinkInstantaneousStats>>(
                "instantaneous",
                |m: &CMsgSteamDatagramConnectionQuality| { &m.instantaneous },
                |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.instantaneous },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramLinkLifetimeStats>>(
                "lifetime",
                |m: &CMsgSteamDatagramConnectionQuality| { &m.lifetime },
                |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.lifetime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionQuality>(
                "CMsgSteamDatagramConnectionQuality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionQuality {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionQuality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionQuality::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionQuality {
    fn clear(&mut self) {
        self.instantaneous.clear();
        self.lifetime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionQuality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
    // message fields
    pub c2r: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub c2s: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    legacy_client_timestamp: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    seq_num_c2r: ::std::option::Option<u32>,
    seq_num_c2s: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsClientToRouter {
        <CMsgSteamDatagramConnectionStatsClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality c2r = 1;


    pub fn get_c2r(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.c2r.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_c2r(&mut self) {
        self.c2r.clear();
    }

    pub fn has_c2r(&self) -> bool {
        self.c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c2r(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.c2r = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c2r(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.c2r.is_none() {
            self.c2r.set_default();
        }
        self.c2r.as_mut().unwrap()
    }

    // Take field
    pub fn take_c2r(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.c2r.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality c2s = 2;


    pub fn get_c2s(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.c2s.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_c2s(&mut self) {
        self.c2s.clear();
    }

    pub fn has_c2s(&self) -> bool {
        self.c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c2s(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.c2s = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c2s(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.c2s.is_none() {
            self.c2s.set_default();
        }
        self.c2s.as_mut().unwrap()
    }

    // Take field
    pub fn take_c2s(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.c2s.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional fixed32 legacy_client_timestamp = 3;


    pub fn get_legacy_client_timestamp(&self) -> u32 {
        self.legacy_client_timestamp.unwrap_or(0)
    }
    pub fn clear_legacy_client_timestamp(&mut self) {
        self.legacy_client_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp(&self) -> bool {
        self.legacy_client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp(&mut self, v: u32) {
        self.legacy_client_timestamp = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 4;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 5;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 6;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 8;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 9;


    pub fn get_seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }
    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 10;


    pub fn get_seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }
    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.c2r {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.c2s {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.c2r)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.c2s)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2r = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2s = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.c2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp {
            my_size += 5;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.c2r.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.legacy_client_timestamp {
            os.write_fixed32(3, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(4, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(5, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        CMsgSteamDatagramConnectionStatsClientToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "c2r",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "c2s",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.c2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_timestamp",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.legacy_client_timestamp },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.legacy_client_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2r",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2s",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2s },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsClientToRouter>(
                "CMsgSteamDatagramConnectionStatsClientToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsClientToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsClientToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsClientToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn clear(&mut self) {
        self.c2r.clear();
        self.c2s.clear();
        self.legacy_client_timestamp = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsClientToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsClientToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsClientToRouter_Flags>("CMsgSteamDatagramConnectionStatsClientToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
    // message fields
    pub r2c: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub s2c: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    legacy_client_timestamp_from_router: ::std::option::Option<u32>,
    legacy_client_timestamp_from_server: ::std::option::Option<u32>,
    router_gameserver_latency: ::std::option::Option<u32>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    migrate_request_ip: ::std::option::Option<u32>,
    migrate_request_port: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    seq_num_s2c: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToClient {
        <CMsgSteamDatagramConnectionStatsRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality r2c = 1;


    pub fn get_r2c(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.r2c.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_r2c(&mut self) {
        self.r2c.clear();
    }

    pub fn has_r2c(&self) -> bool {
        self.r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r2c(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.r2c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r2c(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.r2c.is_none() {
            self.r2c.set_default();
        }
        self.r2c.as_mut().unwrap()
    }

    // Take field
    pub fn take_r2c(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.r2c.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality s2c = 2;


    pub fn get_s2c(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.s2c.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_s2c(&mut self) {
        self.s2c.clear();
    }

    pub fn has_s2c(&self) -> bool {
        self.s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s2c(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.s2c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s2c(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.s2c.is_none() {
            self.s2c.set_default();
        }
        self.s2c.as_mut().unwrap()
    }

    // Take field
    pub fn take_s2c(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.s2c.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional fixed32 legacy_client_timestamp_from_router = 3;


    pub fn get_legacy_client_timestamp_from_router(&self) -> u32 {
        self.legacy_client_timestamp_from_router.unwrap_or(0)
    }
    pub fn clear_legacy_client_timestamp_from_router(&mut self) {
        self.legacy_client_timestamp_from_router = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp_from_router(&self) -> bool {
        self.legacy_client_timestamp_from_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp_from_router(&mut self, v: u32) {
        self.legacy_client_timestamp_from_router = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_client_timestamp_from_server = 4;


    pub fn get_legacy_client_timestamp_from_server(&self) -> u32 {
        self.legacy_client_timestamp_from_server.unwrap_or(0)
    }
    pub fn clear_legacy_client_timestamp_from_server(&mut self) {
        self.legacy_client_timestamp_from_server = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp_from_server(&self) -> bool {
        self.legacy_client_timestamp_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp_from_server(&mut self, v: u32) {
        self.legacy_client_timestamp_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;


    pub fn get_router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }
    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 6;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 10;


    pub fn get_migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }
    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 11;


    pub fn get_migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }
    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 12;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 13;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 14;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 15;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 8;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 9;


    pub fn get_seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }
    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.r2c {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.s2c {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.r2c)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.s2c)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_timestamp_from_router = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_timestamp_from_server = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.router_gameserver_latency = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.migrate_request_ip = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.migrate_request_port = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_s2c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.r2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp_from_router {
            my_size += 5;
        }
        if let Some(v) = self.legacy_client_timestamp_from_server {
            my_size += 5;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 5;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.r2c.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.s2c.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.legacy_client_timestamp_from_router {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_client_timestamp_from_server {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(12, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(13, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(14, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        CMsgSteamDatagramConnectionStatsRouterToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "r2c",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "s2c",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.s2c },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.s2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_timestamp_from_router",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.legacy_client_timestamp_from_router },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.legacy_client_timestamp_from_router },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_timestamp_from_server",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.legacy_client_timestamp_from_server },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.legacy_client_timestamp_from_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "router_gameserver_latency",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.router_gameserver_latency },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.router_gameserver_latency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "migrate_request_ip",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_ip },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "migrate_request_port",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_port },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_s2c",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_s2c },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_s2c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToClient>(
                "CMsgSteamDatagramConnectionStatsRouterToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsRouterToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsRouterToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn clear(&mut self) {
        self.r2c.clear();
        self.s2c.clear();
        self.legacy_client_timestamp_from_router = ::std::option::Option::None;
        self.legacy_client_timestamp_from_server = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsRouterToClient_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsRouterToClient_Flags] = &[
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToClient_Flags>("CMsgSteamDatagramConnectionStatsRouterToClient.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
    // message fields
    pub r2s: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub c2s: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    legacy_client_timestamp: ::std::option::Option<u32>,
    legacy_router_timestamp: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    seq_num_r2s: ::std::option::Option<u32>,
    seq_num_c2s: ::std::option::Option<u32>,
    client_steam_id: ::std::option::Option<u64>,
    relay_session_id: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToServer {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToServer {
        <CMsgSteamDatagramConnectionStatsRouterToServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToServer {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality r2s = 1;


    pub fn get_r2s(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.r2s.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_r2s(&mut self) {
        self.r2s.clear();
    }

    pub fn has_r2s(&self) -> bool {
        self.r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r2s(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.r2s = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r2s(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.r2s.is_none() {
            self.r2s.set_default();
        }
        self.r2s.as_mut().unwrap()
    }

    // Take field
    pub fn take_r2s(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.r2s.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality c2s = 2;


    pub fn get_c2s(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.c2s.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_c2s(&mut self) {
        self.c2s.clear();
    }

    pub fn has_c2s(&self) -> bool {
        self.c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c2s(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.c2s = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c2s(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.c2s.is_none() {
            self.c2s.set_default();
        }
        self.c2s.as_mut().unwrap()
    }

    // Take field
    pub fn take_c2s(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.c2s.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional fixed32 legacy_client_timestamp = 3;


    pub fn get_legacy_client_timestamp(&self) -> u32 {
        self.legacy_client_timestamp.unwrap_or(0)
    }
    pub fn clear_legacy_client_timestamp(&mut self) {
        self.legacy_client_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp(&self) -> bool {
        self.legacy_client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp(&mut self, v: u32) {
        self.legacy_client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_router_timestamp = 4;


    pub fn get_legacy_router_timestamp(&self) -> u32 {
        self.legacy_router_timestamp.unwrap_or(0)
    }
    pub fn clear_legacy_router_timestamp(&mut self) {
        self.legacy_router_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_router_timestamp(&self) -> bool {
        self.legacy_router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_router_timestamp(&mut self, v: u32) {
        self.legacy_router_timestamp = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 10;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 11;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 12;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2s = 5;


    pub fn get_seq_num_r2s(&self) -> u32 {
        self.seq_num_r2s.unwrap_or(0)
    }
    pub fn clear_seq_num_r2s(&mut self) {
        self.seq_num_r2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2s(&self) -> bool {
        self.seq_num_r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2s(&mut self, v: u32) {
        self.seq_num_r2s = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 6;


    pub fn get_seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }
    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 7;


    pub fn get_client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }
    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 9;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 13;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn is_initialized(&self) -> bool {
        for v in &self.r2s {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.c2s {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.r2s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.c2s)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_router_timestamp = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2s = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2s = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.client_steam_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.r2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.legacy_router_timestamp {
            my_size += 5;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_r2s {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.r2s.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.legacy_client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_router_timestamp {
            os.write_fixed32(4, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(11, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.seq_num_r2s {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        CMsgSteamDatagramConnectionStatsRouterToServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "r2s",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.r2s },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.r2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "c2s",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.c2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_timestamp",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_client_timestamp },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_client_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_router_timestamp",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_router_timestamp },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_router_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2s",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_r2s },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_r2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2s",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_c2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "client_steam_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_steam_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.server_connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToServer>(
                "CMsgSteamDatagramConnectionStatsRouterToServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToServer {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsRouterToServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsRouterToServer::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn clear(&mut self) {
        self.r2s.clear();
        self.c2s.clear();
        self.legacy_client_timestamp = ::std::option::Option::None;
        self.legacy_router_timestamp = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_r2s = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsRouterToServer_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsRouterToServer_Flags] = &[
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToServer_Flags>("CMsgSteamDatagramConnectionStatsRouterToServer.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
    // message fields
    pub s2r: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub s2c: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    seq_num_s2r: ::std::option::Option<u32>,
    seq_num_s2c: ::std::option::Option<u32>,
    client_steam_id: ::std::option::Option<u64>,
    relay_session_id: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsServerToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsServerToRouter {
        <CMsgSteamDatagramConnectionStatsServerToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsServerToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality s2r = 1;


    pub fn get_s2r(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.s2r.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_s2r(&mut self) {
        self.s2r.clear();
    }

    pub fn has_s2r(&self) -> bool {
        self.s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s2r(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.s2r = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s2r(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.s2r.is_none() {
            self.s2r.set_default();
        }
        self.s2r.as_mut().unwrap()
    }

    // Take field
    pub fn take_s2r(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.s2r.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality s2c = 2;


    pub fn get_s2c(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.s2c.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_s2c(&mut self) {
        self.s2c.clear();
    }

    pub fn has_s2c(&self) -> bool {
        self.s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s2c(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.s2c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s2c(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.s2c.is_none() {
            self.s2c.set_default();
        }
        self.s2c.as_mut().unwrap()
    }

    // Take field
    pub fn take_s2c(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.s2c.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 8;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 9;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 10;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2r = 3;


    pub fn get_seq_num_s2r(&self) -> u32 {
        self.seq_num_s2r.unwrap_or(0)
    }
    pub fn clear_seq_num_s2r(&mut self) {
        self.seq_num_s2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2r(&self) -> bool {
        self.seq_num_s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2r(&mut self, v: u32) {
        self.seq_num_s2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 4;


    pub fn get_seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }
    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 5;


    pub fn get_client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }
    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 6;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 11;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.s2r {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.s2c {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.s2r)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.s2c)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_s2r = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_s2c = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.client_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.s2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_s2r {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.s2r.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.s2c.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(8, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(9, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.seq_num_s2r {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        CMsgSteamDatagramConnectionStatsServerToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "s2r",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.s2r },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.s2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "s2c",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.s2c },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.s2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_s2r",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2r },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_s2c",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2c },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "client_steam_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_steam_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.server_connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsServerToRouter>(
                "CMsgSteamDatagramConnectionStatsServerToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsServerToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsServerToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsServerToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn clear(&mut self) {
        self.s2r.clear();
        self.s2c.clear();
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_s2r = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsServerToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsServerToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsServerToRouter_Flags>("CMsgSteamDatagramConnectionStatsServerToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleRequest {
    // message fields
    connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleRequest {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleRequest {
        <CMsgSteamDatagramClientPingSampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleRequest {
    pub fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        CMsgSteamDatagramClientPingSampleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientPingSampleRequest| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientPingSampleRequest| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleRequest>(
                "CMsgSteamDatagramClientPingSampleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleRequest {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply {
    // message fields
    connection_id: ::std::option::Option<u32>,
    pub routing_clusters: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_RoutingCluster>,
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_DataCenter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply {
        <CMsgSteamDatagramClientPingSampleReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramClientPingSampleReply.RoutingCluster routing_clusters = 2;


    pub fn get_routing_clusters(&self) -> &[CMsgSteamDatagramClientPingSampleReply_RoutingCluster] {
        &self.routing_clusters
    }
    pub fn clear_routing_clusters(&mut self) {
        self.routing_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_routing_clusters(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_RoutingCluster>) {
        self.routing_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routing_clusters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_RoutingCluster> {
        &mut self.routing_clusters
    }

    // Take field
    pub fn take_routing_clusters(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_RoutingCluster> {
        ::std::mem::replace(&mut self.routing_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramClientPingSampleReply.DataCenter data_centers = 3;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramClientPingSampleReply_DataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_DataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_DataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_DataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply {
    fn is_initialized(&self) -> bool {
        for v in &self.routing_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routing_clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        for value in &self.routing_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        for v in &self.routing_clusters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.data_centers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply {
        CMsgSteamDatagramClientPingSampleReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientPingSampleReply_RoutingCluster>>(
                "routing_clusters",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.routing_clusters },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.routing_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientPingSampleReply_DataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.data_centers },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.data_centers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply>(
                "CMsgSteamDatagramClientPingSampleReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.routing_clusters.clear();
        self.data_centers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    // message fields
    id: ::std::option::Option<u32>,
    front_ping_ms: ::std::option::Option<u32>,
    e2e_ping_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
        <CMsgSteamDatagramClientPingSampleReply_RoutingCluster as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
        ::std::default::Default::default()
    }

    // optional fixed32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 front_ping_ms = 2;


    pub fn get_front_ping_ms(&self) -> u32 {
        self.front_ping_ms.unwrap_or(0)
    }
    pub fn clear_front_ping_ms(&mut self) {
        self.front_ping_ms = ::std::option::Option::None;
    }

    pub fn has_front_ping_ms(&self) -> bool {
        self.front_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_ping_ms(&mut self, v: u32) {
        self.front_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 e2e_ping_ms = 3;


    pub fn get_e2e_ping_ms(&self) -> u32 {
        self.e2e_ping_ms.unwrap_or(0)
    }
    pub fn clear_e2e_ping_ms(&mut self) {
        self.e2e_ping_ms = ::std::option::Option::None;
    }

    pub fn has_e2e_ping_ms(&self) -> bool {
        self.e2e_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_ping_ms(&mut self, v: u32) {
        self.e2e_ping_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.front_ping_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.e2e_ping_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 5;
        }
        if let Some(v) = self.front_ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.e2e_ping_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.front_ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.e2e_ping_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
        CMsgSteamDatagramClientPingSampleReply_RoutingCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "id",
                |m: &CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &m.id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "front_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &m.front_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &mut m.front_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "e2e_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &m.e2e_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_RoutingCluster| { &mut m.e2e_ping_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply_RoutingCluster>(
                "CMsgSteamDatagramClientPingSampleReply.RoutingCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply_RoutingCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply_RoutingCluster::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.front_ping_ms = ::std::option::Option::None;
        self.e2e_ping_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply_DataCenter {
    // message fields
    data_center_id: ::std::option::Option<u32>,
    via_relay_id: ::std::option::Option<u32>,
    e2e_ping_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply_DataCenter {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply_DataCenter {
        <CMsgSteamDatagramClientPingSampleReply_DataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply_DataCenter {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply_DataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 via_relay_id = 2;


    pub fn get_via_relay_id(&self) -> u32 {
        self.via_relay_id.unwrap_or(0)
    }
    pub fn clear_via_relay_id(&mut self) {
        self.via_relay_id = ::std::option::Option::None;
    }

    pub fn has_via_relay_id(&self) -> bool {
        self.via_relay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_via_relay_id(&mut self, v: u32) {
        self.via_relay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 e2e_ping_ms = 3;


    pub fn get_e2e_ping_ms(&self) -> u32 {
        self.e2e_ping_ms.unwrap_or(0)
    }
    pub fn clear_e2e_ping_ms(&mut self) {
        self.e2e_ping_ms = ::std::option::Option::None;
    }

    pub fn has_e2e_ping_ms(&self) -> bool {
        self.e2e_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_ping_ms(&mut self, v: u32) {
        self.e2e_ping_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply_DataCenter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.via_relay_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.e2e_ping_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.via_relay_id {
            my_size += 5;
        }
        if let Some(v) = self.e2e_ping_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.via_relay_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.e2e_ping_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply_DataCenter {
        CMsgSteamDatagramClientPingSampleReply_DataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "data_center_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_DataCenter| { &m.data_center_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_DataCenter| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "via_relay_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_DataCenter| { &m.via_relay_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_DataCenter| { &mut m.via_relay_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "e2e_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_DataCenter| { &m.e2e_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_DataCenter| { &mut m.e2e_ping_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply_DataCenter>(
                "CMsgSteamDatagramClientPingSampleReply.DataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply_DataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply_DataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply_DataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply_DataCenter {
    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.via_relay_id = ::std::option::Option::None;
        self.e2e_ping_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply_DataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply_DataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientSwitchedPrimary {
    // message fields
    connection_id: ::std::option::Option<u32>,
    from_ip: ::std::option::Option<u32>,
    from_port: ::std::option::Option<u32>,
    from_router_cluster: ::std::option::Option<u32>,
    from_active_time: ::std::option::Option<u32>,
    from_active_packets_recv: ::std::option::Option<u32>,
    from_dropped_reason: ::protobuf::SingularField<::std::string::String>,
    gap_ms: ::std::option::Option<u32>,
    pub from_quality_now: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub to_quality_now: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub from_quality_then: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub to_quality_then: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary {
        <CMsgSteamDatagramClientSwitchedPrimary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_ip = 2;


    pub fn get_from_ip(&self) -> u32 {
        self.from_ip.unwrap_or(0)
    }
    pub fn clear_from_ip(&mut self) {
        self.from_ip = ::std::option::Option::None;
    }

    pub fn has_from_ip(&self) -> bool {
        self.from_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_ip(&mut self, v: u32) {
        self.from_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 from_port = 3;


    pub fn get_from_port(&self) -> u32 {
        self.from_port.unwrap_or(0)
    }
    pub fn clear_from_port(&mut self) {
        self.from_port = ::std::option::Option::None;
    }

    pub fn has_from_port(&self) -> bool {
        self.from_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_port(&mut self, v: u32) {
        self.from_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_router_cluster = 4;


    pub fn get_from_router_cluster(&self) -> u32 {
        self.from_router_cluster.unwrap_or(0)
    }
    pub fn clear_from_router_cluster(&mut self) {
        self.from_router_cluster = ::std::option::Option::None;
    }

    pub fn has_from_router_cluster(&self) -> bool {
        self.from_router_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_router_cluster(&mut self, v: u32) {
        self.from_router_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_time = 5;


    pub fn get_from_active_time(&self) -> u32 {
        self.from_active_time.unwrap_or(0)
    }
    pub fn clear_from_active_time(&mut self) {
        self.from_active_time = ::std::option::Option::None;
    }

    pub fn has_from_active_time(&self) -> bool {
        self.from_active_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_time(&mut self, v: u32) {
        self.from_active_time = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_packets_recv = 6;


    pub fn get_from_active_packets_recv(&self) -> u32 {
        self.from_active_packets_recv.unwrap_or(0)
    }
    pub fn clear_from_active_packets_recv(&mut self) {
        self.from_active_packets_recv = ::std::option::Option::None;
    }

    pub fn has_from_active_packets_recv(&self) -> bool {
        self.from_active_packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_packets_recv(&mut self, v: u32) {
        self.from_active_packets_recv = ::std::option::Option::Some(v);
    }

    // optional string from_dropped_reason = 7;


    pub fn get_from_dropped_reason(&self) -> &str {
        match self.from_dropped_reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from_dropped_reason(&mut self) {
        self.from_dropped_reason.clear();
    }

    pub fn has_from_dropped_reason(&self) -> bool {
        self.from_dropped_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_dropped_reason(&mut self, v: ::std::string::String) {
        self.from_dropped_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_dropped_reason(&mut self) -> &mut ::std::string::String {
        if self.from_dropped_reason.is_none() {
            self.from_dropped_reason.set_default();
        }
        self.from_dropped_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_dropped_reason(&mut self) -> ::std::string::String {
        self.from_dropped_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gap_ms = 8;


    pub fn get_gap_ms(&self) -> u32 {
        self.gap_ms.unwrap_or(0)
    }
    pub fn clear_gap_ms(&mut self) {
        self.gap_ms = ::std::option::Option::None;
    }

    pub fn has_gap_ms(&self) -> bool {
        self.gap_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gap_ms(&mut self, v: u32) {
        self.gap_ms = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;


    pub fn get_from_quality_now(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_now.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_quality_now(&mut self) {
        self.from_quality_now.clear();
    }

    pub fn has_from_quality_now(&self) -> bool {
        self.from_quality_now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_quality_now(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.from_quality_now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_quality_now(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.from_quality_now.is_none() {
            self.from_quality_now.set_default();
        }
        self.from_quality_now.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_quality_now(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_now.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;


    pub fn get_to_quality_now(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_now.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to_quality_now(&mut self) {
        self.to_quality_now.clear();
    }

    pub fn has_to_quality_now(&self) -> bool {
        self.to_quality_now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_quality_now(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.to_quality_now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_quality_now(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.to_quality_now.is_none() {
            self.to_quality_now.set_default();
        }
        self.to_quality_now.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_quality_now(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_now.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;


    pub fn get_from_quality_then(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_then.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_quality_then(&mut self) {
        self.from_quality_then.clear();
    }

    pub fn has_from_quality_then(&self) -> bool {
        self.from_quality_then.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_quality_then(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.from_quality_then = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_quality_then(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.from_quality_then.is_none() {
            self.from_quality_then.set_default();
        }
        self.from_quality_then.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_quality_then(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_then.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;


    pub fn get_to_quality_then(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_then.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to_quality_then(&mut self) {
        self.to_quality_then.clear();
    }

    pub fn has_to_quality_then(&self) -> bool {
        self.to_quality_then.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_quality_then(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.to_quality_then = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_quality_then(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.to_quality_then.is_none() {
            self.to_quality_then.set_default();
        }
        self.to_quality_then.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_quality_then(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_then.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary {
    fn is_initialized(&self) -> bool {
        for v in &self.from_quality_now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to_quality_now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.from_quality_then {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to_quality_then {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_router_cluster = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_active_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_active_packets_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from_dropped_reason)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gap_ms = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_quality_now)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_quality_now)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_quality_then)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_quality_then)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_ip {
            my_size += 5;
        }
        if let Some(v) = self.from_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_router_cluster {
            my_size += 5;
        }
        if let Some(v) = self.from_active_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_active_packets_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.from_dropped_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gap_ms {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.from_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.from_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.from_router_cluster {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_active_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.from_active_packets_recv {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.from_dropped_reason.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.gap_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.from_quality_now.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to_quality_now.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.from_quality_then.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to_quality_then.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        CMsgSteamDatagramClientSwitchedPrimary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_ip",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_ip },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_port",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_port },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_router_cluster",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_router_cluster },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_router_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_active_time",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_time },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_active_packets_recv",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_packets_recv },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_packets_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_dropped_reason",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_dropped_reason },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_dropped_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gap_ms",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.gap_ms },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.gap_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "from_quality_now",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_now },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_now },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "to_quality_now",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_now },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_now },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "from_quality_then",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_then },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_then },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "to_quality_then",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_then },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_then },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientSwitchedPrimary>(
                "CMsgSteamDatagramClientSwitchedPrimary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientSwitchedPrimary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientSwitchedPrimary::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientSwitchedPrimary {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.from_ip = ::std::option::Option::None;
        self.from_port = ::std::option::Option::None;
        self.from_router_cluster = ::std::option::Option::None;
        self.from_active_time = ::std::option::Option::None;
        self.from_active_packets_recv = ::std::option::Option::None;
        self.from_dropped_reason.clear();
        self.gap_ms = ::std::option::Option::None;
        self.from_quality_now.clear();
        self.to_quality_now.clear();
        self.from_quality_then.clear();
        self.to_quality_then.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientSwitchedPrimary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    // message fields
    score: ::std::option::Option<u32>,
    front_ping: ::std::option::Option<u32>,
    back_ping: ::std::option::Option<u32>,
    seconds_until_down: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        ::std::default::Default::default()
    }

    // optional uint32 score = 1;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 front_ping = 2;


    pub fn get_front_ping(&self) -> u32 {
        self.front_ping.unwrap_or(0)
    }
    pub fn clear_front_ping(&mut self) {
        self.front_ping = ::std::option::Option::None;
    }

    pub fn has_front_ping(&self) -> bool {
        self.front_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_ping(&mut self, v: u32) {
        self.front_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 back_ping = 3;


    pub fn get_back_ping(&self) -> u32 {
        self.back_ping.unwrap_or(0)
    }
    pub fn clear_back_ping(&mut self) {
        self.back_ping = ::std::option::Option::None;
    }

    pub fn has_back_ping(&self) -> bool {
        self.back_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_back_ping(&mut self, v: u32) {
        self.back_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_down = 4;


    pub fn get_seconds_until_down(&self) -> u32 {
        self.seconds_until_down.unwrap_or(0)
    }
    pub fn clear_seconds_until_down(&mut self) {
        self.seconds_until_down = ::std::option::Option::None;
    }

    pub fn has_seconds_until_down(&self) -> bool {
        self.seconds_until_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_down(&mut self, v: u32) {
        self.seconds_until_down = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.front_ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.back_ping = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_down = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.front_ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.back_ping {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_until_down {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.front_ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.back_ping {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seconds_until_down {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.score },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "front_ping",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.front_ping },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.front_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "back_ping",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.back_ping },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.back_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_down",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.seconds_until_down },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.seconds_until_down },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>(
                "CMsgSteamDatagramClientSwitchedPrimary.RouterQuality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.front_ping = ::std::option::Option::None;
        self.back_ping = ::std::option::Option::None;
        self.seconds_until_down = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterHealth {
    // message fields
    cpu_load: ::std::option::Option<f32>,
    active_sessions: ::std::option::Option<u32>,
    data_pkts_sec: ::std::option::Option<u32>,
    other_pkts_sec: ::std::option::Option<u32>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    cpu_cost_per_user: ::std::option::Option<f32>,
    cpu_cost_per_packet: ::std::option::Option<f32>,
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter>,
    magic: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth {
    fn default() -> &'a CMsgSteamDatagramRouterHealth {
        <CMsgSteamDatagramRouterHealth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth {
    pub fn new() -> CMsgSteamDatagramRouterHealth {
        ::std::default::Default::default()
    }

    // optional float cpu_load = 1;


    pub fn get_cpu_load(&self) -> f32 {
        self.cpu_load.unwrap_or(0.)
    }
    pub fn clear_cpu_load(&mut self) {
        self.cpu_load = ::std::option::Option::None;
    }

    pub fn has_cpu_load(&self) -> bool {
        self.cpu_load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load(&mut self, v: f32) {
        self.cpu_load = ::std::option::Option::Some(v);
    }

    // optional uint32 active_sessions = 2;


    pub fn get_active_sessions(&self) -> u32 {
        self.active_sessions.unwrap_or(0)
    }
    pub fn clear_active_sessions(&mut self) {
        self.active_sessions = ::std::option::Option::None;
    }

    pub fn has_active_sessions(&self) -> bool {
        self.active_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_sessions(&mut self, v: u32) {
        self.active_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 data_pkts_sec = 3;


    pub fn get_data_pkts_sec(&self) -> u32 {
        self.data_pkts_sec.unwrap_or(0)
    }
    pub fn clear_data_pkts_sec(&mut self) {
        self.data_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_data_pkts_sec(&self) -> bool {
        self.data_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_pkts_sec(&mut self, v: u32) {
        self.data_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 other_pkts_sec = 4;


    pub fn get_other_pkts_sec(&self) -> u32 {
        self.other_pkts_sec.unwrap_or(0)
    }
    pub fn clear_other_pkts_sec(&mut self) {
        self.other_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_other_pkts_sec(&self) -> bool {
        self.other_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pkts_sec(&mut self, v: u32) {
        self.other_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_user = 8;


    pub fn get_cpu_cost_per_user(&self) -> f32 {
        self.cpu_cost_per_user.unwrap_or(0.)
    }
    pub fn clear_cpu_cost_per_user(&mut self) {
        self.cpu_cost_per_user = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_user(&self) -> bool {
        self.cpu_cost_per_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_user(&mut self, v: f32) {
        self.cpu_cost_per_user = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_packet = 9;


    pub fn get_cpu_cost_per_packet(&self) -> f32 {
        self.cpu_cost_per_packet.unwrap_or(0.)
    }
    pub fn clear_cpu_cost_per_packet(&mut self) {
        self.cpu_cost_per_packet = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_packet(&self) -> bool {
        self.cpu_cost_per_packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_packet(&mut self, v: f32) {
        self.cpu_cost_per_packet = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramRouterHealth.DataCenter data_centers = 6;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramRouterHealth_DataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 magic = 7;


    pub fn get_magic(&self) -> u64 {
        self.magic.unwrap_or(0)
    }
    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u64) {
        self.magic = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterHealth {
    fn is_initialized(&self) -> bool {
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_load = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_sessions = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_pkts_sec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.other_pkts_sec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_cost_per_user = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_cost_per_packet = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.magic = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_load {
            my_size += 5;
        }
        if let Some(v) = self.active_sessions {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data_pkts_sec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_pkts_sec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpu_cost_per_user {
            my_size += 5;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            my_size += 5;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.magic {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cpu_load {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.active_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data_pkts_sec {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.other_pkts_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cpu_cost_per_user {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            os.write_float(9, v)?;
        }
        for v in &self.data_centers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.magic {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterHealth {
        CMsgSteamDatagramRouterHealth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_load",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_load },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_load },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_sessions",
                |m: &CMsgSteamDatagramRouterHealth| { &m.active_sessions },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.active_sessions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_pkts_sec",
                |m: &CMsgSteamDatagramRouterHealth| { &m.data_pkts_sec },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_pkts_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "other_pkts_sec",
                |m: &CMsgSteamDatagramRouterHealth| { &m.other_pkts_sec },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.other_pkts_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramRouterHealth| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_cost_per_user",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_user },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_cost_per_packet",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_packet },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramRouterHealth_DataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramRouterHealth| { &m.data_centers },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_centers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "magic",
                |m: &CMsgSteamDatagramRouterHealth| { &m.magic },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.magic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterHealth>(
                "CMsgSteamDatagramRouterHealth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterHealth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterHealth::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterHealth {
    fn clear(&mut self) {
        self.cpu_load = ::std::option::Option::None;
        self.active_sessions = ::std::option::Option::None;
        self.data_pkts_sec = ::std::option::Option::None;
        self.other_pkts_sec = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.cpu_cost_per_user = ::std::option::Option::None;
        self.cpu_cost_per_packet = ::std::option::Option::None;
        self.data_centers.clear();
        self.magic = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterHealth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterHealth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterHealth_DataCenter {
    // message fields
    datacenter_id: ::std::option::Option<u32>,
    state: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth_DataCenter {
    fn default() -> &'a CMsgSteamDatagramRouterHealth_DataCenter {
        <CMsgSteamDatagramRouterHealth_DataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth_DataCenter {
    pub fn new() -> CMsgSteamDatagramRouterHealth_DataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 datacenter_id = 1;


    pub fn get_datacenter_id(&self) -> u32 {
        self.datacenter_id.unwrap_or(0)
    }
    pub fn clear_datacenter_id(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
    }

    pub fn has_datacenter_id(&self) -> bool {
        self.datacenter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datacenter_id(&mut self, v: u32) {
        self.datacenter_id = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;


    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterHealth_DataCenter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.datacenter_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.datacenter_id {
            my_size += 5;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.datacenter_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterHealth_DataCenter {
        CMsgSteamDatagramRouterHealth_DataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "datacenter_id",
                |m: &CMsgSteamDatagramRouterHealth_DataCenter| { &m.datacenter_id },
                |m: &mut CMsgSteamDatagramRouterHealth_DataCenter| { &mut m.datacenter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "state",
                |m: &CMsgSteamDatagramRouterHealth_DataCenter| { &m.state },
                |m: &mut CMsgSteamDatagramRouterHealth_DataCenter| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterHealth_DataCenter>(
                "CMsgSteamDatagramRouterHealth.DataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth_DataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterHealth_DataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterHealth_DataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterHealth_DataCenter {
    fn clear(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterHealth_DataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterHealth_DataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectRequest {
    // message fields
    connection_id: ::std::option::Option<u32>,
    client_steam_id: ::std::option::Option<u64>,
    my_timestamp: ::std::option::Option<u64>,
    ping_est_ms: ::std::option::Option<u32>,
    virtual_port: ::std::option::Option<u32>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectRequest {
    fn default() -> &'a CMsgSteamDatagramConnectRequest {
        <CMsgSteamDatagramConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectRequest {
    pub fn new() -> CMsgSteamDatagramConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 3;


    pub fn get_client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }
    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 4;


    pub fn get_my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }
    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 5;


    pub fn get_ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }
    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 virtual_port = 9;


    pub fn get_virtual_port(&self) -> u32 {
        self.virtual_port.unwrap_or(0)
    }
    pub fn clear_virtual_port(&mut self) {
        self.virtual_port = ::std::option::Option::None;
    }

    pub fn has_virtual_port(&self) -> bool {
        self.virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_port(&mut self, v: u32) {
        self.virtual_port = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 7;


    pub fn get_cert(&self) -> &super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.client_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.my_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_est_ms = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.virtual_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.virtual_port {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.virtual_port {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectRequest {
        CMsgSteamDatagramConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "client_steam_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.client_steam_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "my_timestamp",
                |m: &CMsgSteamDatagramConnectRequest| { &m.my_timestamp },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.my_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_est_ms",
                |m: &CMsgSteamDatagramConnectRequest| { &m.ping_est_ms },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.ping_est_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "virtual_port",
                |m: &CMsgSteamDatagramConnectRequest| { &m.virtual_port },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.virtual_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamDatagramConnectRequest| { &m.crypt },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramConnectRequest| { &m.cert },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramConnectRequest| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectRequest>(
                "CMsgSteamDatagramConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectRequest {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.virtual_port = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectOK {
    // message fields
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    your_timestamp: ::std::option::Option<u64>,
    delay_time_usec: ::std::option::Option<u32>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectOK {
    fn default() -> &'a CMsgSteamDatagramConnectOK {
        <CMsgSteamDatagramConnectOK as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectOK {
    pub fn new() -> CMsgSteamDatagramConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 7;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;


    pub fn get_your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }
    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;


    pub fn get_delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }
    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 6;


    pub fn get_cert(&self) -> &super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectOK {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.your_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_time_usec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectOK {
        CMsgSteamDatagramConnectOK::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "your_timestamp",
                |m: &CMsgSteamDatagramConnectOK| { &m.your_timestamp },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.your_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_time_usec",
                |m: &CMsgSteamDatagramConnectOK| { &m.delay_time_usec },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.delay_time_usec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamDatagramConnectOK| { &m.crypt },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramConnectOK| { &m.cert },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramConnectOK| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectOK>(
                "CMsgSteamDatagramConnectOK",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectOK {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectOK> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectOK::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectOK {
    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectOK {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionClosed {
    // message fields
    legacy_client_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    peer_steam_id: ::std::option::Option<u64>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    relay_mode: ::std::option::Option<CMsgSteamDatagramConnectionClosed_ERelayMode>,
    debug: ::protobuf::SingularField<::std::string::String>,
    reason_code: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionClosed {
    fn default() -> &'a CMsgSteamDatagramConnectionClosed {
        <CMsgSteamDatagramConnectionClosed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionClosed {
    pub fn new() -> CMsgSteamDatagramConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;


    pub fn get_legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 7;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 8;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 3;


    pub fn get_peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }
    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4;


    pub fn get_relay_mode(&self) -> CMsgSteamDatagramConnectionClosed_ERelayMode {
        self.relay_mode.unwrap_or(CMsgSteamDatagramConnectionClosed_ERelayMode::None)
    }
    pub fn clear_relay_mode(&mut self) {
        self.relay_mode = ::std::option::Option::None;
    }

    pub fn has_relay_mode(&self) -> bool {
        self.relay_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_mode(&mut self, v: CMsgSteamDatagramConnectionClosed_ERelayMode) {
        self.relay_mode = ::std::option::Option::Some(v);
    }

    // optional string debug = 5;


    pub fn get_debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_debug(&mut self) {
        self.debug.clear();
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug.set_default();
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 6;


    pub fn get_reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }
    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionClosed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_connection_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.peer_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.relay_mode, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_mode {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.debug.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relay_mode {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.debug.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionClosed {
        CMsgSteamDatagramConnectionClosed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_connection_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "peer_steam_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.peer_steam_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.peer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgSteamDatagramConnectionClosed_ERelayMode>>(
                "relay_mode",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.relay_mode },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.relay_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "debug",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.debug },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.debug },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reason_code",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.reason_code },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.reason_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionClosed>(
                "CMsgSteamDatagramConnectionClosed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionClosed {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionClosed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionClosed::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionClosed {
    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.relay_mode = ::std::option::Option::None;
        self.debug.clear();
        self.reason_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionClosed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionClosed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionClosed_ERelayMode {
    None = 0,
    EndToEnd = 1,
    ClosedByPeer = 2,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionClosed_ERelayMode> {
        match value {
            0 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::None),
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::EndToEnd),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::ClosedByPeer),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionClosed_ERelayMode] = &[
            CMsgSteamDatagramConnectionClosed_ERelayMode::None,
            CMsgSteamDatagramConnectionClosed_ERelayMode::EndToEnd,
            CMsgSteamDatagramConnectionClosed_ERelayMode::ClosedByPeer,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionClosed_ERelayMode>("CMsgSteamDatagramConnectionClosed.ERelayMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionClosed_ERelayMode {
}

impl ::std::default::Default for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn default() -> Self {
        CMsgSteamDatagramConnectionClosed_ERelayMode::None
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoConnection {
    // message fields
    legacy_client_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    peer_steam_id: ::std::option::Option<u64>,
    end_to_end: ::std::option::Option<bool>,
    dummy_pad: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoConnection {
    fn default() -> &'a CMsgSteamDatagramNoConnection {
        <CMsgSteamDatagramNoConnection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoConnection {
    pub fn new() -> CMsgSteamDatagramNoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;


    pub fn get_legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 5;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 6;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 3;


    pub fn get_peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }
    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool end_to_end = 4;


    pub fn get_end_to_end(&self) -> bool {
        self.end_to_end.unwrap_or(false)
    }
    pub fn clear_end_to_end(&mut self) {
        self.end_to_end = ::std::option::Option::None;
    }

    pub fn has_end_to_end(&self) -> bool {
        self.end_to_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_to_end(&mut self, v: bool) {
        self.end_to_end = ::std::option::Option::Some(v);
    }

    // optional fixed32 dummy_pad = 1023;


    pub fn get_dummy_pad(&self) -> u32 {
        self.dummy_pad.unwrap_or(0)
    }
    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u32) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_connection_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.peer_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_to_end = ::std::option::Option::Some(tmp);
                },
                1023 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.dummy_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.end_to_end {
            my_size += 2;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.end_to_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed32(1023, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoConnection {
        CMsgSteamDatagramNoConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_connection_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.legacy_client_connection_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.legacy_client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "peer_steam_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.peer_steam_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.peer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "end_to_end",
                |m: &CMsgSteamDatagramNoConnection| { &m.end_to_end },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.end_to_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "dummy_pad",
                |m: &CMsgSteamDatagramNoConnection| { &m.dummy_pad },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.dummy_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoConnection>(
                "CMsgSteamDatagramNoConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoConnection {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoConnection::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoConnection {
    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.end_to_end = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionRequestBody {
    // message fields
    challenge_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    my_connection_id: ::std::option::Option<u32>,
    peer_steam_id: ::std::option::Option<u64>,
    peer_connection_id: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    network_config_version: ::std::option::Option<u32>,
    public_ip: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequestBody {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequestBody {
        <CMsgSteamDatagramP2PSessionRequestBody as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequestBody {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 1;


    pub fn get_challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }
    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_connection_id = 3;


    pub fn get_my_connection_id(&self) -> u32 {
        self.my_connection_id.unwrap_or(0)
    }
    pub fn clear_my_connection_id(&mut self) {
        self.my_connection_id = ::std::option::Option::None;
    }

    pub fn has_my_connection_id(&self) -> bool {
        self.my_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_connection_id(&mut self, v: u32) {
        self.my_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 4;


    pub fn get_peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }
    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 peer_connection_id = 5;


    pub fn get_peer_connection_id(&self) -> u32 {
        self.peer_connection_id.unwrap_or(0)
    }
    pub fn clear_peer_connection_id(&mut self) {
        self.peer_connection_id = ::std::option::Option::None;
    }

    pub fn has_peer_connection_id(&self) -> bool {
        self.peer_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_connection_id(&mut self, v: u32) {
        self.peer_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 9;


    pub fn get_network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }
    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional fixed32 public_ip = 10;


    pub fn get_public_ip(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }
    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequestBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.challenge_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.peer_steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.peer_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_config_version = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.my_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.peer_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.public_ip {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_time {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.my_connection_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.peer_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.public_ip {
            os.write_fixed32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        CMsgSteamDatagramP2PSessionRequestBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "challenge_time",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge_time },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_connection_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.my_connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.my_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "peer_steam_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_steam_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "peer_connection_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_config_version",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.network_config_version },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.network_config_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "public_ip",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.public_ip },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionRequestBody>(
                "CMsgSteamDatagramP2PSessionRequestBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequestBody {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionRequestBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionRequestBody::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionRequestBody {
    fn clear(&mut self) {
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.my_connection_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.peer_connection_id = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.public_ip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionRequestBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequestBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionRequest {
    // message fields
    pub cert: ::protobuf::SingularPtrField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequest {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequest {
        <CMsgSteamDatagramP2PSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequest {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequest {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 1;


    pub fn get_cert(&self) -> &super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional bytes body = 2;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequest {
        CMsgSteamDatagramP2PSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.cert },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.body },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.signature },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionRequest>(
                "CMsgSteamDatagramP2PSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionRequest {
    fn clear(&mut self) {
        self.cert.clear();
        self.body.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionEstablished {
    // message fields
    connection_id: ::std::option::Option<u32>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    relay_routing_id: ::std::option::Option<u64>,
    seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramP2PSessionEstablished {
        <CMsgSteamDatagramP2PSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionEstablished {
    pub fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 3;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed64 relay_routing_id = 4;


    pub fn get_relay_routing_id(&self) -> u64 {
        self.relay_routing_id.unwrap_or(0)
    }
    pub fn clear_relay_routing_id(&mut self) {
        self.relay_routing_id = ::std::option::Option::None;
    }

    pub fn has_relay_routing_id(&self) -> bool {
        self.relay_routing_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_routing_id(&mut self, v: u64) {
        self.relay_routing_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 5;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionEstablished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.relay_routing_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_routing_id {
            my_size += 9;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.relay_routing_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        CMsgSteamDatagramP2PSessionEstablished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "relay_routing_id",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.relay_routing_id },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.relay_routing_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seq_num_r2c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionEstablished>(
                "CMsgSteamDatagramP2PSessionEstablished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionEstablished {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionEstablished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionEstablished::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionEstablished {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.relay_routing_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionEstablished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes {
    // message fields
    pub relay_clusters: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster>,
    pub routes: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route>,
    revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes {
        <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes {
    pub fn new() -> CMsgSteamDatagramP2PRoutes {
        ::std::default::Default::default()
    }

    // repeated .CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;


    pub fn get_relay_clusters(&self) -> &[CMsgSteamDatagramP2PRoutes_RelayCluster] {
        &self.relay_clusters
    }
    pub fn clear_relay_clusters(&mut self) {
        self.relay_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_relay_clusters(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster>) {
        self.relay_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relay_clusters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster> {
        &mut self.relay_clusters
    }

    // Take field
    pub fn take_relay_clusters(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster> {
        ::std::mem::replace(&mut self.relay_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramP2PRoutes.Route routes = 2;


    pub fn get_routes(&self) -> &[CMsgSteamDatagramP2PRoutes_Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // optional uint32 revision = 3;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes {
    fn is_initialized(&self) -> bool {
        for v in &self.relay_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relay_clusters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relay_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relay_clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.routes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.revision {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes {
        CMsgSteamDatagramP2PRoutes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes_RelayCluster>>(
                "relay_clusters",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.relay_clusters },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.relay_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes_Route>>(
                "routes",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.routes },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.revision },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes>(
                "CMsgSteamDatagramP2PRoutes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes {
    fn clear(&mut self) {
        self.relay_clusters.clear();
        self.routes.clear();
        self.revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes_RelayCluster {
    // message fields
    pop_id: ::std::option::Option<u32>,
    ping_ms: ::std::option::Option<u32>,
    score_penalty: ::std::option::Option<u32>,
    session_relay_routing_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes_RelayCluster {
        <CMsgSteamDatagramP2PRoutes_RelayCluster as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes_RelayCluster {
    pub fn new() -> CMsgSteamDatagramP2PRoutes_RelayCluster {
        ::std::default::Default::default()
    }

    // optional fixed32 pop_id = 1;


    pub fn get_pop_id(&self) -> u32 {
        self.pop_id.unwrap_or(0)
    }
    pub fn clear_pop_id(&mut self) {
        self.pop_id = ::std::option::Option::None;
    }

    pub fn has_pop_id(&self) -> bool {
        self.pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pop_id(&mut self, v: u32) {
        self.pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 2;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 score_penalty = 3;


    pub fn get_score_penalty(&self) -> u32 {
        self.score_penalty.unwrap_or(0)
    }
    pub fn clear_score_penalty(&mut self) {
        self.score_penalty = ::std::option::Option::None;
    }

    pub fn has_score_penalty(&self) -> bool {
        self.score_penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_penalty(&mut self, v: u32) {
        self.score_penalty = ::std::option::Option::Some(v);
    }

    // optional fixed64 session_relay_routing_id = 4;


    pub fn get_session_relay_routing_id(&self) -> u64 {
        self.session_relay_routing_id.unwrap_or(0)
    }
    pub fn clear_session_relay_routing_id(&mut self) {
        self.session_relay_routing_id = ::std::option::Option::None;
    }

    pub fn has_session_relay_routing_id(&self) -> bool {
        self.session_relay_routing_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_relay_routing_id(&mut self, v: u64) {
        self.session_relay_routing_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.pop_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_penalty = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.session_relay_routing_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pop_id {
            my_size += 5;
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_relay_routing_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pop_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score_penalty {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.session_relay_routing_id {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes_RelayCluster {
        CMsgSteamDatagramP2PRoutes_RelayCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_penalty",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.score_penalty },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.score_penalty },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "session_relay_routing_id",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.session_relay_routing_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.session_relay_routing_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes_RelayCluster>(
                "CMsgSteamDatagramP2PRoutes.RelayCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes_RelayCluster {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes_RelayCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes_RelayCluster::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn clear(&mut self) {
        self.pop_id = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.score_penalty = ::std::option::Option::None;
        self.session_relay_routing_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes_Route {
    // message fields
    my_pop_id: ::std::option::Option<u32>,
    your_pop_id: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes_Route {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes_Route {
        <CMsgSteamDatagramP2PRoutes_Route as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes_Route {
    pub fn new() -> CMsgSteamDatagramP2PRoutes_Route {
        ::std::default::Default::default()
    }

    // optional fixed32 my_pop_id = 1;


    pub fn get_my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }
    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 2;


    pub fn get_your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }
    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 3;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes_Route {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_pop_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_pop_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.my_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes_Route {
        CMsgSteamDatagramP2PRoutes_Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.my_pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.my_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.your_pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.your_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.score },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes_Route>(
                "CMsgSteamDatagramP2PRoutes.Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes_Route {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes_Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes_Route::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes_Route {
    fn clear(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes_Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes_Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRendezvous {
    // message fields
    to_connection_id: ::std::option::Option<u32>,
    pub routes: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutes>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    pub connect_request: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectRequest>,
    pub connect_ok: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectOK>,
    pub connection_closed: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionClosed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRendezvous {
    fn default() -> &'a CMsgSteamDatagramP2PRendezvous {
        <CMsgSteamDatagramP2PRendezvous as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRendezvous {
    pub fn new() -> CMsgSteamDatagramP2PRendezvous {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 1;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramP2PRoutes routes = 2;


    pub fn get_routes(&self) -> &CMsgSteamDatagramP2PRoutes {
        self.routes.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: CMsgSteamDatagramP2PRoutes) {
        self.routes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut CMsgSteamDatagramP2PRoutes {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> CMsgSteamDatagramP2PRoutes {
        self.routes.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutes::new())
    }

    // optional uint32 ack_peer_routes_revision = 3;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectRequest connect_request = 4;


    pub fn get_connect_request(&self) -> &CMsgSteamDatagramConnectRequest {
        self.connect_request.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_request(&mut self) {
        self.connect_request.clear();
    }

    pub fn has_connect_request(&self) -> bool {
        self.connect_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_request(&mut self, v: CMsgSteamDatagramConnectRequest) {
        self.connect_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_request(&mut self) -> &mut CMsgSteamDatagramConnectRequest {
        if self.connect_request.is_none() {
            self.connect_request.set_default();
        }
        self.connect_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_request(&mut self) -> CMsgSteamDatagramConnectRequest {
        self.connect_request.take().unwrap_or_else(|| CMsgSteamDatagramConnectRequest::new())
    }

    // optional .CMsgSteamDatagramConnectOK connect_ok = 5;


    pub fn get_connect_ok(&self) -> &CMsgSteamDatagramConnectOK {
        self.connect_ok.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectOK as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_ok(&mut self) {
        self.connect_ok.clear();
    }

    pub fn has_connect_ok(&self) -> bool {
        self.connect_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_ok(&mut self, v: CMsgSteamDatagramConnectOK) {
        self.connect_ok = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_ok(&mut self) -> &mut CMsgSteamDatagramConnectOK {
        if self.connect_ok.is_none() {
            self.connect_ok.set_default();
        }
        self.connect_ok.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_ok(&mut self) -> CMsgSteamDatagramConnectOK {
        self.connect_ok.take().unwrap_or_else(|| CMsgSteamDatagramConnectOK::new())
    }

    // optional .CMsgSteamDatagramConnectionClosed connection_closed = 6;


    pub fn get_connection_closed(&self) -> &CMsgSteamDatagramConnectionClosed {
        self.connection_closed.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionClosed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_closed(&mut self) {
        self.connection_closed.clear();
    }

    pub fn has_connection_closed(&self) -> bool {
        self.connection_closed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_closed(&mut self, v: CMsgSteamDatagramConnectionClosed) {
        self.connection_closed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_closed(&mut self) -> &mut CMsgSteamDatagramConnectionClosed {
        if self.connection_closed.is_none() {
            self.connection_closed.set_default();
        }
        self.connection_closed.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_closed(&mut self) -> CMsgSteamDatagramConnectionClosed {
        self.connection_closed.take().unwrap_or_else(|| CMsgSteamDatagramConnectionClosed::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRendezvous {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connect_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connect_ok {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connection_closed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_request)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_ok)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_closed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.connect_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connect_ok.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connection_closed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.connect_request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connect_ok.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connection_closed.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRendezvous {
        CMsgSteamDatagramP2PRendezvous::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes>>(
                "routes",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.routes },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectRequest>>(
                "connect_request",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.connect_request },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.connect_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectOK>>(
                "connect_ok",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.connect_ok },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.connect_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionClosed>>(
                "connection_closed",
                |m: &CMsgSteamDatagramP2PRendezvous| { &m.connection_closed },
                |m: &mut CMsgSteamDatagramP2PRendezvous| { &mut m.connection_closed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRendezvous>(
                "CMsgSteamDatagramP2PRendezvous",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRendezvous {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRendezvous> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRendezvous::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRendezvous {
    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connect_request.clear();
        self.connect_ok.clear();
        self.connection_closed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRendezvous {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRendezvous {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    // message fields
    pub c2r: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub c2s: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    forward_target_relay_routing_id: ::std::option::Option<u64>,
    forward_target_revision: ::std::option::Option<u32>,
    pub routes: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutes>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    seq_num_c2r: ::std::option::Option<u32>,
    seq_num_c2s: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        <CMsgSteamDatagramConnectionStatsP2PClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality c2r = 1;


    pub fn get_c2r(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.c2r.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_c2r(&mut self) {
        self.c2r.clear();
    }

    pub fn has_c2r(&self) -> bool {
        self.c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c2r(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.c2r = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c2r(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.c2r.is_none() {
            self.c2r.set_default();
        }
        self.c2r.as_mut().unwrap()
    }

    // Take field
    pub fn take_c2r(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.c2r.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality c2s = 2;


    pub fn get_c2s(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.c2s.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_c2s(&mut self) {
        self.c2s.clear();
    }

    pub fn has_c2s(&self) -> bool {
        self.c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c2s(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.c2s = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c2s(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.c2s.is_none() {
            self.c2s.set_default();
        }
        self.c2s.as_mut().unwrap()
    }

    // Take field
    pub fn take_c2s(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.c2s.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 3;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 4;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 5;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 forward_target_relay_routing_id = 6;


    pub fn get_forward_target_relay_routing_id(&self) -> u64 {
        self.forward_target_relay_routing_id.unwrap_or(0)
    }
    pub fn clear_forward_target_relay_routing_id(&mut self) {
        self.forward_target_relay_routing_id = ::std::option::Option::None;
    }

    pub fn has_forward_target_relay_routing_id(&self) -> bool {
        self.forward_target_relay_routing_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_id(&mut self, v: u64) {
        self.forward_target_relay_routing_id = ::std::option::Option::Some(v);
    }

    // optional uint32 forward_target_revision = 7;


    pub fn get_forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }
    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramP2PRoutes routes = 8;


    pub fn get_routes(&self) -> &CMsgSteamDatagramP2PRoutes {
        self.routes.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: CMsgSteamDatagramP2PRoutes) {
        self.routes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut CMsgSteamDatagramP2PRoutes {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> CMsgSteamDatagramP2PRoutes {
        self.routes.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutes::new())
    }

    // optional uint32 ack_peer_routes_revision = 9;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 10;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 11;


    pub fn get_seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }
    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 12;


    pub fn get_seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }
    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.c2r {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.c2s {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.c2r)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.c2s)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.forward_target_relay_routing_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.forward_target_revision = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2r = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2s = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.c2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forward_target_relay_routing_id {
            my_size += 9;
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.c2r.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.c2s.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.forward_target_relay_routing_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "c2r",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "c2s",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.c2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "forward_target_relay_routing_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_relay_routing_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_relay_routing_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "forward_target_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes>>(
                "routes",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.routes },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2r",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2s",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_c2s },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_c2s },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PClientToRouter>(
                "CMsgSteamDatagramConnectionStatsP2PClientToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsP2PClientToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsP2PClientToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn clear(&mut self) {
        self.c2r.clear();
        self.c2s.clear();
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.forward_target_relay_routing_id = ::std::option::Option::None;
        self.forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags>("CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    // message fields
    pub r2c: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub p2c: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    migrate_request_ip: ::std::option::Option<u32>,
    migrate_request_port: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    ack_forward_target_revision: ::std::option::Option<u32>,
    pub routes: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutes>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    seq_num_p2c: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        <CMsgSteamDatagramConnectionStatsP2PRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality r2c = 1;


    pub fn get_r2c(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.r2c.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_r2c(&mut self) {
        self.r2c.clear();
    }

    pub fn has_r2c(&self) -> bool {
        self.r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r2c(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.r2c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r2c(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.r2c.is_none() {
            self.r2c.set_default();
        }
        self.r2c.as_mut().unwrap()
    }

    // Take field
    pub fn take_r2c(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.r2c.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality p2c = 2;


    pub fn get_p2c(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.p2c.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2c(&mut self) {
        self.p2c.clear();
    }

    pub fn has_p2c(&self) -> bool {
        self.p2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2c(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.p2c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2c(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.p2c.is_none() {
            self.p2c.set_default();
        }
        self.p2c.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2c(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.p2c.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // optional uint32 seconds_until_shutdown = 3;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 4;


    pub fn get_migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }
    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 5;


    pub fn get_migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }
    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 6;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 7;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 ack_e2e = 8;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 9;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 10;


    pub fn get_ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }
    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramP2PRoutes routes = 11;


    pub fn get_routes(&self) -> &CMsgSteamDatagramP2PRoutes {
        self.routes.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: CMsgSteamDatagramP2PRoutes) {
        self.routes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut CMsgSteamDatagramP2PRoutes {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> CMsgSteamDatagramP2PRoutes {
        self.routes.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutes::new())
    }

    // optional uint32 ack_peer_routes_revision = 12;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 13;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 14;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_p2c = 15;


    pub fn get_seq_num_p2c(&self) -> u32 {
        self.seq_num_p2c.unwrap_or(0)
    }
    pub fn clear_seq_num_p2c(&mut self) {
        self.seq_num_p2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_p2c(&self) -> bool {
        self.seq_num_p2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_p2c(&mut self, v: u32) {
        self.seq_num_p2c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.r2c {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2c {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.r2c)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2c)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.migrate_request_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.migrate_request_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_forward_target_revision = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routes)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_p2c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.r2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 5;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_p2c {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.r2c.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2c.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(6, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(7, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(8, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.seq_num_p2c {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "r2c",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "p2c",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.p2c },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.p2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "migrate_request_ip",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_ip },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "migrate_request_port",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_port },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_forward_target_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes>>(
                "routes",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.routes },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_p2c",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_p2c },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_p2c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToClient>(
                "CMsgSteamDatagramConnectionStatsP2PRouterToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsP2PRouterToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsP2PRouterToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn clear(&mut self) {
        self.r2c.clear();
        self.p2c.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_p2c = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags] = &[
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags>("CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_ChallengeRequest {
    // message fields
    connection_id: ::std::option::Option<u32>,
    my_timestamp: ::std::option::Option<u64>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ChallengeRequest {
    fn default() -> &'a CMsgSteamSockets_UDP_ChallengeRequest {
        <CMsgSteamSockets_UDP_ChallengeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ChallengeRequest {
    pub fn new() -> CMsgSteamSockets_UDP_ChallengeRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 3;


    pub fn get_my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }
    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_ChallengeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.my_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_ChallengeRequest {
        CMsgSteamSockets_UDP_ChallengeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamSockets_UDP_ChallengeRequest| { &m.connection_id },
                |m: &mut CMsgSteamSockets_UDP_ChallengeRequest| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "my_timestamp",
                |m: &CMsgSteamSockets_UDP_ChallengeRequest| { &m.my_timestamp },
                |m: &mut CMsgSteamSockets_UDP_ChallengeRequest| { &mut m.my_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamSockets_UDP_ChallengeRequest| { &m.protocol_version },
                |m: &mut CMsgSteamSockets_UDP_ChallengeRequest| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_ChallengeRequest>(
                "CMsgSteamSockets_UDP_ChallengeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ChallengeRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_ChallengeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_ChallengeRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_ChallengeRequest {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_ChallengeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_ChallengeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_ChallengeReply {
    // message fields
    connection_id: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    your_timestamp: ::std::option::Option<u64>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ChallengeReply {
    fn default() -> &'a CMsgSteamSockets_UDP_ChallengeReply {
        <CMsgSteamSockets_UDP_ChallengeReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ChallengeReply {
    pub fn new() -> CMsgSteamSockets_UDP_ChallengeReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;


    pub fn get_your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }
    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_ChallengeReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.your_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_ChallengeReply {
        CMsgSteamSockets_UDP_ChallengeReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamSockets_UDP_ChallengeReply| { &m.connection_id },
                |m: &mut CMsgSteamSockets_UDP_ChallengeReply| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamSockets_UDP_ChallengeReply| { &m.challenge },
                |m: &mut CMsgSteamSockets_UDP_ChallengeReply| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "your_timestamp",
                |m: &CMsgSteamSockets_UDP_ChallengeReply| { &m.your_timestamp },
                |m: &mut CMsgSteamSockets_UDP_ChallengeReply| { &mut m.your_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamSockets_UDP_ChallengeReply| { &m.protocol_version },
                |m: &mut CMsgSteamSockets_UDP_ChallengeReply| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_ChallengeReply>(
                "CMsgSteamSockets_UDP_ChallengeReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ChallengeReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_ChallengeReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_ChallengeReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_ChallengeReply {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_ChallengeReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_ChallengeReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_ConnectRequest {
    // message fields
    client_connection_id: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    client_steam_id: ::std::option::Option<u64>,
    my_timestamp: ::std::option::Option<u64>,
    ping_est_ms: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectRequest {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectRequest {
        <CMsgSteamSockets_UDP_ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectRequest {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 3;


    pub fn get_client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }
    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 5;


    pub fn get_my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }
    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 6;


    pub fn get_ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }
    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 7;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 4;


    pub fn get_cert(&self) -> &super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_ConnectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.client_steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.my_timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_est_ms = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectRequest {
        CMsgSteamSockets_UDP_ConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.client_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.challenge },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "client_steam_id",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.client_steam_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "my_timestamp",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.my_timestamp },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.my_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_est_ms",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.ping_est_ms },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.ping_est_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.crypt },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.cert },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamSockets_UDP_ConnectRequest| { &m.protocol_version },
                |m: &mut CMsgSteamSockets_UDP_ConnectRequest| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_ConnectRequest>(
                "CMsgSteamSockets_UDP_ConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_ConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_ConnectRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_ConnectRequest {
    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_ConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_ConnectOK {
    // message fields
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    server_steam_id: ::std::option::Option<u64>,
    your_timestamp: ::std::option::Option<u64>,
    delay_time_usec: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectOK {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectOK {
        <CMsgSteamSockets_UDP_ConnectOK as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectOK {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 5;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 2;


    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }
    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;


    pub fn get_your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }
    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;


    pub fn get_delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }
    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 7;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 8;


    pub fn get_cert(&self) -> &super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional uint32 protocol_version = 9;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_ConnectOK {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.your_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_time_usec = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectOK {
        CMsgSteamSockets_UDP_ConnectOK::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.client_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.server_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "server_steam_id",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.server_steam_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.server_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "your_timestamp",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.your_timestamp },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.your_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_time_usec",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.delay_time_usec },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.delay_time_usec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.crypt },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.cert },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamSockets_UDP_ConnectOK| { &m.protocol_version },
                |m: &mut CMsgSteamSockets_UDP_ConnectOK| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_ConnectOK>(
                "CMsgSteamSockets_UDP_ConnectOK",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectOK {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_ConnectOK> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_ConnectOK::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_ConnectOK {
    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_ConnectOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_ConnectOK {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_ConnectionClosed {
    // message fields
    legacy_client_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    debug: ::protobuf::SingularField<::std::string::String>,
    reason_code: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectionClosed {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectionClosed {
        <CMsgSteamSockets_UDP_ConnectionClosed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectionClosed {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;


    pub fn get_legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 4;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 5;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string debug = 2;


    pub fn get_debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_debug(&mut self) {
        self.debug.clear();
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug.set_default();
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 3;


    pub fn get_reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }
    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_ConnectionClosed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.debug.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(ref v) = self.debug.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectionClosed {
        CMsgSteamSockets_UDP_ConnectionClosed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectionClosed| { &m.legacy_client_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectionClosed| { &mut m.legacy_client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectionClosed| { &m.to_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectionClosed| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamSockets_UDP_ConnectionClosed| { &m.from_connection_id },
                |m: &mut CMsgSteamSockets_UDP_ConnectionClosed| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "debug",
                |m: &CMsgSteamSockets_UDP_ConnectionClosed| { &m.debug },
                |m: &mut CMsgSteamSockets_UDP_ConnectionClosed| { &mut m.debug },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reason_code",
                |m: &CMsgSteamSockets_UDP_ConnectionClosed| { &m.reason_code },
                |m: &mut CMsgSteamSockets_UDP_ConnectionClosed| { &mut m.reason_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_ConnectionClosed>(
                "CMsgSteamSockets_UDP_ConnectionClosed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectionClosed {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_ConnectionClosed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_ConnectionClosed::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_ConnectionClosed {
    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.debug.clear();
        self.reason_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_ConnectionClosed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_ConnectionClosed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_NoConnection {
    // message fields
    legacy_client_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_NoConnection {
    fn default() -> &'a CMsgSteamSockets_UDP_NoConnection {
        <CMsgSteamSockets_UDP_NoConnection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_NoConnection {
    pub fn new() -> CMsgSteamSockets_UDP_NoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;


    pub fn get_legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 2;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 3;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_NoConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_NoConnection {
        CMsgSteamSockets_UDP_NoConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_connection_id",
                |m: &CMsgSteamSockets_UDP_NoConnection| { &m.legacy_client_connection_id },
                |m: &mut CMsgSteamSockets_UDP_NoConnection| { &mut m.legacy_client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamSockets_UDP_NoConnection| { &m.from_connection_id },
                |m: &mut CMsgSteamSockets_UDP_NoConnection| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamSockets_UDP_NoConnection| { &m.to_connection_id },
                |m: &mut CMsgSteamSockets_UDP_NoConnection| { &mut m.to_connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_NoConnection>(
                "CMsgSteamSockets_UDP_NoConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_NoConnection {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_NoConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_NoConnection::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_NoConnection {
    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_NoConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_NoConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamSockets_UDP_Stats {
    // message fields
    pub stats: ::protobuf::SingularPtrField<CMsgSteamDatagramConnectionQuality>,
    pub ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    legacy_client_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    seq_num: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_Stats {
    fn default() -> &'a CMsgSteamSockets_UDP_Stats {
        <CMsgSteamSockets_UDP_Stats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_Stats {
    pub fn new() -> CMsgSteamSockets_UDP_Stats {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality stats = 1;


    pub fn get_stats(&self) -> &CMsgSteamDatagramConnectionQuality {
        self.stats.as_ref().unwrap_or_else(|| <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CMsgSteamDatagramConnectionQuality) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CMsgSteamDatagramConnectionQuality {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CMsgSteamDatagramConnectionQuality {
        self.stats.take().unwrap_or_else(|| CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_e2e = 2;


    pub fn get_ack_e2e(&self) -> &[u32] {
        &self.ack_e2e
    }
    pub fn clear_ack_e2e(&mut self) {
        self.ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_e2e
    }

    // Take field
    pub fn take_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 3;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_client_connection_id = 8;


    pub fn get_legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 9;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 10;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num = 4;


    pub fn get_seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }
    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamSockets_UDP_Stats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_e2e)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.legacy_client_connection_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_e2e {
            os.write_fixed32(2, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamSockets_UDP_Stats {
        CMsgSteamSockets_UDP_Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramConnectionQuality>>(
                "stats",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.stats },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_e2e",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.ack_e2e },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.flags },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_client_connection_id",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.legacy_client_connection_id },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.legacy_client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.to_connection_id },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.from_connection_id },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num",
                |m: &CMsgSteamSockets_UDP_Stats| { &m.seq_num },
                |m: &mut CMsgSteamSockets_UDP_Stats| { &mut m.seq_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamSockets_UDP_Stats>(
                "CMsgSteamSockets_UDP_Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_Stats {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamSockets_UDP_Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamSockets_UDP_Stats::new)
    }
}

impl ::protobuf::Clear for CMsgSteamSockets_UDP_Stats {
    fn clear(&mut self) {
        self.stats.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamSockets_UDP_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamSockets_UDP_Stats_Flags {
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamSockets_UDP_Stats_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamSockets_UDP_Stats_Flags> {
        match value {
            2 => ::std::option::Option::Some(CMsgSteamSockets_UDP_Stats_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamSockets_UDP_Stats_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamSockets_UDP_Stats_Flags] = &[
            CMsgSteamSockets_UDP_Stats_Flags::ACK_REQUEST_E2E,
            CMsgSteamSockets_UDP_Stats_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamSockets_UDP_Stats_Flags>("CMsgSteamSockets_UDP_Stats.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamSockets_UDP_Stats_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamSockets_UDP_Stats_Flags {
    fn default() -> Self {
        CMsgSteamSockets_UDP_Stats_Flags::ACK_REQUEST_E2E
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamSockets_UDP_Stats_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESteamDatagramMsgID {
    k_ESteamDatagramMsg_Invalid = 0,
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    k_ESteamDatagramMsg_RouterPingReply = 2,
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    k_ESteamDatagramMsg_GameserverPingReply = 4,
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    k_ESteamDatagramMsg_NoSession = 7,
    k_ESteamDatagramMsg_Diagnostic = 8,
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    k_ESteamDatagramMsg_Stats = 13,
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    k_ESteamDatagramMsg_RelayHealth = 17,
    k_ESteamDatagramMsg_ConnectRequest = 18,
    k_ESteamDatagramMsg_ConnectOK = 19,
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    k_ESteamDatagramMsg_NoConnection = 21,
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 22,
    k_ESteamDatagramMsg_RelayToRelayPingReply = 23,
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
}

impl ::protobuf::ProtobufEnum for ESteamDatagramMsgID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDatagramMsgID> {
        match value {
            0 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            1 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            2 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            3 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            4 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            5 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            6 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            7 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            8 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            9 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            10 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            11 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            12 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            13 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            14 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            15 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            16 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            17 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            18 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            19 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            20 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            21 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            22 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            23 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            24 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            25 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamDatagramMsgID] = &[
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamDatagramMsgID>("ESteamDatagramMsgID", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamDatagramMsgID {
}

impl ::std::default::Default for ESteamDatagramMsgID {
    fn default() -> Self {
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamDatagramMsgID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESteamNetworkingUDPMsgID {
    k_ESteamNetworkingUDPMsg_ChallengeRequest = 32,
    k_ESteamNetworkingUDPMsg_ChallengeReply = 33,
    k_ESteamNetworkingUDPMsg_ConnectRequest = 34,
    k_ESteamNetworkingUDPMsg_ConnectOK = 35,
    k_ESteamNetworkingUDPMsg_ConnectionClosed = 36,
    k_ESteamNetworkingUDPMsg_NoConnection = 37,
    k_ESteamNetworkingUDPMsg_Stats = 38,
}

impl ::protobuf::ProtobufEnum for ESteamNetworkingUDPMsgID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamNetworkingUDPMsgID> {
        match value {
            32 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest),
            33 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeReply),
            34 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectRequest),
            35 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectOK),
            36 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectionClosed),
            37 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_NoConnection),
            38 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_Stats),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamNetworkingUDPMsgID] = &[
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeReply,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectRequest,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectOK,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectionClosed,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_NoConnection,
            ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_Stats,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamNetworkingUDPMsgID>("ESteamNetworkingUDPMsgID", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamNetworkingUDPMsgID {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESteamNetworkingUDPMsgID {
    fn default() -> Self {
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamNetworkingUDPMsgID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1csteamdatagram_messages.proto\x1a!steamdatagram_auth_messages.proto\
    \"\xfb\x04\n\x20CMsgSteamDatagramRouterPingReply\x12)\n\x10client_timest\
    amp\x18\x01\x20\x01(\x07R\x0fclientTimestamp\x128\n\x16latency_datacente\
    r_ids\x18\x02\x20\x03(\x07R\x14latencyDatacenterIdsB\x02\x10\x01\x12*\n\
    \x0flatency_ping_ms\x18\x03\x20\x03(\rR\rlatencyPingMsB\x02\x10\x01\x12$\
    \n\x0eyour_public_ip\x18\x04\x20\x01(\x07R\x0cyourPublicIp\x12\x1f\n\x0b\
    server_time\x18\x05\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\x18\
    \x06\x20\x01(\x06R\tchallenge\x124\n\x16seconds_until_shutdown\x18\x07\
    \x20\x01(\rR\x14secondsUntilShutdown\x12#\n\rclient_cookie\x18\x08\x20\
    \x01(\x07R\x0cclientCookie\x12A\n\x1dscoring_penalty_relay_cluster\x18\t\
    \x20\x01(\rR\x1ascoringPenaltyRelayCluster\x12[\n\x10route_exceptions\
    \x18\n\x20\x03(\x0b20.CMsgSteamDatagramRouterPingReply.RouteExceptionR\
    \x0frouteExceptions\x1af\n\x0eRouteException\x12$\n\x0edata_center_id\
    \x18\x01\x20\x01(\x07R\x0cdataCenterId\x12\x14\n\x05flags\x18\x02\x20\
    \x01(\rR\x05flags\x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\x07penalty\"\
    \xb0\x03\n\x1fCMsgSteamDatagramGameserverPing\x122\n\x15legacy_client_se\
    ssion\x18\x01\x20\x01(\rR\x13legacyClientSession\x12&\n\x0fclient_steam_\
    id\x18\x02\x20\x01(\x06R\rclientSteamId\x12)\n\x10client_timestamp\x18\
    \x03\x20\x01(\x07R\x0fclientTimestamp\x12)\n\x10router_timestamp\x18\x04\
    \x20\x01(\x07R\x0frouterTimestamp\x12:\n\x19router_gameserver_latency\
    \x18\x05\x20\x01(\rR\x17routerGameserverLatency\x12*\n\x11seq_number_rou\
    ter\x18\x06\x20\x01(\rR\x0fseqNumberRouter\x12$\n\x0eseq_number_e2e\x18\
    \x07\x20\x01(\rR\x0cseqNumberE2e\x12(\n\x10relay_session_id\x18\x08\x20\
    \x01(\rR\x0erelaySessionId\x12#\n\rconnection_id\x18\t\x20\x01(\x07R\x0c\
    connectionId\"\xcb\x01\n!CMsgSteamDatagramRelayToRelayPing\x12+\n\x11req\
    uest_timestamp\x18\x01\x20\x01(\x07R\x10requestTimestamp\x12!\n\x0creque\
    st_date\x18\x02\x20\x01(\x07R\x0brequestDate\x12\x1a\n\tmy_pop_id\x18\
    \x03\x20\x01(\x07R\x07myPopId\x12\x1e\n\x0byour_pop_id\x18\x04\x20\x01(\
    \x07R\tyourPopId\x12\x1a\n\x08checksum\x18\x05\x20\x01(\x07R\x08checksum\
    \"\xe5\x01\n!CMsgSteamDatagramSessionCryptInfo\x12O\n\x08key_type\x18\
    \x01\x20\x01(\x0e2+.CMsgSteamDatagramSessionCryptInfo.EKeyType:\x07INVAL\
    IDR\x07keyType\x12\x19\n\x08key_data\x18\x02\x20\x01(\x0cR\x07keyData\
    \x12\x14\n\x05nonce\x18\x03\x20\x01(\x06R\x05nonce\x12\x15\n\x06is_snp\
    \x18\x04\x20\x01(\x08R\x05isSnp\"'\n\x08EKeyType\x12\x0b\n\x07INVALID\
    \x10\0\x12\x0e\n\nCURVE25519\x10\x01\"[\n'CMsgSteamDatagramSessionCryptI\
    nfoSigned\x12\x12\n\x04info\x18\x01\x20\x01(\x0cR\x04info\x12\x1c\n\tsig\
    nature\x18\x02\x20\x01(\x0cR\tsignature\"\xcd\x02\n)CMsgSteamDatagramGam\
    eserverSessionRequest\x12\x16\n\x06ticket\x18\x01\x20\x01(\x0cR\x06ticke\
    t\x12%\n\x0echallenge_time\x18\x03\x20\x01(\x07R\rchallengeTime\x12\x1c\
    \n\tchallenge\x18\x04\x20\x01(\x06R\tchallenge\x120\n\x14client_connecti\
    on_id\x18\x05\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_conne\
    ction_id\x18\x08\x20\x01(\x07R\x12serverConnectionId\x124\n\x16network_c\
    onfig_version\x18\x06\x20\x01(\rR\x14networkConfigVersion\x12)\n\x10prot\
    ocol_version\x18\x07\x20\x01(\rR\x0fprotocolVersion\"\x91\x02\n-CMsgStea\
    mDatagramGameserverSessionEstablished\x12#\n\rconnection_id\x18\x01\x20\
    \x01(\x07R\x0cconnectionId\x12.\n\x13gameserver_steam_id\x18\x03\x20\x01\
    (\x06R\x11gameserverSteamId\x124\n\x16seconds_until_shutdown\x18\x04\x20\
    \x01(\rR\x14secondsUntilShutdown\x125\n\x17legacy_relay_session_id\x18\
    \x05\x20\x01(\rR\x14legacyRelaySessionId\x12\x1e\n\x0bseq_num_r2c\x18\
    \x06\x20\x01(\rR\tseqNumR2c\"\xa0\x02\n'CMsgSteamDatagramNoSessionRelayT\
    oClient\x125\n\x17legacy_relay_session_id\x18\x01\x20\x01(\rR\x14legacyR\
    elaySessionId\x12#\n\rconnection_id\x18\x07\x20\x01(\x07R\x0cconnectionI\
    d\x12$\n\x0eyour_public_ip\x18\x02\x20\x01(\x07R\x0cyourPublicIp\x12\x1f\
    \n\x0bserver_time\x18\x03\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\
    \x18\x04\x20\x01(\x06R\tchallenge\x124\n\x16seconds_until_shutdown\x18\
    \x05\x20\x01(\rR\x14secondsUntilShutdown\"\xd6\x01\n'CMsgSteamDatagramNo\
    SessionRelayToServer\x12(\n\x10relay_session_id\x18\x01\x20\x01(\rR\x0er\
    elaySessionId\x120\n\x14client_connection_id\x18\x07\x20\x01(\x07R\x12cl\
    ientConnectionId\x120\n\x14server_connection_id\x18\x08\x20\x01(\x07R\
    \x12serverConnectionId\x12\x1d\n\nkludge_pad\x18c\x20\x01(\x06R\tkludgeP\
    ad\"M\n\x1bCMsgSteamDatagramDiagnostic\x12\x1a\n\x08severity\x18\x01\x20\
    \x01(\rR\x08severity\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"\xef\
    \x02\n\x20CMsgSteamDatagramDataCenterState\x12O\n\x0cdata_centers\x18\
    \x01\x20\x03(\x0b2,.CMsgSteamDatagramDataCenterState.DataCenterR\x0bdata\
    Centers\x1a;\n\x06Server\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07add\
    ress\x12\x17\n\x07ping_ms\x18\x02\x20\x01(\rR\x06pingMs\x1a\xbc\x01\n\nD\
    ataCenter\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12M\n\rserver_s\
    ample\x18\x02\x20\x03(\x0b2(.CMsgSteamDatagramDataCenterState.ServerR\
    \x0cserverSample\x12K\n\x0crelay_sample\x18\x03\x20\x03(\x0b2(.CMsgSteam\
    DatagramDataCenterState.ServerR\x0brelaySample\"\x97\x03\n'CMsgSteamData\
    gramLinkInstantaneousStats\x124\n\x17out_packets_per_sec_x10\x18\x01\x20\
    \x01(\rR\x13outPacketsPerSecX10\x12)\n\x11out_bytes_per_sec\x18\x02\x20\
    \x01(\rR\x0eoutBytesPerSec\x122\n\x16in_packets_per_sec_x10\x18\x03\x20\
    \x01(\rR\x12inPacketsPerSecX10\x12'\n\x10in_bytes_per_sec\x18\x04\x20\
    \x01(\rR\rinBytesPerSec\x12\x17\n\x07ping_ms\x18\x05\x20\x01(\rR\x06ping\
    Ms\x12.\n\x13packets_dropped_pct\x18\x06\x20\x01(\rR\x11packetsDroppedPc\
    t\x12;\n\x1apackets_weird_sequence_pct\x18\x07\x20\x01(\rR\x17packetsWei\
    rdSequencePct\x12(\n\x10peak_jitter_usec\x18\x08\x20\x01(\rR\x0epeakJitt\
    erUsec\"\xe6\x19\n\"CMsgSteamDatagramLinkLifetimeStats\x12!\n\x0cpackets\
    _sent\x18\x03\x20\x01(\x04R\x0bpacketsSent\x12\x17\n\x07kb_sent\x18\x04\
    \x20\x01(\x04R\x06kbSent\x12!\n\x0cpackets_recv\x18\x05\x20\x01(\x04R\
    \x0bpacketsRecv\x12\x17\n\x07kb_recv\x18\x06\x20\x01(\x04R\x06kbRecv\x12\
    4\n\x16packets_recv_sequenced\x18\x07\x20\x01(\x04R\x14packetsRecvSequen\
    ced\x120\n\x14packets_recv_dropped\x18\x08\x20\x01(\x04R\x12packetsRecvD\
    ropped\x128\n\x19packets_recv_out_of_order\x18\t\x20\x01(\x04R\x15packet\
    sRecvOutOfOrder\x124\n\x16packets_recv_duplicate\x18\n\x20\x01(\x04R\x14\
    packetsRecvDuplicate\x12,\n\x12packets_recv_lurch\x18\x0b\x20\x01(\x04R\
    \x10packetsRecvLurch\x122\n\x15quality_histogram_100\x18\x15\x20\x01(\rR\
    \x13qualityHistogram100\x120\n\x14quality_histogram_99\x18\x16\x20\x01(\
    \rR\x12qualityHistogram99\x120\n\x14quality_histogram_97\x18\x17\x20\x01\
    (\rR\x12qualityHistogram97\x120\n\x14quality_histogram_95\x18\x18\x20\
    \x01(\rR\x12qualityHistogram95\x120\n\x14quality_histogram_90\x18\x19\
    \x20\x01(\rR\x12qualityHistogram90\x120\n\x14quality_histogram_75\x18\
    \x1a\x20\x01(\rR\x12qualityHistogram75\x120\n\x14quality_histogram_50\
    \x18\x1b\x20\x01(\rR\x12qualityHistogram50\x12.\n\x13quality_histogram_1\
    \x18\x1c\x20\x01(\rR\x11qualityHistogram1\x124\n\x16quality_histogram_de\
    ad\x18\x1d\x20\x01(\rR\x14qualityHistogramDead\x12*\n\x11quality_ntile_2\
    nd\x18\x1e\x20\x01(\rR\x0fqualityNtile2nd\x12*\n\x11quality_ntile_5th\
    \x18\x1f\x20\x01(\rR\x0fqualityNtile5th\x12,\n\x12quality_ntile_25th\x18\
    \x20\x20\x01(\rR\x10qualityNtile25th\x12,\n\x12quality_ntile_50th\x18!\
    \x20\x01(\rR\x10qualityNtile50th\x12*\n\x11ping_histogram_25\x18)\x20\
    \x01(\rR\x0fpingHistogram25\x12*\n\x11ping_histogram_50\x18*\x20\x01(\rR\
    \x0fpingHistogram50\x12*\n\x11ping_histogram_75\x18+\x20\x01(\rR\x0fping\
    Histogram75\x12,\n\x12ping_histogram_100\x18,\x20\x01(\rR\x10pingHistogr\
    am100\x12,\n\x12ping_histogram_125\x18-\x20\x01(\rR\x10pingHistogram125\
    \x12,\n\x12ping_histogram_150\x18.\x20\x01(\rR\x10pingHistogram150\x12,\
    \n\x12ping_histogram_200\x18/\x20\x01(\rR\x10pingHistogram200\x12,\n\x12\
    ping_histogram_300\x180\x20\x01(\rR\x10pingHistogram300\x12,\n\x12ping_h\
    istogram_max\x181\x20\x01(\rR\x10pingHistogramMax\x12$\n\x0eping_ntile_5\
    th\x182\x20\x01(\rR\x0cpingNtile5th\x12&\n\x0fping_ntile_50th\x183\x20\
    \x01(\rR\rpingNtile50th\x12&\n\x0fping_ntile_75th\x184\x20\x01(\rR\rping\
    Ntile75th\x12&\n\x0fping_ntile_95th\x185\x20\x01(\rR\rpingNtile95th\x12&\
    \n\x0fping_ntile_98th\x186\x20\x01(\rR\rpingNtile98th\x12>\n\x1bjitter_h\
    istogram_negligible\x18=\x20\x01(\rR\x19jitterHistogramNegligible\x12,\n\
    \x12jitter_histogram_1\x18>\x20\x01(\rR\x10jitterHistogram1\x12,\n\x12ji\
    tter_histogram_2\x18?\x20\x01(\rR\x10jitterHistogram2\x12,\n\x12jitter_h\
    istogram_5\x18@\x20\x01(\rR\x10jitterHistogram5\x12.\n\x13jitter_histogr\
    am_10\x18A\x20\x01(\rR\x11jitterHistogram10\x12.\n\x13jitter_histogram_2\
    0\x18B\x20\x01(\rR\x11jitterHistogram20\x12\x1f\n\x0btxspeed_max\x18C\
    \x20\x01(\rR\ntxspeedMax\x120\n\x14txspeed_histogram_16\x18D\x20\x01(\rR\
    \x12txspeedHistogram16\x120\n\x14txspeed_histogram_32\x18E\x20\x01(\rR\
    \x12txspeedHistogram32\x120\n\x14txspeed_histogram_64\x18F\x20\x01(\rR\
    \x12txspeedHistogram64\x122\n\x15txspeed_histogram_128\x18G\x20\x01(\rR\
    \x13txspeedHistogram128\x122\n\x15txspeed_histogram_256\x18H\x20\x01(\rR\
    \x13txspeedHistogram256\x122\n\x15txspeed_histogram_512\x18I\x20\x01(\rR\
    \x13txspeedHistogram512\x124\n\x16txspeed_histogram_1024\x18J\x20\x01(\r\
    R\x14txspeedHistogram1024\x122\n\x15txspeed_histogram_max\x18K\x20\x01(\
    \rR\x13txspeedHistogramMax\x12*\n\x11txspeed_ntile_5th\x18L\x20\x01(\rR\
    \x0ftxspeedNtile5th\x12,\n\x12txspeed_ntile_50th\x18M\x20\x01(\rR\x10txs\
    peedNtile50th\x12,\n\x12txspeed_ntile_75th\x18N\x20\x01(\rR\x10txspeedNt\
    ile75th\x12,\n\x12txspeed_ntile_95th\x18O\x20\x01(\rR\x10txspeedNtile95t\
    h\x12,\n\x12txspeed_ntile_98th\x18P\x20\x01(\rR\x10txspeedNtile98th\x12\
    \x1f\n\x0brxspeed_max\x18Q\x20\x01(\rR\nrxspeedMax\x120\n\x14rxspeed_his\
    togram_16\x18R\x20\x01(\rR\x12rxspeedHistogram16\x120\n\x14rxspeed_histo\
    gram_32\x18S\x20\x01(\rR\x12rxspeedHistogram32\x120\n\x14rxspeed_histogr\
    am_64\x18T\x20\x01(\rR\x12rxspeedHistogram64\x122\n\x15rxspeed_histogram\
    _128\x18U\x20\x01(\rR\x13rxspeedHistogram128\x122\n\x15rxspeed_histogram\
    _256\x18V\x20\x01(\rR\x13rxspeedHistogram256\x122\n\x15rxspeed_histogram\
    _512\x18W\x20\x01(\rR\x13rxspeedHistogram512\x124\n\x16rxspeed_histogram\
    _1024\x18X\x20\x01(\rR\x14rxspeedHistogram1024\x122\n\x15rxspeed_histogr\
    am_max\x18Y\x20\x01(\rR\x13rxspeedHistogramMax\x12*\n\x11rxspeed_ntile_5\
    th\x18Z\x20\x01(\rR\x0frxspeedNtile5th\x12,\n\x12rxspeed_ntile_50th\x18[\
    \x20\x01(\rR\x10rxspeedNtile50th\x12,\n\x12rxspeed_ntile_75th\x18\\\x20\
    \x01(\rR\x10rxspeedNtile75th\x12,\n\x12rxspeed_ntile_95th\x18]\x20\x01(\
    \rR\x10rxspeedNtile95th\x12,\n\x12rxspeed_ntile_98th\x18^\x20\x01(\rR\
    \x10rxspeedNtile98th\"\xb5\x01\n\"CMsgSteamDatagramConnectionQuality\x12\
    N\n\rinstantaneous\x18\x01\x20\x01(\x0b2(.CMsgSteamDatagramLinkInstantan\
    eousStatsR\rinstantaneous\x12?\n\x08lifetime\x18\x02\x20\x01(\x0b2#.CMsg\
    SteamDatagramLinkLifetimeStatsR\x08lifetime\"\xe4\x03\n.CMsgSteamDatagra\
    mConnectionStatsClientToRouter\x125\n\x03c2r\x18\x01\x20\x01(\x0b2#.CMsg\
    SteamDatagramConnectionQualityR\x03c2r\x125\n\x03c2s\x18\x02\x20\x01(\
    \x0b2#.CMsgSteamDatagramConnectionQualityR\x03c2s\x126\n\x17legacy_clien\
    t_timestamp\x18\x03\x20\x01(\x07R\x15legacyClientTimestamp\x12\x1b\n\tac\
    k_relay\x18\x04\x20\x03(\x07R\x08ackRelay\x12\x17\n\x07ack_e2e\x18\x05\
    \x20\x03(\x07R\x06ackE2e\x12\x14\n\x05flags\x18\x06\x20\x01(\rR\x05flags\
    \x120\n\x14client_connection_id\x18\x08\x20\x01(\x07R\x12clientConnectio\
    nId\x12\x1e\n\x0bseq_num_c2r\x18\t\x20\x01(\rR\tseqNumC2r\x12\x1e\n\x0bs\
    eq_num_c2s\x18\n\x20\x01(\rR\tseqNumC2s\"N\n\x05Flags\x12\x15\n\x11ACK_R\
    EQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15A\
    CK_REQUEST_IMMEDIATE\x10\x04\"\xdd\x06\n.CMsgSteamDatagramConnectionStat\
    sRouterToClient\x125\n\x03r2c\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramCo\
    nnectionQualityR\x03r2c\x125\n\x03s2c\x18\x02\x20\x01(\x0b2#.CMsgSteamDa\
    tagramConnectionQualityR\x03s2c\x12L\n#legacy_client_timestamp_from_rout\
    er\x18\x03\x20\x01(\x07R\x1flegacyClientTimestampFromRouter\x12L\n#legac\
    y_client_timestamp_from_server\x18\x04\x20\x01(\x07R\x1flegacyClientTime\
    stampFromServer\x12:\n\x19router_gameserver_latency\x18\x05\x20\x01(\rR\
    \x17routerGameserverLatency\x124\n\x16seconds_until_shutdown\x18\x06\x20\
    \x01(\rR\x14secondsUntilShutdown\x12,\n\x12migrate_request_ip\x18\n\x20\
    \x01(\x07R\x10migrateRequestIp\x120\n\x14migrate_request_port\x18\x0b\
    \x20\x01(\rR\x12migrateRequestPort\x12A\n\x1dscoring_penalty_relay_clust\
    er\x18\x0c\x20\x01(\rR\x1ascoringPenaltyRelayCluster\x12\x1b\n\tack_rela\
    y\x18\r\x20\x03(\x07R\x08ackRelay\x12\x17\n\x07ack_e2e\x18\x0e\x20\x03(\
    \x07R\x06ackE2e\x12\x14\n\x05flags\x18\x0f\x20\x01(\rR\x05flags\x120\n\
    \x14client_connection_id\x18\x07\x20\x01(\x07R\x12clientConnectionId\x12\
    \x1e\n\x0bseq_num_r2c\x18\x08\x20\x01(\rR\tseqNumR2c\x12\x1e\n\x0bseq_nu\
    m_s2c\x18\t\x20\x01(\rR\tseqNumS2c\"N\n\x05Flags\x12\x15\n\x11ACK_REQUES\
    T_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_RE\
    QUEST_IMMEDIATE\x10\x04\"\xa0\x05\n.CMsgSteamDatagramConnectionStatsRout\
    erToServer\x125\n\x03r2s\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnect\
    ionQualityR\x03r2s\x125\n\x03c2s\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagra\
    mConnectionQualityR\x03c2s\x126\n\x17legacy_client_timestamp\x18\x03\x20\
    \x01(\x07R\x15legacyClientTimestamp\x126\n\x17legacy_router_timestamp\
    \x18\x04\x20\x01(\x07R\x15legacyRouterTimestamp\x12\x1b\n\tack_relay\x18\
    \n\x20\x03(\x07R\x08ackRelay\x12\x17\n\x07ack_e2e\x18\x0b\x20\x03(\x07R\
    \x06ackE2e\x12\x14\n\x05flags\x18\x0c\x20\x01(\rR\x05flags\x12\x1e\n\x0b\
    seq_num_r2s\x18\x05\x20\x01(\rR\tseqNumR2s\x12\x1e\n\x0bseq_num_c2s\x18\
    \x06\x20\x01(\rR\tseqNumC2s\x12&\n\x0fclient_steam_id\x18\x07\x20\x01(\
    \x06R\rclientSteamId\x12(\n\x10relay_session_id\x18\x08\x20\x01(\rR\x0er\
    elaySessionId\x120\n\x14client_connection_id\x18\t\x20\x01(\x07R\x12clie\
    ntConnectionId\x120\n\x14server_connection_id\x18\r\x20\x01(\x07R\x12ser\
    verConnectionId\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\
    \x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\
    \x04\"\xb0\x04\n.CMsgSteamDatagramConnectionStatsServerToRouter\x125\n\
    \x03s2r\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03s2\
    r\x125\n\x03s2c\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualit\
    yR\x03s2c\x12\x1b\n\tack_relay\x18\x08\x20\x03(\x07R\x08ackRelay\x12\x17\
    \n\x07ack_e2e\x18\t\x20\x03(\x07R\x06ackE2e\x12\x14\n\x05flags\x18\n\x20\
    \x01(\rR\x05flags\x12\x1e\n\x0bseq_num_s2r\x18\x03\x20\x01(\rR\tseqNumS2\
    r\x12\x1e\n\x0bseq_num_s2c\x18\x04\x20\x01(\rR\tseqNumS2c\x12&\n\x0fclie\
    nt_steam_id\x18\x05\x20\x01(\x06R\rclientSteamId\x12(\n\x10relay_session\
    _id\x18\x06\x20\x01(\rR\x0erelaySessionId\x120\n\x14client_connection_id\
    \x18\x07\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connection\
    _id\x18\x0b\x20\x01(\x07R\x12serverConnectionId\"N\n\x05Flags\x12\x15\n\
    \x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\
    \x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\"O\n(CMsgSteamDatagramClientPing\
    SampleRequest\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionI\
    d\"\xe3\x03\n&CMsgSteamDatagramClientPingSampleReply\x12#\n\rconnection_\
    id\x18\x01\x20\x01(\x07R\x0cconnectionId\x12a\n\x10routing_clusters\x18\
    \x02\x20\x03(\x0b26.CMsgSteamDatagramClientPingSampleReply.RoutingCluste\
    rR\x0froutingClusters\x12U\n\x0cdata_centers\x18\x03\x20\x03(\x0b22.CMsg\
    SteamDatagramClientPingSampleReply.DataCenterR\x0bdataCenters\x1ad\n\x0e\
    RoutingCluster\x12\x0e\n\x02id\x18\x01\x20\x01(\x07R\x02id\x12\"\n\rfron\
    t_ping_ms\x18\x02\x20\x01(\rR\x0bfrontPingMs\x12\x1e\n\x0be2e_ping_ms\
    \x18\x03\x20\x01(\rR\te2ePingMs\x1at\n\nDataCenter\x12$\n\x0edata_center\
    _id\x18\x01\x20\x01(\x07R\x0cdataCenterId\x12\x20\n\x0cvia_relay_id\x18\
    \x02\x20\x01(\x07R\nviaRelayId\x12\x1e\n\x0be2e_ping_ms\x18\x03\x20\x01(\
    \rR\te2ePingMs\"\xef\x06\n&CMsgSteamDatagramClientSwitchedPrimary\x12#\n\
    \rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\x12\x17\n\x07from_\
    ip\x18\x02\x20\x01(\x07R\x06fromIp\x12\x1b\n\tfrom_port\x18\x03\x20\x01(\
    \rR\x08fromPort\x12.\n\x13from_router_cluster\x18\x04\x20\x01(\x07R\x11f\
    romRouterCluster\x12(\n\x10from_active_time\x18\x05\x20\x01(\rR\x0efromA\
    ctiveTime\x127\n\x18from_active_packets_recv\x18\x06\x20\x01(\rR\x15from\
    ActivePacketsRecv\x12.\n\x13from_dropped_reason\x18\x07\x20\x01(\tR\x11f\
    romDroppedReason\x12\x15\n\x06gap_ms\x18\x08\x20\x01(\rR\x05gapMs\x12_\n\
    \x10from_quality_now\x18\t\x20\x01(\x0b25.CMsgSteamDatagramClientSwitche\
    dPrimary.RouterQualityR\x0efromQualityNow\x12[\n\x0eto_quality_now\x18\n\
    \x20\x01(\x0b25.CMsgSteamDatagramClientSwitchedPrimary.RouterQualityR\
    \x0ctoQualityNow\x12a\n\x11from_quality_then\x18\x0b\x20\x01(\x0b25.CMsg\
    SteamDatagramClientSwitchedPrimary.RouterQualityR\x0ffromQualityThen\x12\
    ]\n\x0fto_quality_then\x18\x0c\x20\x01(\x0b25.CMsgSteamDatagramClientSwi\
    tchedPrimary.RouterQualityR\rtoQualityThen\x1a\x8f\x01\n\rRouterQuality\
    \x12\x14\n\x05score\x18\x01\x20\x01(\rR\x05score\x12\x1d\n\nfront_ping\
    \x18\x02\x20\x01(\rR\tfrontPing\x12\x1b\n\tback_ping\x18\x03\x20\x01(\rR\
    \x08backPing\x12,\n\x12seconds_until_down\x18\x04\x20\x01(\rR\x10seconds\
    UntilDown\"\xea\x03\n\x1dCMsgSteamDatagramRouterHealth\x12\x19\n\x08cpu_\
    load\x18\x01\x20\x01(\x02R\x07cpuLoad\x12'\n\x0factive_sessions\x18\x02\
    \x20\x01(\rR\x0eactiveSessions\x12\"\n\rdata_pkts_sec\x18\x03\x20\x01(\r\
    R\x0bdataPktsSec\x12$\n\x0eother_pkts_sec\x18\x04\x20\x01(\rR\x0cotherPk\
    tsSec\x124\n\x16seconds_until_shutdown\x18\x05\x20\x01(\rR\x14secondsUnt\
    ilShutdown\x12)\n\x11cpu_cost_per_user\x18\x08\x20\x01(\x02R\x0ecpuCostP\
    erUser\x12-\n\x13cpu_cost_per_packet\x18\t\x20\x01(\x02R\x10cpuCostPerPa\
    cket\x12L\n\x0cdata_centers\x18\x06\x20\x03(\x0b2).CMsgSteamDatagramRout\
    erHealth.DataCenterR\x0bdataCenters\x12\x14\n\x05magic\x18\x07\x20\x01(\
    \x06R\x05magic\x1aG\n\nDataCenter\x12#\n\rdatacenter_id\x18\x01\x20\x01(\
    \x07R\x0cdatacenterId\x12\x14\n\x05state\x18\x02\x20\x01(\rR\x05state\"\
    \xb7\x03\n\x1fCMsgSteamDatagramConnectRequest\x12#\n\rconnection_id\x18\
    \x01\x20\x01(\x07R\x0cconnectionId\x12&\n\x0fclient_steam_id\x18\x03\x20\
    \x01(\x06R\rclientSteamId\x12!\n\x0cmy_timestamp\x18\x04\x20\x01(\x06R\
    \x0bmyTimestamp\x12\x1e\n\x0bping_est_ms\x18\x05\x20\x01(\rR\tpingEstMs\
    \x12!\n\x0cvirtual_port\x18\t\x20\x01(\rR\x0bvirtualPort\x12=\n\x1bgames\
    erver_relay_session_id\x18\x02\x20\x01(\rR\x18gameserverRelaySessionId\
    \x12>\n\x05crypt\x18\x06\x20\x01(\x0b2(.CMsgSteamDatagramSessionCryptInf\
    oSignedR\x05crypt\x127\n\x04cert\x18\x07\x20\x01(\x0b2#.CMsgSteamDatagra\
    mCertificateSignedR\x04cert\x12)\n\x10protocol_version\x18\x08\x20\x01(\
    \rR\x0fprotocolVersion\"\xb2\x03\n\x1aCMsgSteamDatagramConnectOK\x120\n\
    \x14client_connection_id\x18\x01\x20\x01(\x07R\x12clientConnectionId\x12\
    0\n\x14server_connection_id\x18\x07\x20\x01(\x07R\x12serverConnectionId\
    \x12%\n\x0eyour_timestamp\x18\x03\x20\x01(\x06R\ryourTimestamp\x12&\n\
    \x0fdelay_time_usec\x18\x04\x20\x01(\rR\rdelayTimeUsec\x12=\n\x1bgameser\
    ver_relay_session_id\x18\x02\x20\x01(\rR\x18gameserverRelaySessionId\x12\
    >\n\x05crypt\x18\x05\x20\x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSig\
    nedR\x05crypt\x127\n\x04cert\x18\x06\x20\x01(\x0b2#.CMsgSteamDatagramCer\
    tificateSignedR\x04cert\x12)\n\x10protocol_version\x18\x08\x20\x01(\rR\
    \x0fprotocolVersion\"\xe0\x03\n!CMsgSteamDatagramConnectionClosed\x12=\n\
    \x1blegacy_client_connection_id\x18\x01\x20\x01(\x07R\x18legacyClientCon\
    nectionId\x12(\n\x10to_connection_id\x18\x07\x20\x01(\x07R\x0etoConnecti\
    onId\x12,\n\x12from_connection_id\x18\x08\x20\x01(\x07R\x10fromConnectio\
    nId\x12\"\n\rpeer_steam_id\x18\x03\x20\x01(\x06R\x0bpeerSteamId\x12=\n\
    \x1bgameserver_relay_session_id\x18\x02\x20\x01(\rR\x18gameserverRelaySe\
    ssionId\x12R\n\nrelay_mode\x18\x04\x20\x01(\x0e2-.CMsgSteamDatagramConne\
    ctionClosed.ERelayMode:\x04NoneR\trelayMode\x12\x14\n\x05debug\x18\x05\
    \x20\x01(\tR\x05debug\x12\x1f\n\x0breason_code\x18\x06\x20\x01(\rR\nreas\
    onCode\"6\n\nERelayMode\x12\x08\n\x04None\x10\0\x12\x0c\n\x08EndToEnd\
    \x10\x01\x12\x10\n\x0cClosedByPeer\x10\x02\"\xd5\x02\n\x1dCMsgSteamDatag\
    ramNoConnection\x12=\n\x1blegacy_client_connection_id\x18\x01\x20\x01(\
    \x07R\x18legacyClientConnectionId\x12(\n\x10to_connection_id\x18\x05\x20\
    \x01(\x07R\x0etoConnectionId\x12,\n\x12from_connection_id\x18\x06\x20\
    \x01(\x07R\x10fromConnectionId\x12=\n\x1bgameserver_relay_session_id\x18\
    \x02\x20\x01(\rR\x18gameserverRelaySessionId\x12\"\n\rpeer_steam_id\x18\
    \x03\x20\x01(\x06R\x0bpeerSteamId\x12\x1c\n\nend_to_end\x18\x04\x20\x01(\
    \x08R\x08endToEnd\x12\x1c\n\tdummy_pad\x18\xff\x07\x20\x01(\x07R\x08dumm\
    yPad\"\xe7\x02\n&CMsgSteamDatagramP2PSessionRequestBody\x12%\n\x0echalle\
    nge_time\x18\x01\x20\x01(\x07R\rchallengeTime\x12\x1c\n\tchallenge\x18\
    \x02\x20\x01(\x06R\tchallenge\x12(\n\x10my_connection_id\x18\x03\x20\x01\
    (\x07R\x0emyConnectionId\x12\"\n\rpeer_steam_id\x18\x04\x20\x01(\x06R\
    \x0bpeerSteamId\x12,\n\x12peer_connection_id\x18\x05\x20\x01(\x07R\x10pe\
    erConnectionId\x12)\n\x10protocol_version\x18\x08\x20\x01(\rR\x0fprotoco\
    lVersion\x124\n\x16network_config_version\x18\t\x20\x01(\rR\x14networkCo\
    nfigVersion\x12\x1b\n\tpublic_ip\x18\n\x20\x01(\x07R\x08publicIp\"\x8f\
    \x01\n\"CMsgSteamDatagramP2PSessionRequest\x127\n\x04cert\x18\x01\x20\
    \x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04cert\x12\x12\n\x04bod\
    y\x18\x02\x20\x01(\x0cR\x04body\x12\x1c\n\tsignature\x18\x03\x20\x01(\
    \x0cR\tsignature\"\xcd\x01\n&CMsgSteamDatagramP2PSessionEstablished\x12#\
    \n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\x124\n\x16second\
    s_until_shutdown\x18\x03\x20\x01(\rR\x14secondsUntilShutdown\x12(\n\x10r\
    elay_routing_id\x18\x04\x20\x01(\x06R\x0erelayRoutingId\x12\x1e\n\x0bseq\
    _num_r2c\x18\x05\x20\x01(\rR\tseqNumR2c\"\xbe\x03\n\x1aCMsgSteamDatagram\
    P2PRoutes\x12O\n\x0erelay_clusters\x18\x01\x20\x03(\x0b2(.CMsgSteamDatag\
    ramP2PRoutes.RelayClusterR\rrelayClusters\x129\n\x06routes\x18\x02\x20\
    \x03(\x0b2!.CMsgSteamDatagramP2PRoutes.RouteR\x06routes\x12\x1a\n\x08rev\
    ision\x18\x03\x20\x01(\rR\x08revision\x1a\x9c\x01\n\x0cRelayCluster\x12\
    \x15\n\x06pop_id\x18\x01\x20\x01(\x07R\x05popId\x12\x17\n\x07ping_ms\x18\
    \x02\x20\x01(\rR\x06pingMs\x12#\n\rscore_penalty\x18\x03\x20\x01(\rR\x0c\
    scorePenalty\x127\n\x18session_relay_routing_id\x18\x04\x20\x01(\x06R\
    \x15sessionRelayRoutingId\x1aY\n\x05Route\x12\x1a\n\tmy_pop_id\x18\x01\
    \x20\x01(\x07R\x07myPopId\x12\x1e\n\x0byour_pop_id\x18\x02\x20\x01(\x07R\
    \tyourPopId\x12\x14\n\x05score\x18\x03\x20\x01(\rR\x05score\"\x90\x03\n\
    \x1eCMsgSteamDatagramP2PRendezvous\x12(\n\x10to_connection_id\x18\x01\
    \x20\x01(\x07R\x0etoConnectionId\x123\n\x06routes\x18\x02\x20\x01(\x0b2\
    \x1b.CMsgSteamDatagramP2PRoutesR\x06routes\x127\n\x18ack_peer_routes_rev\
    ision\x18\x03\x20\x01(\rR\x15ackPeerRoutesRevision\x12I\n\x0fconnect_req\
    uest\x18\x04\x20\x01(\x0b2\x20.CMsgSteamDatagramConnectRequestR\x0econne\
    ctRequest\x12:\n\nconnect_ok\x18\x05\x20\x01(\x0b2\x1b.CMsgSteamDatagram\
    ConnectOKR\tconnectOk\x12O\n\x11connection_closed\x18\x06\x20\x01(\x0b2\
    \".CMsgSteamDatagramConnectionClosedR\x10connectionClosed\"\x8e\x05\n1CM\
    sgSteamDatagramConnectionStatsP2PClientToRouter\x125\n\x03c2r\x18\x01\
    \x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03c2r\x125\n\x03c2s\
    \x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03c2s\x12\
    \x1b\n\tack_relay\x18\x03\x20\x03(\x07R\x08ackRelay\x12\x17\n\x07ack_e2e\
    \x18\x04\x20\x03(\x07R\x06ackE2e\x12\x14\n\x05flags\x18\x05\x20\x01(\rR\
    \x05flags\x12D\n\x1fforward_target_relay_routing_id\x18\x06\x20\x01(\x06\
    R\x1bforwardTargetRelayRoutingId\x126\n\x17forward_target_revision\x18\
    \x07\x20\x01(\rR\x15forwardTargetRevision\x123\n\x06routes\x18\x08\x20\
    \x01(\x0b2\x1b.CMsgSteamDatagramP2PRoutesR\x06routes\x127\n\x18ack_peer_\
    routes_revision\x18\t\x20\x01(\rR\x15ackPeerRoutesRevision\x12#\n\rconne\
    ction_id\x18\n\x20\x01(\x07R\x0cconnectionId\x12\x1e\n\x0bseq_num_c2r\
    \x18\x0b\x20\x01(\rR\tseqNumC2r\x12\x1e\n\x0bseq_num_c2s\x18\x0c\x20\x01\
    (\rR\tseqNumC2s\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\
    \x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\
    \x04\"\xa8\x06\n1CMsgSteamDatagramConnectionStatsP2PRouterToClient\x125\
    \n\x03r2c\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03\
    r2c\x125\n\x03p2c\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQual\
    ityR\x03p2c\x124\n\x16seconds_until_shutdown\x18\x03\x20\x01(\rR\x14seco\
    ndsUntilShutdown\x12,\n\x12migrate_request_ip\x18\x04\x20\x01(\x07R\x10m\
    igrateRequestIp\x120\n\x14migrate_request_port\x18\x05\x20\x01(\rR\x12mi\
    grateRequestPort\x12A\n\x1dscoring_penalty_relay_cluster\x18\x06\x20\x01\
    (\rR\x1ascoringPenaltyRelayCluster\x12\x1b\n\tack_relay\x18\x07\x20\x03(\
    \x07R\x08ackRelay\x12\x17\n\x07ack_e2e\x18\x08\x20\x03(\x07R\x06ackE2e\
    \x12\x14\n\x05flags\x18\t\x20\x01(\rR\x05flags\x12=\n\x1back_forward_tar\
    get_revision\x18\n\x20\x01(\rR\x18ackForwardTargetRevision\x123\n\x06rou\
    tes\x18\x0b\x20\x01(\x0b2\x1b.CMsgSteamDatagramP2PRoutesR\x06routes\x127\
    \n\x18ack_peer_routes_revision\x18\x0c\x20\x01(\rR\x15ackPeerRoutesRevis\
    ion\x12#\n\rconnection_id\x18\r\x20\x01(\x07R\x0cconnectionId\x12\x1e\n\
    \x0bseq_num_r2c\x18\x0e\x20\x01(\rR\tseqNumR2c\x12\x1e\n\x0bseq_num_p2c\
    \x18\x0f\x20\x01(\rR\tseqNumP2c\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_R\
    ELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUE\
    ST_IMMEDIATE\x10\x04\"\x9a\x01\n%CMsgSteamSockets_UDP_ChallengeRequest\
    \x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\x12!\n\x0cm\
    y_timestamp\x18\x03\x20\x01(\x06R\x0bmyTimestamp\x12)\n\x10protocol_vers\
    ion\x18\x04\x20\x01(\rR\x0fprotocolVersion\"\xba\x01\n#CMsgSteamSockets_\
    UDP_ChallengeReply\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnec\
    tionId\x12\x1c\n\tchallenge\x18\x02\x20\x01(\x06R\tchallenge\x12%\n\x0ey\
    our_timestamp\x18\x03\x20\x01(\x06R\ryourTimestamp\x12)\n\x10protocol_ve\
    rsion\x18\x04\x20\x01(\rR\x0fprotocolVersion\"\x84\x03\n#CMsgSteamSocket\
    s_UDP_ConnectRequest\x120\n\x14client_connection_id\x18\x01\x20\x01(\x07\
    R\x12clientConnectionId\x12\x1c\n\tchallenge\x18\x02\x20\x01(\x06R\tchal\
    lenge\x12&\n\x0fclient_steam_id\x18\x03\x20\x01(\x06R\rclientSteamId\x12\
    !\n\x0cmy_timestamp\x18\x05\x20\x01(\x06R\x0bmyTimestamp\x12\x1e\n\x0bpi\
    ng_est_ms\x18\x06\x20\x01(\rR\tpingEstMs\x12>\n\x05crypt\x18\x07\x20\x01\
    (\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\x04cert\
    \x18\x04\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04cert\x12)\
    \n\x10protocol_version\x18\x08\x20\x01(\rR\x0fprotocolVersion\"\x9f\x03\
    \n\x1eCMsgSteamSockets_UDP_ConnectOK\x120\n\x14client_connection_id\x18\
    \x01\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connection_id\
    \x18\x05\x20\x01(\x07R\x12serverConnectionId\x12&\n\x0fserver_steam_id\
    \x18\x02\x20\x01(\x06R\rserverSteamId\x12%\n\x0eyour_timestamp\x18\x03\
    \x20\x01(\x06R\ryourTimestamp\x12&\n\x0fdelay_time_usec\x18\x04\x20\x01(\
    \rR\rdelayTimeUsec\x12>\n\x05crypt\x18\x07\x20\x01(\x0b2(.CMsgSteamDatag\
    ramSessionCryptInfoSignedR\x05crypt\x127\n\x04cert\x18\x08\x20\x01(\x0b2\
    #.CMsgSteamDatagramCertificateSignedR\x04cert\x12)\n\x10protocol_version\
    \x18\t\x20\x01(\rR\x0fprotocolVersion\"\xf5\x01\n%CMsgSteamSockets_UDP_C\
    onnectionClosed\x12=\n\x1blegacy_client_connection_id\x18\x01\x20\x01(\
    \x07R\x18legacyClientConnectionId\x12(\n\x10to_connection_id\x18\x04\x20\
    \x01(\x07R\x0etoConnectionId\x12,\n\x12from_connection_id\x18\x05\x20\
    \x01(\x07R\x10fromConnectionId\x12\x14\n\x05debug\x18\x02\x20\x01(\tR\
    \x05debug\x12\x1f\n\x0breason_code\x18\x03\x20\x01(\rR\nreasonCode\"\xba\
    \x01\n!CMsgSteamSockets_UDP_NoConnection\x12=\n\x1blegacy_client_connect\
    ion_id\x18\x01\x20\x01(\x07R\x18legacyClientConnectionId\x12,\n\x12from_\
    connection_id\x18\x02\x20\x01(\x07R\x10fromConnectionId\x12(\n\x10to_con\
    nection_id\x18\x03\x20\x01(\x07R\x0etoConnectionId\"\xef\x02\n\x1aCMsgSt\
    eamSockets_UDP_Stats\x129\n\x05stats\x18\x01\x20\x01(\x0b2#.CMsgSteamDat\
    agramConnectionQualityR\x05stats\x12\x17\n\x07ack_e2e\x18\x02\x20\x03(\
    \x07R\x06ackE2e\x12\x14\n\x05flags\x18\x03\x20\x01(\rR\x05flags\x12=\n\
    \x1blegacy_client_connection_id\x18\x08\x20\x01(\x07R\x18legacyClientCon\
    nectionId\x12(\n\x10to_connection_id\x18\t\x20\x01(\x07R\x0etoConnection\
    Id\x12,\n\x12from_connection_id\x18\n\x20\x01(\x07R\x10fromConnectionId\
    \x12\x17\n\x07seq_num\x18\x04\x20\x01(\rR\x06seqNum\"7\n\x05Flags\x12\
    \x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\
    \x04*\xf5\x08\n\x13ESteamDatagramMsgID\x12\x1f\n\x1bk_ESteamDatagramMsg_\
    Invalid\x10\0\x12)\n%k_ESteamDatagramMsg_RouterPingRequest\x10\x01\x12'\
    \n#k_ESteamDatagramMsg_RouterPingReply\x10\x02\x12-\n)k_ESteamDatagramMs\
    g_GameserverPingRequest\x10\x03\x12+\n'k_ESteamDatagramMsg_GameserverPin\
    gReply\x10\x04\x120\n,k_ESteamDatagramMsg_GameserverSessionRequest\x10\
    \x05\x124\n0k_ESteamDatagramMsg_GameserverSessionEstablished\x10\x06\x12\
    !\n\x1dk_ESteamDatagramMsg_NoSession\x10\x07\x12\"\n\x1ek_ESteamDatagram\
    Msg_Diagnostic\x10\x08\x12*\n&k_ESteamDatagramMsg_DataClientToRouter\x10\
    \t\x12*\n&k_ESteamDatagramMsg_DataRouterToServer\x10\n\x12*\n&k_ESteamDa\
    tagramMsg_DataServerToRouter\x10\x0b\x12*\n&k_ESteamDatagramMsg_DataRout\
    erToClient\x10\x0c\x12\x1d\n\x19k_ESteamDatagramMsg_Stats\x10\r\x12/\n+k\
    _ESteamDatagramMsg_ClientPingSampleRequest\x10\x0e\x12-\n)k_ESteamDatagr\
    amMsg_ClientPingSampleReply\x10\x0f\x125\n1k_ESteamDatagramMsg_ClientToR\
    outerSwitchedPrimary\x10\x10\x12#\n\x1fk_ESteamDatagramMsg_RelayHealth\
    \x10\x11\x12&\n\"k_ESteamDatagramMsg_ConnectRequest\x10\x12\x12!\n\x1dk_\
    ESteamDatagramMsg_ConnectOK\x10\x13\x12(\n$k_ESteamDatagramMsg_Connectio\
    nClosed\x10\x14\x12$\n\x20k_ESteamDatagramMsg_NoConnection\x10\x15\x12/\
    \n+k_ESteamDatagramMsg_RelayToRelayPingRequest\x10\x16\x12-\n)k_ESteamDa\
    tagramMsg_RelayToRelayPingReply\x10\x17\x12)\n%k_ESteamDatagramMsg_P2PSe\
    ssionRequest\x10\x18\x12-\n)k_ESteamDatagramMsg_P2PSessionEstablished\
    \x10\x19*\xc9\x02\n\x18ESteamNetworkingUDPMsgID\x12-\n)k_ESteamNetworkin\
    gUDPMsg_ChallengeRequest\x10\x20\x12+\n'k_ESteamNetworkingUDPMsg_Challen\
    geReply\x10!\x12+\n'k_ESteamNetworkingUDPMsg_ConnectRequest\x10\"\x12&\n\
    \"k_ESteamNetworkingUDPMsg_ConnectOK\x10#\x12-\n)k_ESteamNetworkingUDPMs\
    g_ConnectionClosed\x10$\x12)\n%k_ESteamNetworkingUDPMsg_NoConnection\x10\
    %\x12\"\n\x1ek_ESteamNetworkingUDPMsg_Stats\x10&B\x03\x80\x01\0J\xaa\xf0\
    \x01\n\x07\x12\x05\0\0\xd4\x04\x01\n\t\n\x02\x03\0\x12\x03\0\x07*\n\x08\
    \n\x01\x08\x12\x03\x02\0#\n\t\n\x02\x08\x10\x12\x03\x02\0#\n\n\n\x02\x05\
    \0\x12\x04\x04\0\x1f\x01\n\n\n\x03\x05\0\x01\x12\x03\x04\x05\x18\n\x0b\n\
    \x04\x05\0\x02\0\x12\x03\x05\x08(\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\
    \x05\x08#\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x05&'\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x06\x082\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x06\x08-\
    \n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0601\n\x0b\n\x04\x05\0\x02\x02\
    \x12\x03\x07\x080\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x07\x08+\n\x0c\n\
    \x05\x05\0\x02\x02\x02\x12\x03\x07./\n\x0b\n\x04\x05\0\x02\x03\x12\x03\
    \x08\x086\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x08\x081\n\x0c\n\x05\x05\
    \0\x02\x03\x02\x12\x03\x0845\n\x0b\n\x04\x05\0\x02\x04\x12\x03\t\x084\n\
    \x0c\n\x05\x05\0\x02\x04\x01\x12\x03\t\x08/\n\x0c\n\x05\x05\0\x02\x04\
    \x02\x12\x03\t23\n\x0b\n\x04\x05\0\x02\x05\x12\x03\n\x089\n\x0c\n\x05\
    \x05\0\x02\x05\x01\x12\x03\n\x084\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\
    \n78\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0b\x08=\n\x0c\n\x05\x05\0\x02\
    \x06\x01\x12\x03\x0b\x088\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0b;<\n\
    \x0b\n\x04\x05\0\x02\x07\x12\x03\x0c\x08*\n\x0c\n\x05\x05\0\x02\x07\x01\
    \x12\x03\x0c\x08%\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x0c()\n\x0b\n\
    \x04\x05\0\x02\x08\x12\x03\r\x08+\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\
    \r\x08&\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\r)*\n\x0b\n\x04\x05\0\x02\
    \t\x12\x03\x0e\x083\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0e\x08.\n\x0c\n\
    \x05\x05\0\x02\t\x02\x12\x03\x0e12\n\x0b\n\x04\x05\0\x02\n\x12\x03\x0f\
    \x084\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x0f\x08.\n\x0c\n\x05\x05\0\x02\
    \n\x02\x12\x03\x0f13\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x10\x084\n\x0c\n\
    \x05\x05\0\x02\x0b\x01\x12\x03\x10\x08.\n\x0c\n\x05\x05\0\x02\x0b\x02\
    \x12\x03\x1013\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x11\x084\n\x0c\n\x05\
    \x05\0\x02\x0c\x01\x12\x03\x11\x08.\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\
    \x03\x1113\n\x0b\n\x04\x05\0\x02\r\x12\x03\x12\x08'\n\x0c\n\x05\x05\0\
    \x02\r\x01\x12\x03\x12\x08!\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x12$&\n\
    \x0b\n\x04\x05\0\x02\x0e\x12\x03\x13\x089\n\x0c\n\x05\x05\0\x02\x0e\x01\
    \x12\x03\x13\x083\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x1368\n\x0b\n\
    \x04\x05\0\x02\x0f\x12\x03\x14\x087\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\
    \x03\x14\x081\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x1446\n\x0b\n\x04\
    \x05\0\x02\x10\x12\x03\x15\x08?\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\
    \x15\x089\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x15<>\n\x0b\n\x04\x05\0\
    \x02\x11\x12\x03\x16\x08-\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x16\x08'\
    \n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x16*,\n\x0b\n\x04\x05\0\x02\x12\
    \x12\x03\x17\x080\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x17\x08*\n\x0c\n\
    \x05\x05\0\x02\x12\x02\x12\x03\x17-/\n\x0b\n\x04\x05\0\x02\x13\x12\x03\
    \x18\x08+\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x18\x08%\n\x0c\n\x05\x05\
    \0\x02\x13\x02\x12\x03\x18(*\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x19\x082\
    \n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x19\x08,\n\x0c\n\x05\x05\0\x02\
    \x14\x02\x12\x03\x19/1\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1a\x08.\n\x0c\
    \n\x05\x05\0\x02\x15\x01\x12\x03\x1a\x08(\n\x0c\n\x05\x05\0\x02\x15\x02\
    \x12\x03\x1a+-\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1b\x089\n\x0c\n\x05\
    \x05\0\x02\x16\x01\x12\x03\x1b\x083\n\x0c\n\x05\x05\0\x02\x16\x02\x12\
    \x03\x1b68\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x1c\x087\n\x0c\n\x05\x05\0\
    \x02\x17\x01\x12\x03\x1c\x081\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1c4\
    6\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1d\x083\n\x0c\n\x05\x05\0\x02\x18\
    \x01\x12\x03\x1d\x08-\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\x1d02\n\x0b\
    \n\x04\x05\0\x02\x19\x12\x03\x1e\x087\n\x0c\n\x05\x05\0\x02\x19\x01\x12\
    \x03\x1e\x081\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03\x1e46\n\n\n\x02\x05\
    \x01\x12\x04!\0)\x01\n\n\n\x03\x05\x01\x01\x12\x03!\x05\x1d\n\x0b\n\x04\
    \x05\x01\x02\0\x12\x03\"\x087\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\"\
    \x081\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\"46\n\x0b\n\x04\x05\x01\x02\
    \x01\x12\x03#\x085\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03#\x08/\n\x0c\n\
    \x05\x05\x01\x02\x01\x02\x12\x03#24\n\x0b\n\x04\x05\x01\x02\x02\x12\x03$\
    \x085\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03$\x08/\n\x0c\n\x05\x05\x01\
    \x02\x02\x02\x12\x03$24\n\x0b\n\x04\x05\x01\x02\x03\x12\x03%\x080\n\x0c\
    \n\x05\x05\x01\x02\x03\x01\x12\x03%\x08*\n\x0c\n\x05\x05\x01\x02\x03\x02\
    \x12\x03%-/\n\x0b\n\x04\x05\x01\x02\x04\x12\x03&\x087\n\x0c\n\x05\x05\
    \x01\x02\x04\x01\x12\x03&\x081\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03&4\
    6\n\x0b\n\x04\x05\x01\x02\x05\x12\x03'\x083\n\x0c\n\x05\x05\x01\x02\x05\
    \x01\x12\x03'\x08-\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03'02\n\x0b\n\
    \x04\x05\x01\x02\x06\x12\x03(\x08,\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\
    \x03(\x08&\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03()+\n\n\n\x02\x04\0\
    \x12\x04+\0<\x01\n\n\n\x03\x04\0\x01\x12\x03+\x08(\n\x0c\n\x04\x04\0\x03\
    \0\x12\x04,\x080\t\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03,\x10\x1e\n\r\n\
    \x06\x04\0\x03\0\x02\0\x12\x03-\x104\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\
    \x12\x03-\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03-\x19\x20\n\
    \x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03-!/\n\x0e\n\x07\x04\0\x03\0\x02\
    \0\x03\x12\x03-23\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03.\x10*\n\x0e\n\
    \x07\x04\0\x03\0\x02\x01\x04\x12\x03.\x10\x18\n\x0e\n\x07\x04\0\x03\0\
    \x02\x01\x05\x12\x03.\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\
    \x03.\x20%\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03.()\n\r\n\x06\x04\
    \0\x03\0\x02\x02\x12\x03/\x10,\n\x0e\n\x07\x04\0\x03\0\x02\x02\x04\x12\
    \x03/\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x02\x05\x12\x03/\x19\x1f\n\x0e\
    \n\x07\x04\0\x03\0\x02\x02\x01\x12\x03/\x20'\n\x0e\n\x07\x04\0\x03\0\x02\
    \x02\x03\x12\x03/*+\n\x0b\n\x04\x04\0\x02\0\x12\x032\x08.\n\x0c\n\x05\
    \x04\0\x02\0\x04\x12\x032\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x032\
    \x11\x18\n\x0c\n\x05\x04\0\x02\0\x01\x12\x032\x19)\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x032,-\n\x0b\n\x04\x04\0\x02\x01\x12\x033\x08D\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x033\x11\x18\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x033\x19/\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03323\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x0334C\n\
    \r\n\x06\x04\0\x02\x01\x08\x02\x12\x0335B\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x034\x08<\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x034\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x02\x05\x12\x034\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x034\x18'\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x034*+\n\x0c\n\x05\x04\0\
    \x02\x02\x08\x12\x034,;\n\r\n\x06\x04\0\x02\x02\x08\x02\x12\x034-:\n\x0b\
    \n\x04\x04\0\x02\x03\x12\x035\x08,\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\
    5\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x035\x11\x18\n\x0c\n\x05\x04\
    \0\x02\x03\x01\x12\x035\x19'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x035*+\n\
    \x0b\n\x04\x04\0\x02\x04\x12\x036\x08)\n\x0c\n\x05\x04\0\x02\x04\x04\x12\
    \x036\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x036\x11\x18\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x036\x19$\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x036'\
    (\n\x0b\n\x04\x04\0\x02\x05\x12\x037\x08'\n\x0c\n\x05\x04\0\x02\x05\x04\
    \x12\x037\x08\x10\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x037\x11\x18\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x037\x19\"\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x037%&\n\x0b\n\x04\x04\0\x02\x06\x12\x038\x083\n\x0c\n\x05\x04\0\x02\
    \x06\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x038\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x06\x01\x12\x038\x18.\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03812\n\x0b\n\x04\x04\0\x02\x07\x12\x039\x08+\n\x0c\n\x05\x04\
    \0\x02\x07\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x039\
    \x11\x18\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x039\x19&\n\x0c\n\x05\x04\0\
    \x02\x07\x03\x12\x039)*\n\x0b\n\x04\x04\0\x02\x08\x12\x03:\x08:\n\x0c\n\
    \x05\x04\0\x02\x08\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\0\x02\x08\x05\
    \x12\x03:\x11\x17\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03:\x185\n\x0c\n\
    \x05\x04\0\x02\x08\x03\x12\x03:89\n\x0b\n\x04\x04\0\x02\t\x12\x03;\x08X\
    \n\x0c\n\x05\x04\0\x02\t\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\0\x02\t\
    \x06\x12\x03;\x11A\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03;BR\n\x0c\n\x05\
    \x04\0\x02\t\x03\x12\x03;UW\n\n\n\x02\x04\x01\x12\x04>\0H\x01\n\n\n\x03\
    \x04\x01\x01\x12\x03>\x08'\n\x0b\n\x04\x04\x01\x02\0\x12\x03?\x082\n\x0c\
    \n\x05\x04\x01\x02\0\x04\x12\x03?\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03?\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03?\x18-\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03?01\n\x0b\n\x04\x04\x01\x02\x01\x12\x03@\
    \x08-\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03@\x11\x18\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03@\x19(\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03@+,\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03A\x08.\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03A\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03A\x11\x18\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03A\x19)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03A,\
    -\n\x0b\n\x04\x04\x01\x02\x03\x12\x03B\x08.\n\x0c\n\x05\x04\x01\x02\x03\
    \x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03B\x11\x18\n\
    \x0c\n\x05\x04\x01\x02\x03\x01\x12\x03B\x19)\n\x0c\n\x05\x04\x01\x02\x03\
    \x03\x12\x03B,-\n\x0b\n\x04\x04\x01\x02\x04\x12\x03C\x086\n\x0c\n\x05\
    \x04\x01\x02\x04\x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\
    \x12\x03C\x11\x17\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03C\x181\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x03C45\n\x0b\n\x04\x04\x01\x02\x05\x12\x03D\
    \x08.\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x05\x05\x12\x03D\x11\x17\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\
    \x03D\x18)\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03D,-\n\x0b\n\x04\x04\
    \x01\x02\x06\x12\x03E\x08+\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03E\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03E\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\x06\x01\x12\x03E\x18&\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03E)\
    *\n\x0b\n\x04\x04\x01\x02\x07\x12\x03F\x08-\n\x0c\n\x05\x04\x01\x02\x07\
    \x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03F\x11\x17\n\
    \x0c\n\x05\x04\x01\x02\x07\x01\x12\x03F\x18(\n\x0c\n\x05\x04\x01\x02\x07\
    \x03\x12\x03F+,\n\x0b\n\x04\x04\x01\x02\x08\x12\x03G\x08+\n\x0c\n\x05\
    \x04\x01\x02\x08\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x01\x02\x08\x05\
    \x12\x03G\x11\x18\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03G\x19&\n\x0c\n\
    \x05\x04\x01\x02\x08\x03\x12\x03G)*\n\n\n\x02\x04\x02\x12\x04J\0P\x01\n\
    \n\n\x03\x04\x02\x01\x12\x03J\x08)\n\x0b\n\x04\x04\x02\x02\0\x12\x03K\
    \x08/\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03K\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03K\x19*\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03K-.\n\x0b\n\x04\x04\x02\x02\x01\
    \x12\x03L\x08*\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03L\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03L\x11\x18\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03L\x19%\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03L()\n\x0b\n\
    \x04\x04\x02\x02\x02\x12\x03M\x08'\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\
    \x03M\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03M\x11\x18\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03M\x19\"\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03M%&\n\x0b\n\x04\x04\x02\x02\x03\x12\x03N\x08)\n\x0c\n\x05\x04\
    \x02\x02\x03\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\
    \x03N\x11\x18\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03N\x19$\n\x0c\n\x05\
    \x04\x02\x02\x03\x03\x12\x03N'(\n\x0b\n\x04\x04\x02\x02\x04\x12\x03O\x08\
    &\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x04\x05\x12\x03O\x11\x18\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03O\
    \x19!\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03O$%\n\n\n\x02\x04\x03\x12\
    \x04R\0\\\x01\n\n\n\x03\x04\x03\x01\x12\x03R\x08)\n\x0c\n\x04\x04\x03\
    \x04\0\x12\x04S\x08V\t\n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03S\r\x15\n\r\
    \n\x06\x04\x03\x04\0\x02\0\x12\x03T\x10\x1c\n\x0e\n\x07\x04\x03\x04\0\
    \x02\0\x01\x12\x03T\x10\x17\n\x0e\n\x07\x04\x03\x04\0\x02\0\x02\x12\x03T\
    \x1a\x1b\n\r\n\x06\x04\x03\x04\0\x02\x01\x12\x03U\x10\x1f\n\x0e\n\x07\
    \x04\x03\x04\0\x02\x01\x01\x12\x03U\x10\x1a\n\x0e\n\x07\x04\x03\x04\0\
    \x02\x01\x02\x12\x03U\x1d\x1e\n\x0b\n\x04\x04\x03\x02\0\x12\x03X\x08^\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x06\x12\x03X\x11<\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03X=E\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03XHI\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03XJ]\n\
    \x0c\n\x05\x04\x03\x02\0\x07\x12\x03XU\\\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x03Y\x08$\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03Y\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x01\x05\x12\x03Y\x11\x16\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03Y\x17\x1f\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03Y\"#\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03Z\x08#\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\
    \x03Z\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03Z\x11\x18\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03Z\x19\x1e\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03Z!\"\n\x0b\n\x04\x04\x03\x02\x03\x12\x03[\x08!\n\x0c\n\x05\
    \x04\x03\x02\x03\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\
    \x12\x03[\x11\x15\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03[\x16\x1c\n\x0c\
    \n\x05\x04\x03\x02\x03\x03\x12\x03[\x1f\x20\n\n\n\x02\x04\x04\x12\x04^\0\
    a\x01\n\n\n\x03\x04\x04\x01\x12\x03^\x08/\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03_\x08\x20\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03_\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\0\x05\x12\x03_\x11\x16\n\x0c\n\x05\x04\x04\x02\0\x01\x12\
    \x03_\x17\x1b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03_\x1e\x1f\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03`\x08%\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03`\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03`\x11\x16\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03`\x17\x20\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x03`#$\n\n\n\x02\x04\x05\x12\x04c\0k\x01\n\n\n\x03\x04\x05\x01\x12\
    \x03c\x081\n\x0b\n\x04\x04\x05\x02\0\x12\x03d\x08\"\n\x0c\n\x05\x04\x05\
    \x02\0\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03d\x11\
    \x16\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03d\x17\x1d\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03d\x20!\n\x0b\n\x04\x04\x05\x02\x01\x12\x03e\x08,\n\x0c\
    \n\x05\x04\x05\x02\x01\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\
    \x05\x12\x03e\x11\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03e\x19'\n\
    \x0c\n\x05\x04\x05\x02\x01\x03\x12\x03e*+\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x03f\x08'\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03f\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x02\x05\x12\x03f\x11\x18\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03f\x19\"\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03f%&\n\x0b\n\
    \x04\x04\x05\x02\x03\x12\x03g\x082\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\
    \x03g\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03g\x11\x18\n\x0c\n\
    \x05\x04\x05\x02\x03\x01\x12\x03g\x19-\n\x0c\n\x05\x04\x05\x02\x03\x03\
    \x12\x03g01\n\x0b\n\x04\x04\x05\x02\x04\x12\x03h\x082\n\x0c\n\x05\x04\
    \x05\x02\x04\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\
    \x03h\x11\x18\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03h\x19-\n\x0c\n\x05\
    \x04\x05\x02\x04\x03\x12\x03h01\n\x0b\n\x04\x04\x05\x02\x05\x12\x03i\x08\
    3\n\x0c\n\x05\x04\x05\x02\x05\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x03i\x11\x17\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03i\
    \x18.\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03i12\n\x0b\n\x04\x04\x05\x02\
    \x06\x12\x03j\x08-\n\x0c\n\x05\x04\x05\x02\x06\x04\x12\x03j\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x06\x05\x12\x03j\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \x06\x01\x12\x03j\x18(\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\x03j+,\n\n\n\
    \x02\x04\x06\x12\x04m\0s\x01\n\n\n\x03\x04\x06\x01\x12\x03m\x085\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x03n\x08+\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03n\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03n\x11\x18\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03n\x19&\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03n)*\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x03o\x081\n\x0c\n\x05\x04\x06\x02\x01\x04\
    \x12\x03o\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03o\x11\x18\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03o\x19,\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03o/0\n\x0b\n\x04\x04\x06\x02\x02\x12\x03p\x083\n\x0c\n\x05\x04\
    \x06\x02\x02\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\
    \x03p\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03p\x18.\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03p12\n\x0b\n\x04\x04\x06\x02\x03\x12\x03q\x08\
    4\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\x03\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03q\
    \x18/\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03q23\n\x0b\n\x04\x04\x06\x02\
    \x04\x12\x03r\x08(\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03r\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x04\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \x04\x01\x12\x03r\x18#\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03r&'\n\n\n\
    \x02\x04\x07\x12\x04u\0|\x01\n\n\n\x03\x04\x07\x01\x12\x03u\x08/\n\x0b\n\
    \x04\x04\x07\x02\0\x12\x03v\x084\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03v\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03v\x18/\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03v23\n\
    \x0b\n\x04\x04\x07\x02\x01\x12\x03w\x08+\n\x0c\n\x05\x04\x07\x02\x01\x04\
    \x12\x03w\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03w\x11\x18\n\x0c\
    \n\x05\x04\x07\x02\x01\x01\x12\x03w\x19&\n\x0c\n\x05\x04\x07\x02\x01\x03\
    \x12\x03w)*\n\x0b\n\x04\x04\x07\x02\x02\x12\x03x\x08,\n\x0c\n\x05\x04\
    \x07\x02\x02\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\
    \x03x\x11\x18\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03x\x19'\n\x0c\n\x05\
    \x04\x07\x02\x02\x03\x12\x03x*+\n\x0b\n\x04\x04\x07\x02\x03\x12\x03y\x08\
    )\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x07\
    \x02\x03\x05\x12\x03y\x11\x18\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03y\
    \x19$\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03y'(\n\x0b\n\x04\x04\x07\x02\
    \x04\x12\x03z\x08'\n\x0c\n\x05\x04\x07\x02\x04\x04\x12\x03z\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x04\x05\x12\x03z\x11\x18\n\x0c\n\x05\x04\x07\x02\
    \x04\x01\x12\x03z\x19\"\n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03z%&\n\x0b\
    \n\x04\x04\x07\x02\x05\x12\x03{\x083\n\x0c\n\x05\x04\x07\x02\x05\x04\x12\
    \x03{\x08\x10\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03{\x11\x17\n\x0c\n\
    \x05\x04\x07\x02\x05\x01\x12\x03{\x18.\n\x0c\n\x05\x04\x07\x02\x05\x03\
    \x12\x03{12\n\x0b\n\x02\x04\x08\x12\x05~\0\x83\x01\x01\n\n\n\x03\x04\x08\
    \x01\x12\x03~\x08/\n\x0b\n\x04\x04\x08\x02\0\x12\x03\x7f\x08-\n\x0c\n\
    \x05\x04\x08\x02\0\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\
    \x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03\x7f\x18(\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03\x7f+,\n\x0c\n\x04\x04\x08\x02\x01\
    \x12\x04\x80\x01\x082\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\x80\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x80\x01\x11\x18\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\x80\x01\x19-\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\x80\x0101\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\x81\x01\x082\n\r\n\
    \x05\x04\x08\x02\x02\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\x81\x01\x11\x18\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \x81\x01\x19-\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x81\x0101\n\x0c\n\
    \x04\x04\x08\x02\x03\x12\x04\x82\x01\x08)\n\r\n\x05\x04\x08\x02\x03\x04\
    \x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\x82\x01\
    \x11\x18\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\x82\x01\x19#\n\r\n\x05\
    \x04\x08\x02\x03\x03\x12\x04\x82\x01&(\n\x0c\n\x02\x04\t\x12\x06\x85\x01\
    \0\x88\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x85\x01\x08#\n\x0c\n\x04\
    \x04\t\x02\0\x12\x04\x86\x01\x08%\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x86\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\x86\x01\x18\x20\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\x86\x01#$\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x87\x01\x08!\n\r\n\x05\
    \x04\t\x02\x01\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x87\x01\x18\
    \x1c\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x87\x01\x1f\x20\n\x0c\n\x02\x04\
    \n\x12\x06\x8a\x01\0\x97\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x8a\x01\
    \x08(\n\x0e\n\x04\x04\n\x03\0\x12\x06\x8b\x01\x08\x8e\x01\t\n\r\n\x05\
    \x04\n\x03\0\x01\x12\x04\x8b\x01\x10\x16\n\x0e\n\x06\x04\n\x03\0\x02\0\
    \x12\x04\x8c\x01\x10,\n\x0f\n\x07\x04\n\x03\0\x02\0\x04\x12\x04\x8c\x01\
    \x10\x18\n\x0f\n\x07\x04\n\x03\0\x02\0\x05\x12\x04\x8c\x01\x19\x1f\n\x0f\
    \n\x07\x04\n\x03\0\x02\0\x01\x12\x04\x8c\x01\x20'\n\x0f\n\x07\x04\n\x03\
    \0\x02\0\x03\x12\x04\x8c\x01*+\n\x0e\n\x06\x04\n\x03\0\x02\x01\x12\x04\
    \x8d\x01\x10,\n\x0f\n\x07\x04\n\x03\0\x02\x01\x04\x12\x04\x8d\x01\x10\
    \x18\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\x12\x04\x8d\x01\x19\x1f\n\x0f\n\
    \x07\x04\n\x03\0\x02\x01\x01\x12\x04\x8d\x01\x20'\n\x0f\n\x07\x04\n\x03\
    \0\x02\x01\x03\x12\x04\x8d\x01*+\n\x0e\n\x04\x04\n\x03\x01\x12\x06\x90\
    \x01\x08\x94\x01\t\n\r\n\x05\x04\n\x03\x01\x01\x12\x04\x90\x01\x10\x1a\n\
    \x0e\n\x06\x04\n\x03\x01\x02\0\x12\x04\x91\x01\x10)\n\x0f\n\x07\x04\n\
    \x03\x01\x02\0\x04\x12\x04\x91\x01\x10\x18\n\x0f\n\x07\x04\n\x03\x01\x02\
    \0\x05\x12\x04\x91\x01\x19\x1f\n\x0f\n\x07\x04\n\x03\x01\x02\0\x01\x12\
    \x04\x91\x01\x20$\n\x0f\n\x07\x04\n\x03\x01\x02\0\x03\x12\x04\x91\x01'(\
    \n\x0e\n\x06\x04\n\x03\x01\x02\x01\x12\x04\x92\x01\x10T\n\x0f\n\x07\x04\
    \n\x03\x01\x02\x01\x04\x12\x04\x92\x01\x10\x18\n\x0f\n\x07\x04\n\x03\x01\
    \x02\x01\x06\x12\x04\x92\x01\x19A\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x01\
    \x12\x04\x92\x01BO\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x03\x12\x04\x92\x01\
    RS\n\x0e\n\x06\x04\n\x03\x01\x02\x02\x12\x04\x93\x01\x10S\n\x0f\n\x07\
    \x04\n\x03\x01\x02\x02\x04\x12\x04\x93\x01\x10\x18\n\x0f\n\x07\x04\n\x03\
    \x01\x02\x02\x06\x12\x04\x93\x01\x19A\n\x0f\n\x07\x04\n\x03\x01\x02\x02\
    \x01\x12\x04\x93\x01BN\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x03\x12\x04\x93\
    \x01QR\n\x0c\n\x04\x04\n\x02\0\x12\x04\x96\x01\x08O\n\r\n\x05\x04\n\x02\
    \0\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x96\x01\
    \x11=\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x96\x01>J\n\r\n\x05\x04\n\x02\0\
    \x03\x12\x04\x96\x01MN\n\x0c\n\x02\x04\x0b\x12\x06\x99\x01\0\xa2\x01\x01\
    \n\x0b\n\x03\x04\x0b\x01\x12\x04\x99\x01\x08/\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\x9a\x01\x084\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x9a\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9a\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\0\x01\x12\x04\x9a\x01\x18/\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \x9a\x0123\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x9b\x01\x08.\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\
    \x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x9b\
    \x01\x18)\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9b\x01,-\n\x0c\n\x04\
    \x04\x0b\x02\x02\x12\x04\x9c\x01\x083\n\r\n\x05\x04\x0b\x02\x02\x04\x12\
    \x04\x9c\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x9c\x01\x11\
    \x17\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x9c\x01\x18.\n\r\n\x05\x04\
    \x0b\x02\x02\x03\x12\x04\x9c\x0112\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\
    \x9d\x01\x08-\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x9d\x01\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x03\x05\x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x03\x01\x12\x04\x9d\x01\x18(\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x9d\
    \x01+,\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x9e\x01\x08$\n\r\n\x05\x04\
    \x0b\x02\x04\x04\x12\x04\x9e\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\x05\
    \x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x9e\x01\
    \x18\x1f\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x9e\x01\"#\n\x0c\n\x04\
    \x04\x0b\x02\x05\x12\x04\x9f\x01\x080\n\r\n\x05\x04\x0b\x02\x05\x04\x12\
    \x04\x9f\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x9f\x01\x11\
    \x17\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x9f\x01\x18+\n\r\n\x05\x04\
    \x0b\x02\x05\x03\x12\x04\x9f\x01./\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\
    \xa0\x01\x087\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\xa0\x01\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x06\x05\x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x06\x01\x12\x04\xa0\x01\x182\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\xa0\
    \x0156\n\x0c\n\x04\x04\x0b\x02\x07\x12\x04\xa1\x01\x08-\n\r\n\x05\x04\
    \x0b\x02\x07\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x07\x05\
    \x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\xa1\x01\
    \x18(\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\xa1\x01+,\n\x0c\n\x02\x04\
    \x0c\x12\x06\xa4\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa4\
    \x01\x08*\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xa5\x01\x08)\n\r\n\x05\x04\
    \x0c\x02\0\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xa5\x01\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa5\x01\x18$\n\
    \r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa5\x01'(\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\xa6\x01\x08$\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xa6\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xa6\x01\x18\x1f\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xa6\x01\"#\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xa7\x01\x08)\n\r\
    \n\x05\x04\x0c\x02\x02\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x02\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xa7\x01\x18$\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa7\x01'(\n\x0c\n\
    \x04\x04\x0c\x02\x03\x12\x04\xa8\x01\x08$\n\r\n\x05\x04\x0c\x02\x03\x04\
    \x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xa8\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xa8\x01\x18\x1f\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\xa8\x01\"#\n\x0c\n\x04\x04\x0c\x02\x04\x12\
    \x04\xa9\x01\x083\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\xa9\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x04\x01\x12\x04\xa9\x01\x18.\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\
    \xa9\x0112\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xaa\x01\x081\n\r\n\x05\
    \x04\x0c\x02\x05\x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x05\
    \x05\x12\x04\xaa\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xaa\
    \x01\x18,\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xaa\x01/0\n\x0c\n\x04\
    \x04\x0c\x02\x06\x12\x04\xab\x01\x086\n\r\n\x05\x04\x0c\x02\x06\x04\x12\
    \x04\xab\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xab\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xab\x01\x181\n\r\n\x05\x04\
    \x0c\x02\x06\x03\x12\x04\xab\x0145\n\x0c\n\x04\x04\x0c\x02\x07\x12\x04\
    \xac\x01\x084\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xac\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x07\x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\x04\x0c\x02\
    \x07\x01\x12\x04\xac\x01\x18.\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xac\
    \x0113\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\xad\x01\x080\n\r\n\x05\x04\
    \x0c\x02\x08\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x08\x05\
    \x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\xad\x01\
    \x18*\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xad\x01-/\n\x0c\n\x04\x04\
    \x0c\x02\t\x12\x04\xae\x01\x083\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\xae\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xae\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x02\t\x01\x12\x04\xae\x01\x18-\n\r\n\x05\x04\x0c\x02\t\x03\
    \x12\x04\xae\x0102\n\x0c\n\x04\x04\x0c\x02\n\x12\x04\xaf\x01\x082\n\r\n\
    \x05\x04\x0c\x02\n\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x0c\x02\n\
    \x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x0c\x02\n\x01\x12\x04\xaf\x01\
    \x18,\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\xaf\x01/1\n\x0c\n\x04\x04\x0c\
    \x02\x0b\x12\x04\xb0\x01\x082\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\x04\xb0\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x02\x0b\x05\x12\x04\xb0\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x02\x0b\x01\x12\x04\xb0\x01\x18,\n\r\n\x05\x04\x0c\x02\x0b\
    \x03\x12\x04\xb0\x01/1\n\x0c\n\x04\x04\x0c\x02\x0c\x12\x04\xb1\x01\x082\
    \n\r\n\x05\x04\x0c\x02\x0c\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x0c\x05\x12\x04\xb1\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x0c\x01\x12\
    \x04\xb1\x01\x18,\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\xb1\x01/1\n\x0c\
    \n\x04\x04\x0c\x02\r\x12\x04\xb2\x01\x082\n\r\n\x05\x04\x0c\x02\r\x04\
    \x12\x04\xb2\x01\x08\x10\n\r\n\x05\x04\x0c\x02\r\x05\x12\x04\xb2\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02\r\x01\x12\x04\xb2\x01\x18,\n\r\n\x05\x04\x0c\
    \x02\r\x03\x12\x04\xb2\x01/1\n\x0c\n\x04\x04\x0c\x02\x0e\x12\x04\xb3\x01\
    \x082\n\r\n\x05\x04\x0c\x02\x0e\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x0e\x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x0e\
    \x01\x12\x04\xb3\x01\x18,\n\r\n\x05\x04\x0c\x02\x0e\x03\x12\x04\xb3\x01/\
    1\n\x0c\n\x04\x04\x0c\x02\x0f\x12\x04\xb4\x01\x082\n\r\n\x05\x04\x0c\x02\
    \x0f\x04\x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x0f\x05\x12\x04\
    \xb4\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x0f\x01\x12\x04\xb4\x01\x18,\n\r\
    \n\x05\x04\x0c\x02\x0f\x03\x12\x04\xb4\x01/1\n\x0c\n\x04\x04\x0c\x02\x10\
    \x12\x04\xb5\x01\x081\n\r\n\x05\x04\x0c\x02\x10\x04\x12\x04\xb5\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x10\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x10\x01\x12\x04\xb5\x01\x18+\n\r\n\x05\x04\x0c\x02\x10\x03\x12\
    \x04\xb5\x01.0\n\x0c\n\x04\x04\x0c\x02\x11\x12\x04\xb6\x01\x084\n\r\n\
    \x05\x04\x0c\x02\x11\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x11\x05\x12\x04\xb6\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x11\x01\x12\x04\
    \xb6\x01\x18.\n\r\n\x05\x04\x0c\x02\x11\x03\x12\x04\xb6\x0113\n\x0c\n\
    \x04\x04\x0c\x02\x12\x12\x04\xb7\x01\x08/\n\r\n\x05\x04\x0c\x02\x12\x04\
    \x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x12\x05\x12\x04\xb7\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x12\x01\x12\x04\xb7\x01\x18)\n\r\n\x05\
    \x04\x0c\x02\x12\x03\x12\x04\xb7\x01,.\n\x0c\n\x04\x04\x0c\x02\x13\x12\
    \x04\xb8\x01\x08/\n\r\n\x05\x04\x0c\x02\x13\x04\x12\x04\xb8\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x13\x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x13\x01\x12\x04\xb8\x01\x18)\n\r\n\x05\x04\x0c\x02\x13\x03\x12\x04\
    \xb8\x01,.\n\x0c\n\x04\x04\x0c\x02\x14\x12\x04\xb9\x01\x080\n\r\n\x05\
    \x04\x0c\x02\x14\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x14\
    \x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x14\x01\x12\x04\xb9\
    \x01\x18*\n\r\n\x05\x04\x0c\x02\x14\x03\x12\x04\xb9\x01-/\n\x0c\n\x04\
    \x04\x0c\x02\x15\x12\x04\xba\x01\x080\n\r\n\x05\x04\x0c\x02\x15\x04\x12\
    \x04\xba\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x15\x05\x12\x04\xba\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x15\x01\x12\x04\xba\x01\x18*\n\r\n\x05\x04\
    \x0c\x02\x15\x03\x12\x04\xba\x01-/\n\x0c\n\x04\x04\x0c\x02\x16\x12\x04\
    \xbb\x01\x08/\n\r\n\x05\x04\x0c\x02\x16\x04\x12\x04\xbb\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x16\x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x0c\x02\
    \x16\x01\x12\x04\xbb\x01\x18)\n\r\n\x05\x04\x0c\x02\x16\x03\x12\x04\xbb\
    \x01,.\n\x0c\n\x04\x04\x0c\x02\x17\x12\x04\xbc\x01\x08/\n\r\n\x05\x04\
    \x0c\x02\x17\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x17\x05\
    \x12\x04\xbc\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x17\x01\x12\x04\xbc\x01\
    \x18)\n\r\n\x05\x04\x0c\x02\x17\x03\x12\x04\xbc\x01,.\n\x0c\n\x04\x04\
    \x0c\x02\x18\x12\x04\xbd\x01\x08/\n\r\n\x05\x04\x0c\x02\x18\x04\x12\x04\
    \xbd\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x18\x05\x12\x04\xbd\x01\x11\x17\n\
    \r\n\x05\x04\x0c\x02\x18\x01\x12\x04\xbd\x01\x18)\n\r\n\x05\x04\x0c\x02\
    \x18\x03\x12\x04\xbd\x01,.\n\x0c\n\x04\x04\x0c\x02\x19\x12\x04\xbe\x01\
    \x080\n\r\n\x05\x04\x0c\x02\x19\x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x19\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x19\
    \x01\x12\x04\xbe\x01\x18*\n\r\n\x05\x04\x0c\x02\x19\x03\x12\x04\xbe\x01-\
    /\n\x0c\n\x04\x04\x0c\x02\x1a\x12\x04\xbf\x01\x080\n\r\n\x05\x04\x0c\x02\
    \x1a\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x1a\x05\x12\x04\
    \xbf\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x1a\x01\x12\x04\xbf\x01\x18*\n\r\
    \n\x05\x04\x0c\x02\x1a\x03\x12\x04\xbf\x01-/\n\x0c\n\x04\x04\x0c\x02\x1b\
    \x12\x04\xc0\x01\x080\n\r\n\x05\x04\x0c\x02\x1b\x04\x12\x04\xc0\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x1b\x05\x12\x04\xc0\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x1b\x01\x12\x04\xc0\x01\x18*\n\r\n\x05\x04\x0c\x02\x1b\x03\x12\
    \x04\xc0\x01-/\n\x0c\n\x04\x04\x0c\x02\x1c\x12\x04\xc1\x01\x080\n\r\n\
    \x05\x04\x0c\x02\x1c\x04\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x1c\x05\x12\x04\xc1\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x1c\x01\x12\x04\
    \xc1\x01\x18*\n\r\n\x05\x04\x0c\x02\x1c\x03\x12\x04\xc1\x01-/\n\x0c\n\
    \x04\x04\x0c\x02\x1d\x12\x04\xc2\x01\x080\n\r\n\x05\x04\x0c\x02\x1d\x04\
    \x12\x04\xc2\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x1d\x05\x12\x04\xc2\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x1d\x01\x12\x04\xc2\x01\x18*\n\r\n\x05\
    \x04\x0c\x02\x1d\x03\x12\x04\xc2\x01-/\n\x0c\n\x04\x04\x0c\x02\x1e\x12\
    \x04\xc3\x01\x080\n\r\n\x05\x04\x0c\x02\x1e\x04\x12\x04\xc3\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x1e\x05\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x1e\x01\x12\x04\xc3\x01\x18*\n\r\n\x05\x04\x0c\x02\x1e\x03\x12\x04\
    \xc3\x01-/\n\x0c\n\x04\x04\x0c\x02\x1f\x12\x04\xc4\x01\x08,\n\r\n\x05\
    \x04\x0c\x02\x1f\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x1f\
    \x05\x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x1f\x01\x12\x04\xc4\
    \x01\x18&\n\r\n\x05\x04\x0c\x02\x1f\x03\x12\x04\xc4\x01)+\n\x0c\n\x04\
    \x04\x0c\x02\x20\x12\x04\xc5\x01\x08-\n\r\n\x05\x04\x0c\x02\x20\x04\x12\
    \x04\xc5\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x20\x05\x12\x04\xc5\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x20\x01\x12\x04\xc5\x01\x18'\n\r\n\x05\x04\
    \x0c\x02\x20\x03\x12\x04\xc5\x01*,\n\x0c\n\x04\x04\x0c\x02!\x12\x04\xc6\
    \x01\x08-\n\r\n\x05\x04\x0c\x02!\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02!\x05\x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x0c\x02!\x01\x12\
    \x04\xc6\x01\x18'\n\r\n\x05\x04\x0c\x02!\x03\x12\x04\xc6\x01*,\n\x0c\n\
    \x04\x04\x0c\x02\"\x12\x04\xc7\x01\x08-\n\r\n\x05\x04\x0c\x02\"\x04\x12\
    \x04\xc7\x01\x08\x10\n\r\n\x05\x04\x0c\x02\"\x05\x12\x04\xc7\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02\"\x01\x12\x04\xc7\x01\x18'\n\r\n\x05\x04\x0c\x02\
    \"\x03\x12\x04\xc7\x01*,\n\x0c\n\x04\x04\x0c\x02#\x12\x04\xc8\x01\x08-\n\
    \r\n\x05\x04\x0c\x02#\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\x0c\x02#\
    \x05\x12\x04\xc8\x01\x11\x17\n\r\n\x05\x04\x0c\x02#\x01\x12\x04\xc8\x01\
    \x18'\n\r\n\x05\x04\x0c\x02#\x03\x12\x04\xc8\x01*,\n\x0c\n\x04\x04\x0c\
    \x02$\x12\x04\xc9\x01\x089\n\r\n\x05\x04\x0c\x02$\x04\x12\x04\xc9\x01\
    \x08\x10\n\r\n\x05\x04\x0c\x02$\x05\x12\x04\xc9\x01\x11\x17\n\r\n\x05\
    \x04\x0c\x02$\x01\x12\x04\xc9\x01\x183\n\r\n\x05\x04\x0c\x02$\x03\x12\
    \x04\xc9\x0168\n\x0c\n\x04\x04\x0c\x02%\x12\x04\xca\x01\x080\n\r\n\x05\
    \x04\x0c\x02%\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x0c\x02%\x05\x12\
    \x04\xca\x01\x11\x17\n\r\n\x05\x04\x0c\x02%\x01\x12\x04\xca\x01\x18*\n\r\
    \n\x05\x04\x0c\x02%\x03\x12\x04\xca\x01-/\n\x0c\n\x04\x04\x0c\x02&\x12\
    \x04\xcb\x01\x080\n\r\n\x05\x04\x0c\x02&\x04\x12\x04\xcb\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x02&\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\x0c\x02&\
    \x01\x12\x04\xcb\x01\x18*\n\r\n\x05\x04\x0c\x02&\x03\x12\x04\xcb\x01-/\n\
    \x0c\n\x04\x04\x0c\x02'\x12\x04\xcc\x01\x080\n\r\n\x05\x04\x0c\x02'\x04\
    \x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x0c\x02'\x05\x12\x04\xcc\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02'\x01\x12\x04\xcc\x01\x18*\n\r\n\x05\x04\x0c\
    \x02'\x03\x12\x04\xcc\x01-/\n\x0c\n\x04\x04\x0c\x02(\x12\x04\xcd\x01\x08\
    1\n\r\n\x05\x04\x0c\x02(\x04\x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x02(\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x0c\x02(\x01\x12\x04\xcd\
    \x01\x18+\n\r\n\x05\x04\x0c\x02(\x03\x12\x04\xcd\x01.0\n\x0c\n\x04\x04\
    \x0c\x02)\x12\x04\xce\x01\x081\n\r\n\x05\x04\x0c\x02)\x04\x12\x04\xce\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x02)\x05\x12\x04\xce\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x02)\x01\x12\x04\xce\x01\x18+\n\r\n\x05\x04\x0c\x02)\x03\
    \x12\x04\xce\x01.0\n\x0c\n\x04\x04\x0c\x02*\x12\x04\xcf\x01\x08)\n\r\n\
    \x05\x04\x0c\x02*\x04\x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\x0c\x02*\x05\
    \x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x0c\x02*\x01\x12\x04\xcf\x01\x18#\
    \n\r\n\x05\x04\x0c\x02*\x03\x12\x04\xcf\x01&(\n\x0c\n\x04\x04\x0c\x02+\
    \x12\x04\xd0\x01\x082\n\r\n\x05\x04\x0c\x02+\x04\x12\x04\xd0\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02+\x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02+\x01\x12\x04\xd0\x01\x18,\n\r\n\x05\x04\x0c\x02+\x03\x12\x04\xd0\
    \x01/1\n\x0c\n\x04\x04\x0c\x02,\x12\x04\xd1\x01\x082\n\r\n\x05\x04\x0c\
    \x02,\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x0c\x02,\x05\x12\x04\xd1\
    \x01\x11\x17\n\r\n\x05\x04\x0c\x02,\x01\x12\x04\xd1\x01\x18,\n\r\n\x05\
    \x04\x0c\x02,\x03\x12\x04\xd1\x01/1\n\x0c\n\x04\x04\x0c\x02-\x12\x04\xd2\
    \x01\x082\n\r\n\x05\x04\x0c\x02-\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02-\x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\x04\x0c\x02-\x01\x12\
    \x04\xd2\x01\x18,\n\r\n\x05\x04\x0c\x02-\x03\x12\x04\xd2\x01/1\n\x0c\n\
    \x04\x04\x0c\x02.\x12\x04\xd3\x01\x083\n\r\n\x05\x04\x0c\x02.\x04\x12\
    \x04\xd3\x01\x08\x10\n\r\n\x05\x04\x0c\x02.\x05\x12\x04\xd3\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02.\x01\x12\x04\xd3\x01\x18-\n\r\n\x05\x04\x0c\x02.\
    \x03\x12\x04\xd3\x0102\n\x0c\n\x04\x04\x0c\x02/\x12\x04\xd4\x01\x083\n\r\
    \n\x05\x04\x0c\x02/\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x0c\x02/\
    \x05\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x0c\x02/\x01\x12\x04\xd4\x01\
    \x18-\n\r\n\x05\x04\x0c\x02/\x03\x12\x04\xd4\x0102\n\x0c\n\x04\x04\x0c\
    \x020\x12\x04\xd5\x01\x083\n\r\n\x05\x04\x0c\x020\x04\x12\x04\xd5\x01\
    \x08\x10\n\r\n\x05\x04\x0c\x020\x05\x12\x04\xd5\x01\x11\x17\n\r\n\x05\
    \x04\x0c\x020\x01\x12\x04\xd5\x01\x18-\n\r\n\x05\x04\x0c\x020\x03\x12\
    \x04\xd5\x0102\n\x0c\n\x04\x04\x0c\x021\x12\x04\xd6\x01\x084\n\r\n\x05\
    \x04\x0c\x021\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\x0c\x021\x05\x12\
    \x04\xd6\x01\x11\x17\n\r\n\x05\x04\x0c\x021\x01\x12\x04\xd6\x01\x18.\n\r\
    \n\x05\x04\x0c\x021\x03\x12\x04\xd6\x0113\n\x0c\n\x04\x04\x0c\x022\x12\
    \x04\xd7\x01\x083\n\r\n\x05\x04\x0c\x022\x04\x12\x04\xd7\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x022\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x0c\x022\
    \x01\x12\x04\xd7\x01\x18-\n\r\n\x05\x04\x0c\x022\x03\x12\x04\xd7\x0102\n\
    \x0c\n\x04\x04\x0c\x023\x12\x04\xd8\x01\x08/\n\r\n\x05\x04\x0c\x023\x04\
    \x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x0c\x023\x05\x12\x04\xd8\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x023\x01\x12\x04\xd8\x01\x18)\n\r\n\x05\x04\x0c\
    \x023\x03\x12\x04\xd8\x01,.\n\x0c\n\x04\x04\x0c\x024\x12\x04\xd9\x01\x08\
    0\n\r\n\x05\x04\x0c\x024\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x024\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x0c\x024\x01\x12\x04\xd9\
    \x01\x18*\n\r\n\x05\x04\x0c\x024\x03\x12\x04\xd9\x01-/\n\x0c\n\x04\x04\
    \x0c\x025\x12\x04\xda\x01\x080\n\r\n\x05\x04\x0c\x025\x04\x12\x04\xda\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x025\x05\x12\x04\xda\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x025\x01\x12\x04\xda\x01\x18*\n\r\n\x05\x04\x0c\x025\x03\
    \x12\x04\xda\x01-/\n\x0c\n\x04\x04\x0c\x026\x12\x04\xdb\x01\x080\n\r\n\
    \x05\x04\x0c\x026\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x0c\x026\x05\
    \x12\x04\xdb\x01\x11\x17\n\r\n\x05\x04\x0c\x026\x01\x12\x04\xdb\x01\x18*\
    \n\r\n\x05\x04\x0c\x026\x03\x12\x04\xdb\x01-/\n\x0c\n\x04\x04\x0c\x027\
    \x12\x04\xdc\x01\x080\n\r\n\x05\x04\x0c\x027\x04\x12\x04\xdc\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x027\x05\x12\x04\xdc\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x027\x01\x12\x04\xdc\x01\x18*\n\r\n\x05\x04\x0c\x027\x03\x12\x04\xdc\
    \x01-/\n\x0c\n\x04\x04\x0c\x028\x12\x04\xdd\x01\x08)\n\r\n\x05\x04\x0c\
    \x028\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\x0c\x028\x05\x12\x04\xdd\
    \x01\x11\x17\n\r\n\x05\x04\x0c\x028\x01\x12\x04\xdd\x01\x18#\n\r\n\x05\
    \x04\x0c\x028\x03\x12\x04\xdd\x01&(\n\x0c\n\x04\x04\x0c\x029\x12\x04\xde\
    \x01\x082\n\r\n\x05\x04\x0c\x029\x04\x12\x04\xde\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x029\x05\x12\x04\xde\x01\x11\x17\n\r\n\x05\x04\x0c\x029\x01\x12\
    \x04\xde\x01\x18,\n\r\n\x05\x04\x0c\x029\x03\x12\x04\xde\x01/1\n\x0c\n\
    \x04\x04\x0c\x02:\x12\x04\xdf\x01\x082\n\r\n\x05\x04\x0c\x02:\x04\x12\
    \x04\xdf\x01\x08\x10\n\r\n\x05\x04\x0c\x02:\x05\x12\x04\xdf\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02:\x01\x12\x04\xdf\x01\x18,\n\r\n\x05\x04\x0c\x02:\
    \x03\x12\x04\xdf\x01/1\n\x0c\n\x04\x04\x0c\x02;\x12\x04\xe0\x01\x082\n\r\
    \n\x05\x04\x0c\x02;\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x0c\x02;\
    \x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x0c\x02;\x01\x12\x04\xe0\x01\
    \x18,\n\r\n\x05\x04\x0c\x02;\x03\x12\x04\xe0\x01/1\n\x0c\n\x04\x04\x0c\
    \x02<\x12\x04\xe1\x01\x083\n\r\n\x05\x04\x0c\x02<\x04\x12\x04\xe1\x01\
    \x08\x10\n\r\n\x05\x04\x0c\x02<\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\
    \x04\x0c\x02<\x01\x12\x04\xe1\x01\x18-\n\r\n\x05\x04\x0c\x02<\x03\x12\
    \x04\xe1\x0102\n\x0c\n\x04\x04\x0c\x02=\x12\x04\xe2\x01\x083\n\r\n\x05\
    \x04\x0c\x02=\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x0c\x02=\x05\x12\
    \x04\xe2\x01\x11\x17\n\r\n\x05\x04\x0c\x02=\x01\x12\x04\xe2\x01\x18-\n\r\
    \n\x05\x04\x0c\x02=\x03\x12\x04\xe2\x0102\n\x0c\n\x04\x04\x0c\x02>\x12\
    \x04\xe3\x01\x083\n\r\n\x05\x04\x0c\x02>\x04\x12\x04\xe3\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x02>\x05\x12\x04\xe3\x01\x11\x17\n\r\n\x05\x04\x0c\x02>\
    \x01\x12\x04\xe3\x01\x18-\n\r\n\x05\x04\x0c\x02>\x03\x12\x04\xe3\x0102\n\
    \x0c\n\x04\x04\x0c\x02?\x12\x04\xe4\x01\x084\n\r\n\x05\x04\x0c\x02?\x04\
    \x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\x0c\x02?\x05\x12\x04\xe4\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02?\x01\x12\x04\xe4\x01\x18.\n\r\n\x05\x04\x0c\
    \x02?\x03\x12\x04\xe4\x0113\n\x0c\n\x04\x04\x0c\x02@\x12\x04\xe5\x01\x08\
    3\n\r\n\x05\x04\x0c\x02@\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x02@\x05\x12\x04\xe5\x01\x11\x17\n\r\n\x05\x04\x0c\x02@\x01\x12\x04\xe5\
    \x01\x18-\n\r\n\x05\x04\x0c\x02@\x03\x12\x04\xe5\x0102\n\x0c\n\x04\x04\
    \x0c\x02A\x12\x04\xe6\x01\x08/\n\r\n\x05\x04\x0c\x02A\x04\x12\x04\xe6\
    \x01\x08\x10\n\r\n\x05\x04\x0c\x02A\x05\x12\x04\xe6\x01\x11\x17\n\r\n\
    \x05\x04\x0c\x02A\x01\x12\x04\xe6\x01\x18)\n\r\n\x05\x04\x0c\x02A\x03\
    \x12\x04\xe6\x01,.\n\x0c\n\x04\x04\x0c\x02B\x12\x04\xe7\x01\x080\n\r\n\
    \x05\x04\x0c\x02B\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x0c\x02B\x05\
    \x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\x0c\x02B\x01\x12\x04\xe7\x01\x18*\
    \n\r\n\x05\x04\x0c\x02B\x03\x12\x04\xe7\x01-/\n\x0c\n\x04\x04\x0c\x02C\
    \x12\x04\xe8\x01\x080\n\r\n\x05\x04\x0c\x02C\x04\x12\x04\xe8\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02C\x05\x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02C\x01\x12\x04\xe8\x01\x18*\n\r\n\x05\x04\x0c\x02C\x03\x12\x04\xe8\
    \x01-/\n\x0c\n\x04\x04\x0c\x02D\x12\x04\xe9\x01\x080\n\r\n\x05\x04\x0c\
    \x02D\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x0c\x02D\x05\x12\x04\xe9\
    \x01\x11\x17\n\r\n\x05\x04\x0c\x02D\x01\x12\x04\xe9\x01\x18*\n\r\n\x05\
    \x04\x0c\x02D\x03\x12\x04\xe9\x01-/\n\x0c\n\x04\x04\x0c\x02E\x12\x04\xea\
    \x01\x080\n\r\n\x05\x04\x0c\x02E\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02E\x05\x12\x04\xea\x01\x11\x17\n\r\n\x05\x04\x0c\x02E\x01\x12\
    \x04\xea\x01\x18*\n\r\n\x05\x04\x0c\x02E\x03\x12\x04\xea\x01-/\n\x0c\n\
    \x02\x04\r\x12\x06\xed\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\
    \xed\x01\x08*\n\x0c\n\x04\x04\r\x02\0\x12\x04\xee\x01\x08L\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\
    \xee\x01\x119\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xee\x01:G\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\xee\x01JK\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xef\x01\
    \x08B\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\
    \r\x02\x01\x06\x12\x04\xef\x01\x114\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xef\x015=\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xef\x01@A\n\x0c\n\x02\x04\
    \x0e\x12\x06\xf2\x01\0\x82\x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xf2\
    \x01\x086\n\x0e\n\x04\x04\x0e\x04\0\x12\x06\xf3\x01\x08\xf7\x01\t\n\r\n\
    \x05\x04\x0e\x04\0\x01\x12\x04\xf3\x01\r\x12\n\x0e\n\x06\x04\x0e\x04\0\
    \x02\0\x12\x04\xf4\x01\x10&\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\
    \xf4\x01\x10!\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xf4\x01$%\n\
    \x0e\n\x06\x04\x0e\x04\0\x02\x01\x12\x04\xf5\x01\x10$\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x01\x01\x12\x04\xf5\x01\x10\x1f\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x01\x02\x12\x04\xf5\x01\"#\n\x0e\n\x06\x04\x0e\x04\0\x02\x02\x12\
    \x04\xf6\x01\x10*\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\x04\xf6\x01\
    \x10%\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\xf6\x01()\n\x0c\n\
    \x04\x04\x0e\x02\0\x12\x04\xf9\x01\x08=\n\r\n\x05\x04\x0e\x02\0\x04\x12\
    \x04\xf9\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xf9\x01\x114\n\
    \r\n\x05\x04\x0e\x02\0\x01\x12\x04\xf9\x0158\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\xf9\x01;<\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xfa\x01\x08=\n\r\
    \n\x05\x04\x0e\x02\x01\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xfa\x01\x114\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xfa\
    \x0158\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xfa\x01;<\n\x0c\n\x04\x04\
    \x0e\x02\x02\x12\x04\xfb\x01\x085\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\
    \xfb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xfb\x01\x11\x18\n\
    \r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xfb\x01\x190\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xfb\x0134\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xfc\x01\
    \x08'\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x03\x05\x12\x04\xfc\x01\x11\x18\n\r\n\x05\x04\x0e\x02\x03\
    \x01\x12\x04\xfc\x01\x19\"\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xfc\x01\
    %&\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xfd\x01\x08%\n\r\n\x05\x04\x0e\
    \x02\x04\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x04\x05\x12\
    \x04\xfd\x01\x11\x18\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xfd\x01\x19\
    \x20\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xfd\x01#$\n\x0c\n\x04\x04\x0e\
    \x02\x05\x12\x04\xfe\x01\x08\"\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xfe\
    \x01\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xfe\x01\x11\x17\n\r\n\
    \x05\x04\x0e\x02\x05\x01\x12\x04\xfe\x01\x18\x1d\n\r\n\x05\x04\x0e\x02\
    \x05\x03\x12\x04\xfe\x01\x20!\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xff\
    \x01\x082\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xff\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x06\x05\x12\x04\xff\x01\x11\x18\n\r\n\x05\x04\x0e\x02\
    \x06\x01\x12\x04\xff\x01\x19-\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xff\
    \x0101\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\x80\x02\x08(\n\r\n\x05\x04\
    \x0e\x02\x07\x04\x12\x04\x80\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x05\
    \x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x80\x02\
    \x18#\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\x80\x02&'\n\x0c\n\x04\x04\
    \x0e\x02\x08\x12\x04\x81\x02\x08)\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\
    \x81\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\x81\x02\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x81\x02\x18#\n\r\n\x05\x04\x0e\x02\
    \x08\x03\x12\x04\x81\x02&(\n\x0c\n\x02\x04\x0f\x12\x06\x84\x02\0\x9a\x02\
    \x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x84\x02\x086\n\x0e\n\x04\x04\x0f\
    \x04\0\x12\x06\x85\x02\x08\x89\x02\t\n\r\n\x05\x04\x0f\x04\0\x01\x12\x04\
    \x85\x02\r\x12\n\x0e\n\x06\x04\x0f\x04\0\x02\0\x12\x04\x86\x02\x10&\n\
    \x0f\n\x07\x04\x0f\x04\0\x02\0\x01\x12\x04\x86\x02\x10!\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\0\x02\x12\x04\x86\x02$%\n\x0e\n\x06\x04\x0f\x04\0\x02\x01\
    \x12\x04\x87\x02\x10$\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x01\x12\x04\x87\
    \x02\x10\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x02\x12\x04\x87\x02\"#\n\
    \x0e\n\x06\x04\x0f\x04\0\x02\x02\x12\x04\x88\x02\x10*\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x02\x01\x12\x04\x88\x02\x10%\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x02\x02\x12\x04\x88\x02()\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x8b\x02\
    \x08=\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\
    \x0f\x02\0\x06\x12\x04\x8b\x02\x114\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \x8b\x0258\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x8b\x02;<\n\x0c\n\x04\x04\
    \x0f\x02\x01\x12\x04\x8c\x02\x08=\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\
    \x8c\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\x8c\x02\x114\n\r\
    \n\x05\x04\x0f\x02\x01\x01\x12\x04\x8c\x0258\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\x8c\x02;<\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x8d\x02\x08A\
    \n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\x8d\x02\x11\x18\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\x8d\x02\x19<\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x8d\x02?@\n\x0c\
    \n\x04\x04\x0f\x02\x03\x12\x04\x8e\x02\x08A\n\r\n\x05\x04\x0f\x02\x03\
    \x04\x12\x04\x8e\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x8e\
    \x02\x11\x18\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x8e\x02\x19<\n\r\n\
    \x05\x04\x0f\x02\x03\x03\x12\x04\x8e\x02?@\n\x0c\n\x04\x04\x0f\x02\x04\
    \x12\x04\x8f\x02\x086\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\x8f\x02\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\x04\
    \x0f\x02\x04\x01\x12\x04\x8f\x02\x181\n\r\n\x05\x04\x0f\x02\x04\x03\x12\
    \x04\x8f\x0245\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\x90\x02\x083\n\r\n\
    \x05\x04\x0f\x02\x05\x04\x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\x0f\x02\
    \x05\x05\x12\x04\x90\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\
    \x90\x02\x18.\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x90\x0212\n\x0c\n\
    \x04\x04\x0f\x02\x06\x12\x04\x91\x02\x081\n\r\n\x05\x04\x0f\x02\x06\x04\
    \x12\x04\x91\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\x91\x02\
    \x11\x18\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x91\x02\x19+\n\r\n\x05\
    \x04\x0f\x02\x06\x03\x12\x04\x91\x02.0\n\x0c\n\x04\x04\x0f\x02\x07\x12\
    \x04\x92\x02\x082\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\x92\x02\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x07\x05\x12\x04\x92\x02\x11\x17\n\r\n\x05\x04\x0f\
    \x02\x07\x01\x12\x04\x92\x02\x18,\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\
    \x92\x02/1\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\x93\x02\x08;\n\r\n\x05\
    \x04\x0f\x02\x08\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x08\
    \x05\x12\x04\x93\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\x93\
    \x02\x185\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x93\x028:\n\x0c\n\x04\
    \x04\x0f\x02\t\x12\x04\x94\x02\x08(\n\r\n\x05\x04\x0f\x02\t\x04\x12\x04\
    \x94\x02\x08\x10\n\r\n\x05\x04\x0f\x02\t\x05\x12\x04\x94\x02\x11\x18\n\r\
    \n\x05\x04\x0f\x02\t\x01\x12\x04\x94\x02\x19\"\n\r\n\x05\x04\x0f\x02\t\
    \x03\x12\x04\x94\x02%'\n\x0c\n\x04\x04\x0f\x02\n\x12\x04\x95\x02\x08&\n\
    \r\n\x05\x04\x0f\x02\n\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x0f\x02\
    \n\x05\x12\x04\x95\x02\x11\x18\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\x95\
    \x02\x19\x20\n\r\n\x05\x04\x0f\x02\n\x03\x12\x04\x95\x02#%\n\x0c\n\x04\
    \x04\x0f\x02\x0b\x12\x04\x96\x02\x08#\n\r\n\x05\x04\x0f\x02\x0b\x04\x12\
    \x04\x96\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x0b\x05\x12\x04\x96\x02\x11\
    \x17\n\r\n\x05\x04\x0f\x02\x0b\x01\x12\x04\x96\x02\x18\x1d\n\r\n\x05\x04\
    \x0f\x02\x0b\x03\x12\x04\x96\x02\x20\"\n\x0c\n\x04\x04\x0f\x02\x0c\x12\
    \x04\x97\x02\x082\n\r\n\x05\x04\x0f\x02\x0c\x04\x12\x04\x97\x02\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x0c\x05\x12\x04\x97\x02\x11\x18\n\r\n\x05\x04\x0f\
    \x02\x0c\x01\x12\x04\x97\x02\x19-\n\r\n\x05\x04\x0f\x02\x0c\x03\x12\x04\
    \x97\x0201\n\x0c\n\x04\x04\x0f\x02\r\x12\x04\x98\x02\x08(\n\r\n\x05\x04\
    \x0f\x02\r\x04\x12\x04\x98\x02\x08\x10\n\r\n\x05\x04\x0f\x02\r\x05\x12\
    \x04\x98\x02\x11\x17\n\r\n\x05\x04\x0f\x02\r\x01\x12\x04\x98\x02\x18#\n\
    \r\n\x05\x04\x0f\x02\r\x03\x12\x04\x98\x02&'\n\x0c\n\x04\x04\x0f\x02\x0e\
    \x12\x04\x99\x02\x08(\n\r\n\x05\x04\x0f\x02\x0e\x04\x12\x04\x99\x02\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x0e\x05\x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\
    \x0f\x02\x0e\x01\x12\x04\x99\x02\x18#\n\r\n\x05\x04\x0f\x02\x0e\x03\x12\
    \x04\x99\x02&'\n\x0c\n\x02\x04\x10\x12\x06\x9c\x02\0\xb0\x02\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\x9c\x02\x086\n\x0e\n\x04\x04\x10\x04\0\x12\x06\
    \x9d\x02\x08\xa1\x02\t\n\r\n\x05\x04\x10\x04\0\x01\x12\x04\x9d\x02\r\x12\
    \n\x0e\n\x06\x04\x10\x04\0\x02\0\x12\x04\x9e\x02\x10&\n\x0f\n\x07\x04\
    \x10\x04\0\x02\0\x01\x12\x04\x9e\x02\x10!\n\x0f\n\x07\x04\x10\x04\0\x02\
    \0\x02\x12\x04\x9e\x02$%\n\x0e\n\x06\x04\x10\x04\0\x02\x01\x12\x04\x9f\
    \x02\x10$\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\x9f\x02\x10\x1f\
    \n\x0f\n\x07\x04\x10\x04\0\x02\x01\x02\x12\x04\x9f\x02\"#\n\x0e\n\x06\
    \x04\x10\x04\0\x02\x02\x12\x04\xa0\x02\x10*\n\x0f\n\x07\x04\x10\x04\0\
    \x02\x02\x01\x12\x04\xa0\x02\x10%\n\x0f\n\x07\x04\x10\x04\0\x02\x02\x02\
    \x12\x04\xa0\x02()\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa3\x02\x08=\n\r\n\
    \x05\x04\x10\x02\0\x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04\x10\x02\0\
    \x06\x12\x04\xa3\x02\x114\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa3\x0258\
    \n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa3\x02;<\n\x0c\n\x04\x04\x10\x02\
    \x01\x12\x04\xa4\x02\x08=\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xa4\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xa4\x02\x114\n\r\n\x05\
    \x04\x10\x02\x01\x01\x12\x04\xa4\x0258\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\xa4\x02;<\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xa5\x02\x085\n\r\n\
    \x05\x04\x10\x02\x02\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\xa5\x02\x11\x18\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\
    \xa5\x02\x190\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xa5\x0234\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\xa6\x02\x085\n\r\n\x05\x04\x10\x02\x03\x04\
    \x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xa6\x02\
    \x11\x18\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xa6\x02\x190\n\r\n\x05\
    \x04\x10\x02\x03\x03\x12\x04\xa6\x0234\n\x0c\n\x04\x04\x10\x02\x04\x12\
    \x04\xa7\x02\x08(\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xa7\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xa7\x02\x11\x18\n\r\n\x05\x04\x10\
    \x02\x04\x01\x12\x04\xa7\x02\x19\"\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\
    \xa7\x02%'\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xa8\x02\x08&\n\r\n\x05\
    \x04\x10\x02\x05\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x10\x02\x05\
    \x05\x12\x04\xa8\x02\x11\x18\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xa8\
    \x02\x19\x20\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xa8\x02#%\n\x0c\n\x04\
    \x04\x10\x02\x06\x12\x04\xa9\x02\x08#\n\r\n\x05\x04\x10\x02\x06\x04\x12\
    \x04\xa9\x02\x08\x10\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xa9\x02\x11\
    \x17\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xa9\x02\x18\x1d\n\r\n\x05\x04\
    \x10\x02\x06\x03\x12\x04\xa9\x02\x20\"\n\x0c\n\x04\x04\x10\x02\x07\x12\
    \x04\xaa\x02\x08(\n\r\n\x05\x04\x10\x02\x07\x04\x12\x04\xaa\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\xaa\x02\x11\x17\n\r\n\x05\x04\x10\
    \x02\x07\x01\x12\x04\xaa\x02\x18#\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\
    \xaa\x02&'\n\x0c\n\x04\x04\x10\x02\x08\x12\x04\xab\x02\x08(\n\r\n\x05\
    \x04\x10\x02\x08\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04\x10\x02\x08\
    \x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xab\
    \x02\x18#\n\r\n\x05\x04\x10\x02\x08\x03\x12\x04\xab\x02&'\n\x0c\n\x04\
    \x04\x10\x02\t\x12\x04\xac\x02\x08-\n\r\n\x05\x04\x10\x02\t\x04\x12\x04\
    \xac\x02\x08\x10\n\r\n\x05\x04\x10\x02\t\x05\x12\x04\xac\x02\x11\x18\n\r\
    \n\x05\x04\x10\x02\t\x01\x12\x04\xac\x02\x19(\n\r\n\x05\x04\x10\x02\t\
    \x03\x12\x04\xac\x02+,\n\x0c\n\x04\x04\x10\x02\n\x12\x04\xad\x02\x08-\n\
    \r\n\x05\x04\x10\x02\n\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \n\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\xad\
    \x02\x18(\n\r\n\x05\x04\x10\x02\n\x03\x12\x04\xad\x02+,\n\x0c\n\x04\x04\
    \x10\x02\x0b\x12\x04\xae\x02\x082\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\
    \xae\x02\x08\x10\n\r\n\x05\x04\x10\x02\x0b\x05\x12\x04\xae\x02\x11\x18\n\
    \r\n\x05\x04\x10\x02\x0b\x01\x12\x04\xae\x02\x19-\n\r\n\x05\x04\x10\x02\
    \x0b\x03\x12\x04\xae\x0201\n\x0c\n\x04\x04\x10\x02\x0c\x12\x04\xaf\x02\
    \x083\n\r\n\x05\x04\x10\x02\x0c\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\
    \x04\x10\x02\x0c\x05\x12\x04\xaf\x02\x11\x18\n\r\n\x05\x04\x10\x02\x0c\
    \x01\x12\x04\xaf\x02\x19-\n\r\n\x05\x04\x10\x02\x0c\x03\x12\x04\xaf\x020\
    2\n\x0c\n\x02\x04\x11\x12\x06\xb2\x02\0\xc4\x02\x01\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xb2\x02\x086\n\x0e\n\x04\x04\x11\x04\0\x12\x06\xb3\x02\x08\
    \xb7\x02\t\n\r\n\x05\x04\x11\x04\0\x01\x12\x04\xb3\x02\r\x12\n\x0e\n\x06\
    \x04\x11\x04\0\x02\0\x12\x04\xb4\x02\x10&\n\x0f\n\x07\x04\x11\x04\0\x02\
    \0\x01\x12\x04\xb4\x02\x10!\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\
    \xb4\x02$%\n\x0e\n\x06\x04\x11\x04\0\x02\x01\x12\x04\xb5\x02\x10$\n\x0f\
    \n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xb5\x02\x10\x1f\n\x0f\n\x07\x04\
    \x11\x04\0\x02\x01\x02\x12\x04\xb5\x02\"#\n\x0e\n\x06\x04\x11\x04\0\x02\
    \x02\x12\x04\xb6\x02\x10*\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\
    \xb6\x02\x10%\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\xb6\x02()\n\
    \x0c\n\x04\x04\x11\x02\0\x12\x04\xb9\x02\x08=\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb9\x02\
    \x114\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb9\x0258\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\xb9\x02;<\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xba\x02\
    \x08=\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xba\x02\x08\x10\n\r\n\x05\
    \x04\x11\x02\x01\x06\x12\x04\xba\x02\x114\n\r\n\x05\x04\x11\x02\x01\x01\
    \x12\x04\xba\x0258\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xba\x02;<\n\x0c\
    \n\x04\x04\x11\x02\x02\x12\x04\xbb\x02\x08'\n\r\n\x05\x04\x11\x02\x02\
    \x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xbb\
    \x02\x11\x18\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xbb\x02\x19\"\n\r\n\
    \x05\x04\x11\x02\x02\x03\x12\x04\xbb\x02%&\n\x0c\n\x04\x04\x11\x02\x03\
    \x12\x04\xbc\x02\x08%\n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\xbc\x02\x08\
    \x10\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xbc\x02\x11\x18\n\r\n\x05\x04\
    \x11\x02\x03\x01\x12\x04\xbc\x02\x19\x20\n\r\n\x05\x04\x11\x02\x03\x03\
    \x12\x04\xbc\x02#$\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xbd\x02\x08#\n\r\
    \n\x05\x04\x11\x02\x04\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\x11\x02\
    \x04\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\
    \xbd\x02\x18\x1d\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xbd\x02\x20\"\n\
    \x0c\n\x04\x04\x11\x02\x05\x12\x04\xbe\x02\x08(\n\r\n\x05\x04\x11\x02\
    \x05\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\
    \xbe\x02\x11\x17\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\xbe\x02\x18#\n\r\
    \n\x05\x04\x11\x02\x05\x03\x12\x04\xbe\x02&'\n\x0c\n\x04\x04\x11\x02\x06\
    \x12\x04\xbf\x02\x08(\n\r\n\x05\x04\x11\x02\x06\x04\x12\x04\xbf\x02\x08\
    \x10\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04\
    \x11\x02\x06\x01\x12\x04\xbf\x02\x18#\n\r\n\x05\x04\x11\x02\x06\x03\x12\
    \x04\xbf\x02&'\n\x0c\n\x04\x04\x11\x02\x07\x12\x04\xc0\x02\x08-\n\r\n\
    \x05\x04\x11\x02\x07\x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04\x11\x02\
    \x07\x05\x12\x04\xc0\x02\x11\x18\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\
    \xc0\x02\x19(\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\xc0\x02+,\n\x0c\n\
    \x04\x04\x11\x02\x08\x12\x04\xc1\x02\x08-\n\r\n\x05\x04\x11\x02\x08\x04\
    \x12\x04\xc1\x02\x08\x10\n\r\n\x05\x04\x11\x02\x08\x05\x12\x04\xc1\x02\
    \x11\x17\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xc1\x02\x18(\n\r\n\x05\
    \x04\x11\x02\x08\x03\x12\x04\xc1\x02+,\n\x0c\n\x04\x04\x11\x02\t\x12\x04\
    \xc2\x02\x082\n\r\n\x05\x04\x11\x02\t\x04\x12\x04\xc2\x02\x08\x10\n\r\n\
    \x05\x04\x11\x02\t\x05\x12\x04\xc2\x02\x11\x18\n\r\n\x05\x04\x11\x02\t\
    \x01\x12\x04\xc2\x02\x19-\n\r\n\x05\x04\x11\x02\t\x03\x12\x04\xc2\x0201\
    \n\x0c\n\x04\x04\x11\x02\n\x12\x04\xc3\x02\x083\n\r\n\x05\x04\x11\x02\n\
    \x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04\x11\x02\n\x05\x12\x04\xc3\x02\
    \x11\x18\n\r\n\x05\x04\x11\x02\n\x01\x12\x04\xc3\x02\x19-\n\r\n\x05\x04\
    \x11\x02\n\x03\x12\x04\xc3\x0202\n\x0c\n\x02\x04\x12\x12\x06\xc6\x02\0\
    \xc8\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xc6\x02\x080\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xc7\x02\x08+\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\
    \xc7\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xc7\x02\x11\x18\n\r\
    \n\x05\x04\x12\x02\0\x01\x12\x04\xc7\x02\x19&\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\xc7\x02)*\n\x0c\n\x02\x04\x13\x12\x06\xca\x02\0\xda\x02\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xca\x02\x08.\n\x0e\n\x04\x04\x13\x03\0\
    \x12\x06\xcb\x02\x08\xcf\x02\t\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\xcb\
    \x02\x10\x1e\n\x0e\n\x06\x04\x13\x03\0\x02\0\x12\x04\xcc\x02\x10(\n\x0f\
    \n\x07\x04\x13\x03\0\x02\0\x04\x12\x04\xcc\x02\x10\x18\n\x0f\n\x07\x04\
    \x13\x03\0\x02\0\x05\x12\x04\xcc\x02\x19\x20\n\x0f\n\x07\x04\x13\x03\0\
    \x02\0\x01\x12\x04\xcc\x02!#\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\
    \xcc\x02&'\n\x0e\n\x06\x04\x13\x03\0\x02\x01\x12\x04\xcd\x02\x102\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\xcd\x02\x10\x18\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x01\x05\x12\x04\xcd\x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x01\x01\x12\x04\xcd\x02\x20-\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\
    \x12\x04\xcd\x0201\n\x0e\n\x06\x04\x13\x03\0\x02\x02\x12\x04\xce\x02\x10\
    0\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\xce\x02\x10\x18\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x02\x05\x12\x04\xce\x02\x19\x1f\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x02\x01\x12\x04\xce\x02\x20+\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x02\x03\x12\x04\xce\x02./\n\x0e\n\x04\x04\x13\x03\x01\x12\x06\xd1\
    \x02\x08\xd5\x02\t\n\r\n\x05\x04\x13\x03\x01\x01\x12\x04\xd1\x02\x10\x1a\
    \n\x0e\n\x06\x04\x13\x03\x01\x02\0\x12\x04\xd2\x02\x104\n\x0f\n\x07\x04\
    \x13\x03\x01\x02\0\x04\x12\x04\xd2\x02\x10\x18\n\x0f\n\x07\x04\x13\x03\
    \x01\x02\0\x05\x12\x04\xd2\x02\x19\x20\n\x0f\n\x07\x04\x13\x03\x01\x02\0\
    \x01\x12\x04\xd2\x02!/\n\x0f\n\x07\x04\x13\x03\x01\x02\0\x03\x12\x04\xd2\
    \x0223\n\x0e\n\x06\x04\x13\x03\x01\x02\x01\x12\x04\xd3\x02\x102\n\x0f\n\
    \x07\x04\x13\x03\x01\x02\x01\x04\x12\x04\xd3\x02\x10\x18\n\x0f\n\x07\x04\
    \x13\x03\x01\x02\x01\x05\x12\x04\xd3\x02\x19\x20\n\x0f\n\x07\x04\x13\x03\
    \x01\x02\x01\x01\x12\x04\xd3\x02!-\n\x0f\n\x07\x04\x13\x03\x01\x02\x01\
    \x03\x12\x04\xd3\x0201\n\x0e\n\x06\x04\x13\x03\x01\x02\x02\x12\x04\xd4\
    \x02\x100\n\x0f\n\x07\x04\x13\x03\x01\x02\x02\x04\x12\x04\xd4\x02\x10\
    \x18\n\x0f\n\x07\x04\x13\x03\x01\x02\x02\x05\x12\x04\xd4\x02\x19\x1f\n\
    \x0f\n\x07\x04\x13\x03\x01\x02\x02\x01\x12\x04\xd4\x02\x20+\n\x0f\n\x07\
    \x04\x13\x03\x01\x02\x02\x03\x12\x04\xd4\x02./\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xd7\x02\x08+\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xd7\x02\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xd7\x02\x11\x18\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xd7\x02\x19&\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xd7\x02)*\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xd8\x02\x08]\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x06\x12\x04\xd8\x02\x11G\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xd8\x02H\
    X\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xd8\x02[\\\n\x0c\n\x04\x04\x13\
    \x02\x02\x12\x04\xd9\x02\x08U\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\xd9\
    \x02\x08\x10\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\xd9\x02\x11C\n\r\n\
    \x05\x04\x13\x02\x02\x01\x12\x04\xd9\x02DP\n\r\n\x05\x04\x13\x02\x02\x03\
    \x12\x04\xd9\x02ST\n\x0c\n\x02\x04\x14\x12\x06\xdc\x02\0\xf0\x02\x01\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xdc\x02\x08.\n\x0e\n\x04\x04\x14\x03\0\
    \x12\x06\xdd\x02\x08\xe2\x02\t\n\r\n\x05\x04\x14\x03\0\x01\x12\x04\xdd\
    \x02\x10\x1d\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\xde\x02\x10*\n\x0f\
    \n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\xde\x02\x10\x18\n\x0f\n\x07\x04\
    \x14\x03\0\x02\0\x05\x12\x04\xde\x02\x19\x1f\n\x0f\n\x07\x04\x14\x03\0\
    \x02\0\x01\x12\x04\xde\x02\x20%\n\x0f\n\x07\x04\x14\x03\0\x02\0\x03\x12\
    \x04\xde\x02()\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\xdf\x02\x10/\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x01\x04\x12\x04\xdf\x02\x10\x18\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x01\x05\x12\x04\xdf\x02\x19\x1f\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x01\x01\x12\x04\xdf\x02\x20*\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x01\x03\x12\x04\xdf\x02-.\n\x0e\n\x06\x04\x14\x03\0\x02\x02\x12\x04\xe0\
    \x02\x10.\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\xe0\x02\x10\x18\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\xe0\x02\x19\x1f\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x02\x01\x12\x04\xe0\x02\x20)\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x02\x03\x12\x04\xe0\x02,-\n\x0e\n\x06\x04\x14\x03\0\x02\x03\
    \x12\x04\xe1\x02\x107\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x04\x12\x04\xe1\
    \x02\x10\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x05\x12\x04\xe1\x02\x19\
    \x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x01\x12\x04\xe1\x02\x202\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x03\x03\x12\x04\xe1\x0256\n\x0c\n\x04\x04\x14\x02\
    \0\x12\x04\xe4\x02\x08+\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xe4\x02\x08\
    \x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xe4\x02\x11\x18\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xe4\x02\x19&\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xe4\x02)*\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xe5\x02\x08%\n\r\n\x05\
    \x04\x14\x02\x01\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04\x14\x02\x01\
    \x05\x12\x04\xe5\x02\x11\x18\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xe5\
    \x02\x19\x20\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe5\x02#$\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\xe6\x02\x08&\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04\xe6\x02\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xe6\x02\x11\
    \x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xe6\x02\x18!\n\r\n\x05\x04\
    \x14\x02\x02\x03\x12\x04\xe6\x02$%\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\
    \xe7\x02\x081\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xe7\x02\x08\x10\n\r\
    \n\x05\x04\x14\x02\x03\x05\x12\x04\xe7\x02\x11\x18\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xe7\x02\x19,\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xe7\
    \x02/0\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xe8\x02\x08-\n\r\n\x05\x04\
    \x14\x02\x04\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04\x14\x02\x04\x05\
    \x12\x04\xe8\x02\x11\x17\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xe8\x02\
    \x18(\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xe8\x02+,\n\x0c\n\x04\x04\
    \x14\x02\x05\x12\x04\xe9\x02\x085\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\
    \xe9\x02\x08\x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xe9\x02\x11\x17\n\
    \r\n\x05\x04\x14\x02\x05\x01\x12\x04\xe9\x02\x180\n\r\n\x05\x04\x14\x02\
    \x05\x03\x12\x04\xe9\x0234\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\xea\x02\
    \x080\n\r\n\x05\x04\x14\x02\x06\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\
    \x04\x14\x02\x06\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x04\x14\x02\x06\
    \x01\x12\x04\xea\x02\x18+\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xea\x02.\
    /\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\xeb\x02\x08#\n\r\n\x05\x04\x14\x02\
    \x07\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\
    \xeb\x02\x11\x17\n\r\n\x05\x04\x14\x02\x07\x01\x12\x04\xeb\x02\x18\x1e\n\
    \r\n\x05\x04\x14\x02\x07\x03\x12\x04\xeb\x02!\"\n\x0c\n\x04\x04\x14\x02\
    \x08\x12\x04\xec\x02\x08\\\n\r\n\x05\x04\x14\x02\x08\x04\x12\x04\xec\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x08\x06\x12\x04\xec\x02\x11F\n\r\n\x05\
    \x04\x14\x02\x08\x01\x12\x04\xec\x02GW\n\r\n\x05\x04\x14\x02\x08\x03\x12\
    \x04\xec\x02Z[\n\x0c\n\x04\x04\x14\x02\t\x12\x04\xed\x02\x08[\n\r\n\x05\
    \x04\x14\x02\t\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\x04\x14\x02\t\x06\
    \x12\x04\xed\x02\x11F\n\r\n\x05\x04\x14\x02\t\x01\x12\x04\xed\x02GU\n\r\
    \n\x05\x04\x14\x02\t\x03\x12\x04\xed\x02XZ\n\x0c\n\x04\x04\x14\x02\n\x12\
    \x04\xee\x02\x08^\n\r\n\x05\x04\x14\x02\n\x04\x12\x04\xee\x02\x08\x10\n\
    \r\n\x05\x04\x14\x02\n\x06\x12\x04\xee\x02\x11F\n\r\n\x05\x04\x14\x02\n\
    \x01\x12\x04\xee\x02GX\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\xee\x02[]\n\
    \x0c\n\x04\x04\x14\x02\x0b\x12\x04\xef\x02\x08\\\n\r\n\x05\x04\x14\x02\
    \x0b\x04\x12\x04\xef\x02\x08\x10\n\r\n\x05\x04\x14\x02\x0b\x06\x12\x04\
    \xef\x02\x11F\n\r\n\x05\x04\x14\x02\x0b\x01\x12\x04\xef\x02GV\n\r\n\x05\
    \x04\x14\x02\x0b\x03\x12\x04\xef\x02Y[\n\x0c\n\x02\x04\x15\x12\x06\xf2\
    \x02\0\x81\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xf2\x02\x08%\n\x0e\n\
    \x04\x04\x15\x03\0\x12\x06\xf3\x02\x08\xf6\x02\t\n\r\n\x05\x04\x15\x03\0\
    \x01\x12\x04\xf3\x02\x10\x1a\n\x0e\n\x06\x04\x15\x03\0\x02\0\x12\x04\xf4\
    \x02\x103\n\x0f\n\x07\x04\x15\x03\0\x02\0\x04\x12\x04\xf4\x02\x10\x18\n\
    \x0f\n\x07\x04\x15\x03\0\x02\0\x05\x12\x04\xf4\x02\x19\x20\n\x0f\n\x07\
    \x04\x15\x03\0\x02\0\x01\x12\x04\xf4\x02!.\n\x0f\n\x07\x04\x15\x03\0\x02\
    \0\x03\x12\x04\xf4\x0212\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\xf5\
    \x02\x10*\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x04\x12\x04\xf5\x02\x10\x18\
    \n\x0f\n\x07\x04\x15\x03\0\x02\x01\x05\x12\x04\xf5\x02\x19\x1f\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x01\x12\x04\xf5\x02\x20%\n\x0f\n\x07\x04\x15\
    \x03\0\x02\x01\x03\x12\x04\xf5\x02()\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xf8\x02\x08$\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xf8\x02\x08\x10\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xf8\x02\x11\x16\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xf8\x02\x17\x1f\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf8\x02\
    \"#\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xf9\x02\x08,\n\r\n\x05\x04\x15\
    \x02\x01\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\
    \x04\xf9\x02\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xf9\x02\x18'\
    \n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xf9\x02*+\n\x0c\n\x04\x04\x15\x02\
    \x02\x12\x04\xfa\x02\x08*\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xfa\x02\
    \x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xfa\x02\x11\x17\n\r\n\x05\
    \x04\x15\x02\x02\x01\x12\x04\xfa\x02\x18%\n\r\n\x05\x04\x15\x02\x02\x03\
    \x12\x04\xfa\x02()\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xfb\x02\x08+\n\r\
    \n\x05\x04\x15\x02\x03\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x03\x05\x12\x04\xfb\x02\x11\x17\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\
    \xfb\x02\x18&\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xfb\x02)*\n\x0c\n\
    \x04\x04\x15\x02\x04\x12\x04\xfc\x02\x083\n\r\n\x05\x04\x15\x02\x04\x04\
    \x12\x04\xfc\x02\x08\x10\n\r\n\x05\x04\x15\x02\x04\x05\x12\x04\xfc\x02\
    \x11\x17\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xfc\x02\x18.\n\r\n\x05\
    \x04\x15\x02\x04\x03\x12\x04\xfc\x0212\n\x0c\n\x04\x04\x15\x02\x05\x12\
    \x04\xfd\x02\x08-\n\r\n\x05\x04\x15\x02\x05\x04\x12\x04\xfd\x02\x08\x10\
    \n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\xfd\x02\x11\x16\n\r\n\x05\x04\x15\
    \x02\x05\x01\x12\x04\xfd\x02\x17(\n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\
    \xfd\x02+,\n\x0c\n\x04\x04\x15\x02\x06\x12\x04\xfe\x02\x08/\n\r\n\x05\
    \x04\x15\x02\x06\x04\x12\x04\xfe\x02\x08\x10\n\r\n\x05\x04\x15\x02\x06\
    \x05\x12\x04\xfe\x02\x11\x16\n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\xfe\
    \x02\x17*\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\xfe\x02-.\n\x0c\n\x04\
    \x04\x15\x02\x07\x12\x04\xff\x02\x08L\n\r\n\x05\x04\x15\x02\x07\x04\x12\
    \x04\xff\x02\x08\x10\n\r\n\x05\x04\x15\x02\x07\x06\x12\x04\xff\x02\x11:\
    \n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xff\x02;G\n\r\n\x05\x04\x15\x02\
    \x07\x03\x12\x04\xff\x02JK\n\x0c\n\x04\x04\x15\x02\x08\x12\x04\x80\x03\
    \x08#\n\r\n\x05\x04\x15\x02\x08\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\
    \x04\x15\x02\x08\x05\x12\x04\x80\x03\x11\x18\n\r\n\x05\x04\x15\x02\x08\
    \x01\x12\x04\x80\x03\x19\x1e\n\r\n\x05\x04\x15\x02\x08\x03\x12\x04\x80\
    \x03!\"\n\x0c\n\x02\x04\x16\x12\x06\x83\x03\0\x8d\x03\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\x83\x03\x08'\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x84\
    \x03\x08+\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x84\x03\x08\x10\n\r\n\x05\
    \x04\x16\x02\0\x05\x12\x04\x84\x03\x11\x18\n\r\n\x05\x04\x16\x02\0\x01\
    \x12\x04\x84\x03\x19&\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x84\x03)*\n\
    \x0c\n\x04\x04\x16\x02\x01\x12\x04\x85\x03\x08-\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \x85\x03\x11\x18\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x85\x03\x19(\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\x85\x03+,\n\x0c\n\x04\x04\x16\x02\x02\
    \x12\x04\x86\x03\x08*\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\x86\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x86\x03\x11\x18\n\r\n\x05\x04\
    \x16\x02\x02\x01\x12\x04\x86\x03\x19%\n\r\n\x05\x04\x16\x02\x02\x03\x12\
    \x04\x86\x03()\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\x87\x03\x08(\n\r\n\
    \x05\x04\x16\x02\x03\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04\x16\x02\
    \x03\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\
    \x87\x03\x18#\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x87\x03&'\n\x0c\n\
    \x04\x04\x16\x02\x04\x12\x04\x88\x03\x08)\n\r\n\x05\x04\x16\x02\x04\x04\
    \x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\x88\x03\
    \x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\x88\x03\x18$\n\r\n\x05\
    \x04\x16\x02\x04\x03\x12\x04\x88\x03'(\n\x0c\n\x04\x04\x16\x02\x05\x12\
    \x04\x89\x03\x088\n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\x89\x03\x08\x10\
    \n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\x89\x03\x11\x17\n\r\n\x05\x04\x16\
    \x02\x05\x01\x12\x04\x89\x03\x183\n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\
    \x89\x0367\n\x0c\n\x04\x04\x16\x02\x06\x12\x04\x8a\x03\x08D\n\r\n\x05\
    \x04\x16\x02\x06\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\x16\x02\x06\
    \x06\x12\x04\x8a\x03\x119\n\r\n\x05\x04\x16\x02\x06\x01\x12\x04\x8a\x03:\
    ?\n\r\n\x05\x04\x16\x02\x06\x03\x12\x04\x8a\x03BC\n\x0c\n\x04\x04\x16\
    \x02\x07\x12\x04\x8b\x03\x08>\n\r\n\x05\x04\x16\x02\x07\x04\x12\x04\x8b\
    \x03\x08\x10\n\r\n\x05\x04\x16\x02\x07\x06\x12\x04\x8b\x03\x114\n\r\n\
    \x05\x04\x16\x02\x07\x01\x12\x04\x8b\x0359\n\r\n\x05\x04\x16\x02\x07\x03\
    \x12\x04\x8b\x03<=\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\x8c\x03\x08-\n\r\
    \n\x05\x04\x16\x02\x08\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04\x16\x02\
    \x08\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\x16\x02\x08\x01\x12\x04\
    \x8c\x03\x18(\n\r\n\x05\x04\x16\x02\x08\x03\x12\x04\x8c\x03+,\n\x0c\n\
    \x02\x04\x17\x12\x06\x8f\x03\0\x98\x03\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\x8f\x03\x08\"\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x90\x03\x082\n\r\n\
    \x05\x04\x17\x02\0\x04\x12\x04\x90\x03\x08\x10\n\r\n\x05\x04\x17\x02\0\
    \x05\x12\x04\x90\x03\x11\x18\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x90\x03\
    \x19-\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x90\x0301\n\x0c\n\x04\x04\x17\
    \x02\x01\x12\x04\x91\x03\x082\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\x91\
    \x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\x91\x03\x11\x18\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\x91\x03\x19-\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\x91\x0301\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\x92\x03\x08,\
    \n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\x02\x05\x12\x04\x92\x03\x11\x18\n\r\n\x05\x04\x17\x02\x02\x01\x12\
    \x04\x92\x03\x19'\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x92\x03*+\n\x0c\
    \n\x04\x04\x17\x02\x03\x12\x04\x93\x03\x08,\n\r\n\x05\x04\x17\x02\x03\
    \x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\x93\
    \x03\x11\x17\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\x93\x03\x18'\n\r\n\
    \x05\x04\x17\x02\x03\x03\x12\x04\x93\x03*+\n\x0c\n\x04\x04\x17\x02\x04\
    \x12\x04\x94\x03\x088\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\x94\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\x94\x03\x11\x17\n\r\n\x05\x04\
    \x17\x02\x04\x01\x12\x04\x94\x03\x183\n\r\n\x05\x04\x17\x02\x04\x03\x12\
    \x04\x94\x0367\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\x95\x03\x08D\n\r\n\
    \x05\x04\x17\x02\x05\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x05\x06\x12\x04\x95\x03\x119\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\x95\
    \x03:?\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\x95\x03BC\n\x0c\n\x04\x04\
    \x17\x02\x06\x12\x04\x96\x03\x08>\n\r\n\x05\x04\x17\x02\x06\x04\x12\x04\
    \x96\x03\x08\x10\n\r\n\x05\x04\x17\x02\x06\x06\x12\x04\x96\x03\x114\n\r\
    \n\x05\x04\x17\x02\x06\x01\x12\x04\x96\x0359\n\r\n\x05\x04\x17\x02\x06\
    \x03\x12\x04\x96\x03<=\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\x97\x03\x08-\
    \n\r\n\x05\x04\x17\x02\x07\x04\x12\x04\x97\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\x07\x05\x12\x04\x97\x03\x11\x17\n\r\n\x05\x04\x17\x02\x07\x01\x12\
    \x04\x97\x03\x18(\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\x97\x03+,\n\x0c\
    \n\x02\x04\x18\x12\x06\x9a\x03\0\xa9\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x9a\x03\x08)\n\x0e\n\x04\x04\x18\x04\0\x12\x06\x9b\x03\x08\x9f\x03\
    \t\n\r\n\x05\x04\x18\x04\0\x01\x12\x04\x9b\x03\r\x17\n\x0e\n\x06\x04\x18\
    \x04\0\x02\0\x12\x04\x9c\x03\x10\x19\n\x0f\n\x07\x04\x18\x04\0\x02\0\x01\
    \x12\x04\x9c\x03\x10\x14\n\x0f\n\x07\x04\x18\x04\0\x02\0\x02\x12\x04\x9c\
    \x03\x17\x18\n\x0e\n\x06\x04\x18\x04\0\x02\x01\x12\x04\x9d\x03\x10\x1d\n\
    \x0f\n\x07\x04\x18\x04\0\x02\x01\x01\x12\x04\x9d\x03\x10\x18\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x01\x02\x12\x04\x9d\x03\x1b\x1c\n\x0e\n\x06\x04\x18\
    \x04\0\x02\x02\x12\x04\x9e\x03\x10!\n\x0f\n\x07\x04\x18\x04\0\x02\x02\
    \x01\x12\x04\x9e\x03\x10\x1c\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\
    \x04\x9e\x03\x1f\x20\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xa1\x03\x089\n\r\
    \n\x05\x04\x18\x02\0\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xa1\x03\x11\x18\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xa1\x03\
    \x194\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xa1\x0378\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\xa2\x03\x08.\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xa2\
    \x03\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xa2\x03\x11\x18\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\xa2\x03\x19)\n\r\n\x05\x04\x18\x02\x01\
    \x03\x12\x04\xa2\x03,-\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xa3\x03\x080\
    \n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\x04\x18\
    \x02\x02\x05\x12\x04\xa3\x03\x11\x18\n\r\n\x05\x04\x18\x02\x02\x01\x12\
    \x04\xa3\x03\x19+\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xa3\x03./\n\x0c\
    \n\x04\x04\x18\x02\x03\x12\x04\xa4\x03\x08+\n\r\n\x05\x04\x18\x02\x03\
    \x04\x12\x04\xa4\x03\x08\x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xa4\
    \x03\x11\x18\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xa4\x03\x19&\n\r\n\
    \x05\x04\x18\x02\x03\x03\x12\x04\xa4\x03)*\n\x0c\n\x04\x04\x18\x02\x04\
    \x12\x04\xa5\x03\x088\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\xa5\x03\x08\
    \x10\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\xa5\x03\x11\x17\n\r\n\x05\x04\
    \x18\x02\x04\x01\x12\x04\xa5\x03\x183\n\r\n\x05\x04\x18\x02\x04\x03\x12\
    \x04\xa5\x0367\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\xa6\x03\x08_\n\r\n\
    \x05\x04\x18\x02\x05\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04\x18\x02\
    \x05\x06\x12\x04\xa6\x03\x11>\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xa6\
    \x03?I\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xa6\x03LM\n\r\n\x05\x04\x18\
    \x02\x05\x08\x12\x04\xa6\x03N^\n\r\n\x05\x04\x18\x02\x05\x07\x12\x04\xa6\
    \x03Y]\n\x0c\n\x04\x04\x18\x02\x06\x12\x04\xa7\x03\x08\"\n\r\n\x05\x04\
    \x18\x02\x06\x04\x12\x04\xa7\x03\x08\x10\n\r\n\x05\x04\x18\x02\x06\x05\
    \x12\x04\xa7\x03\x11\x17\n\r\n\x05\x04\x18\x02\x06\x01\x12\x04\xa7\x03\
    \x18\x1d\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\xa7\x03\x20!\n\x0c\n\x04\
    \x04\x18\x02\x07\x12\x04\xa8\x03\x08(\n\r\n\x05\x04\x18\x02\x07\x04\x12\
    \x04\xa8\x03\x08\x10\n\r\n\x05\x04\x18\x02\x07\x05\x12\x04\xa8\x03\x11\
    \x17\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\xa8\x03\x18#\n\r\n\x05\x04\
    \x18\x02\x07\x03\x12\x04\xa8\x03&'\n\x0c\n\x02\x04\x19\x12\x06\xab\x03\0\
    \xb3\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xab\x03\x08%\n\x0c\n\x04\
    \x04\x19\x02\0\x12\x04\xac\x03\x089\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\
    \xac\x03\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xac\x03\x11\x18\n\r\
    \n\x05\x04\x19\x02\0\x01\x12\x04\xac\x03\x194\n\r\n\x05\x04\x19\x02\0\
    \x03\x12\x04\xac\x0378\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xad\x03\x08.\
    \n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xad\x03\x08\x10\n\r\n\x05\x04\x19\
    \x02\x01\x05\x12\x04\xad\x03\x11\x18\n\r\n\x05\x04\x19\x02\x01\x01\x12\
    \x04\xad\x03\x19)\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xad\x03,-\n\x0c\
    \n\x04\x04\x19\x02\x02\x12\x04\xae\x03\x080\n\r\n\x05\x04\x19\x02\x02\
    \x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xae\
    \x03\x11\x18\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xae\x03\x19+\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xae\x03./\n\x0c\n\x04\x04\x19\x02\x03\
    \x12\x04\xaf\x03\x088\n\r\n\x05\x04\x19\x02\x03\x04\x12\x04\xaf\x03\x08\
    \x10\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xaf\x03\x11\x17\n\r\n\x05\x04\
    \x19\x02\x03\x01\x12\x04\xaf\x03\x183\n\r\n\x05\x04\x19\x02\x03\x03\x12\
    \x04\xaf\x0367\n\x0c\n\x04\x04\x19\x02\x04\x12\x04\xb0\x03\x08+\n\r\n\
    \x05\x04\x19\x02\x04\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\x04\x19\x02\
    \x04\x05\x12\x04\xb0\x03\x11\x18\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\
    \xb0\x03\x19&\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xb0\x03)*\n\x0c\n\
    \x04\x04\x19\x02\x05\x12\x04\xb1\x03\x08%\n\r\n\x05\x04\x19\x02\x05\x04\
    \x12\x04\xb1\x03\x08\x10\n\r\n\x05\x04\x19\x02\x05\x05\x12\x04\xb1\x03\
    \x11\x15\n\r\n\x05\x04\x19\x02\x05\x01\x12\x04\xb1\x03\x16\x20\n\r\n\x05\
    \x04\x19\x02\x05\x03\x12\x04\xb1\x03#$\n\x0c\n\x04\x04\x19\x02\x06\x12\
    \x04\xb2\x03\x08*\n\r\n\x05\x04\x19\x02\x06\x04\x12\x04\xb2\x03\x08\x10\
    \n\r\n\x05\x04\x19\x02\x06\x05\x12\x04\xb2\x03\x11\x18\n\r\n\x05\x04\x19\
    \x02\x06\x01\x12\x04\xb2\x03\x19\"\n\r\n\x05\x04\x19\x02\x06\x03\x12\x04\
    \xb2\x03%)\n\x0c\n\x02\x04\x1a\x12\x06\xb5\x03\0\xbe\x03\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xb5\x03\x08.\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xb6\
    \x03\x08,\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\xb6\x03\x11\x18\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\xb6\x03\x19'\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xb6\x03*+\n\
    \x0c\n\x04\x04\x1a\x02\x01\x12\x04\xb7\x03\x08'\n\r\n\x05\x04\x1a\x02\
    \x01\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\
    \xb7\x03\x11\x18\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xb7\x03\x19\"\n\r\
    \n\x05\x04\x1a\x02\x01\x03\x12\x04\xb7\x03%&\n\x0c\n\x04\x04\x1a\x02\x02\
    \x12\x04\xb8\x03\x08.\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xb8\x03\x08\
    \x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xb8\x03\x11\x18\n\r\n\x05\x04\
    \x1a\x02\x02\x01\x12\x04\xb8\x03\x19)\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\xb8\x03,-\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xb9\x03\x08+\n\r\n\
    \x05\x04\x1a\x02\x03\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x03\x05\x12\x04\xb9\x03\x11\x18\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\
    \xb9\x03\x19&\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xb9\x03)*\n\x0c\n\
    \x04\x04\x1a\x02\x04\x12\x04\xba\x03\x080\n\r\n\x05\x04\x1a\x02\x04\x04\
    \x12\x04\xba\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x04\x05\x12\x04\xba\x03\
    \x11\x18\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xba\x03\x19+\n\r\n\x05\
    \x04\x1a\x02\x04\x03\x12\x04\xba\x03./\n\x0c\n\x04\x04\x1a\x02\x05\x12\
    \x04\xbb\x03\x08-\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\xbb\x03\x08\x10\
    \n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x04\x1a\
    \x02\x05\x01\x12\x04\xbb\x03\x18(\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\
    \xbb\x03+,\n\x0c\n\x04\x04\x1a\x02\x06\x12\x04\xbc\x03\x083\n\r\n\x05\
    \x04\x1a\x02\x06\x04\x12\x04\xbc\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x06\
    \x05\x12\x04\xbc\x03\x11\x17\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xbc\
    \x03\x18.\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xbc\x0312\n\x0c\n\x04\
    \x04\x1a\x02\x07\x12\x04\xbd\x03\x08(\n\r\n\x05\x04\x1a\x02\x07\x04\x12\
    \x04\xbd\x03\x08\x10\n\r\n\x05\x04\x1a\x02\x07\x05\x12\x04\xbd\x03\x11\
    \x18\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xbd\x03\x19\"\n\r\n\x05\x04\
    \x1a\x02\x07\x03\x12\x04\xbd\x03%'\n\x0c\n\x02\x04\x1b\x12\x06\xc0\x03\0\
    \xc4\x03\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xc0\x03\x08*\n\x0c\n\x04\
    \x04\x1b\x02\0\x12\x04\xc1\x03\x08>\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\
    \xc1\x03\x08\x10\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xc1\x03\x114\n\r\n\
    \x05\x04\x1b\x02\0\x01\x12\x04\xc1\x0359\n\r\n\x05\x04\x1b\x02\0\x03\x12\
    \x04\xc1\x03<=\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xc2\x03\x08\x20\n\r\n\
    \x05\x04\x1b\x02\x01\x04\x12\x04\xc2\x03\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xc2\x03\x11\x16\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xc2\x03\x17\x1b\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xc2\x03\x1e\x1f\n\
    \x0c\n\x04\x04\x1b\x02\x02\x12\x04\xc3\x03\x08%\n\r\n\x05\x04\x1b\x02\
    \x02\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\
    \xc3\x03\x11\x16\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xc3\x03\x17\x20\n\
    \r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xc3\x03#$\n\x0c\n\x02\x04\x1c\x12\
    \x06\xc6\x03\0\xcb\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xc6\x03\x08.\
    \n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xc7\x03\x08+\n\r\n\x05\x04\x1c\x02\0\
    \x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xc7\x03\
    \x11\x18\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xc7\x03\x19&\n\r\n\x05\x04\
    \x1c\x02\0\x03\x12\x04\xc7\x03)*\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xc8\
    \x03\x083\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xc8\x03\x08\x10\n\r\n\
    \x05\x04\x1c\x02\x01\x05\x12\x04\xc8\x03\x11\x17\n\r\n\x05\x04\x1c\x02\
    \x01\x01\x12\x04\xc8\x03\x18.\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xc8\
    \x0312\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xc9\x03\x08.\n\r\n\x05\x04\
    \x1c\x02\x02\x04\x12\x04\xc9\x03\x08\x10\n\r\n\x05\x04\x1c\x02\x02\x05\
    \x12\x04\xc9\x03\x11\x18\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xc9\x03\
    \x19)\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xc9\x03,-\n\x0c\n\x04\x04\
    \x1c\x02\x03\x12\x04\xca\x03\x08(\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\
    \xca\x03\x08\x10\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xca\x03\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xca\x03\x18#\n\r\n\x05\x04\x1c\x02\
    \x03\x03\x12\x04\xca\x03&'\n\x0c\n\x02\x04\x1d\x12\x06\xcd\x03\0\xde\x03\
    \x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xcd\x03\x08\"\n\x0e\n\x04\x04\x1d\
    \x03\0\x12\x06\xce\x03\x08\xd3\x03\t\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\
    \xce\x03\x10\x1c\n\x0e\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xcf\x03\x10,\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x04\xcf\x03\x10\x18\n\x0f\n\x07\
    \x04\x1d\x03\0\x02\0\x05\x12\x04\xcf\x03\x19\x20\n\x0f\n\x07\x04\x1d\x03\
    \0\x02\0\x01\x12\x04\xcf\x03!'\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x03\x12\
    \x04\xcf\x03*+\n\x0e\n\x06\x04\x1d\x03\0\x02\x01\x12\x04\xd0\x03\x10,\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\x04\xd0\x03\x10\x18\n\x0f\n\x07\
    \x04\x1d\x03\0\x02\x01\x05\x12\x04\xd0\x03\x19\x1f\n\x0f\n\x07\x04\x1d\
    \x03\0\x02\x01\x01\x12\x04\xd0\x03\x20'\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \x01\x03\x12\x04\xd0\x03*+\n\x0e\n\x06\x04\x1d\x03\0\x02\x02\x12\x04\xd1\
    \x03\x102\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x04\x12\x04\xd1\x03\x10\x18\
    \n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x05\x12\x04\xd1\x03\x19\x1f\n\x0f\n\
    \x07\x04\x1d\x03\0\x02\x02\x01\x12\x04\xd1\x03\x20-\n\x0f\n\x07\x04\x1d\
    \x03\0\x02\x02\x03\x12\x04\xd1\x0301\n\x0e\n\x06\x04\x1d\x03\0\x02\x03\
    \x12\x04\xd2\x03\x10>\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x04\x12\x04\xd2\
    \x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x05\x12\x04\xd2\x03\x19\
    \x20\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x01\x12\x04\xd2\x03!9\n\x0f\n\x07\
    \x04\x1d\x03\0\x02\x03\x03\x12\x04\xd2\x03<=\n\x0e\n\x04\x04\x1d\x03\x01\
    \x12\x06\xd5\x03\x08\xd9\x03\t\n\r\n\x05\x04\x1d\x03\x01\x01\x12\x04\xd5\
    \x03\x10\x15\n\x0e\n\x06\x04\x1d\x03\x01\x02\0\x12\x04\xd6\x03\x10/\n\
    \x0f\n\x07\x04\x1d\x03\x01\x02\0\x04\x12\x04\xd6\x03\x10\x18\n\x0f\n\x07\
    \x04\x1d\x03\x01\x02\0\x05\x12\x04\xd6\x03\x19\x20\n\x0f\n\x07\x04\x1d\
    \x03\x01\x02\0\x01\x12\x04\xd6\x03!*\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\
    \x03\x12\x04\xd6\x03-.\n\x0e\n\x06\x04\x1d\x03\x01\x02\x01\x12\x04\xd7\
    \x03\x101\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x04\x12\x04\xd7\x03\x10\
    \x18\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x05\x12\x04\xd7\x03\x19\x20\n\
    \x0f\n\x07\x04\x1d\x03\x01\x02\x01\x01\x12\x04\xd7\x03!,\n\x0f\n\x07\x04\
    \x1d\x03\x01\x02\x01\x03\x12\x04\xd7\x03/0\n\x0e\n\x06\x04\x1d\x03\x01\
    \x02\x02\x12\x04\xd8\x03\x10*\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x04\
    \x12\x04\xd8\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x05\x12\x04\
    \xd8\x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x01\x12\x04\xd8\x03\
    \x20%\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x03\x12\x04\xd8\x03()\n\x0c\n\
    \x04\x04\x1d\x02\0\x12\x04\xdb\x03\x08M\n\r\n\x05\x04\x1d\x02\0\x04\x12\
    \x04\xdb\x03\x08\x10\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xdb\x03\x119\n\
    \r\n\x05\x04\x1d\x02\0\x01\x12\x04\xdb\x03:H\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xdb\x03KL\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xdc\x03\x08>\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xdc\x03\x08\x10\n\r\n\x05\x04\x1d\x02\
    \x01\x06\x12\x04\xdc\x03\x112\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xdc\
    \x0339\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xdc\x03<=\n\x0c\n\x04\x04\
    \x1d\x02\x02\x12\x04\xdd\x03\x08%\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\
    \xdd\x03\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xdd\x03\x11\x17\n\
    \r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xdd\x03\x18\x20\n\r\n\x05\x04\x1d\
    \x02\x02\x03\x12\x04\xdd\x03#$\n\x0c\n\x02\x04\x1e\x12\x06\xe0\x03\0\xe7\
    \x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xe0\x03\x08&\n\x0c\n\x04\x04\
    \x1e\x02\0\x12\x04\xe1\x03\x08.\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xe1\
    \x03\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xe1\x03\x11\x18\n\r\n\
    \x05\x04\x1e\x02\0\x01\x12\x04\xe1\x03\x19)\n\r\n\x05\x04\x1e\x02\0\x03\
    \x12\x04\xe1\x03,-\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xe2\x03\x088\n\r\
    \n\x05\x04\x1e\x02\x01\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x01\x06\x12\x04\xe2\x03\x11,\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xe2\
    \x03-3\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xe2\x0367\n\x0c\n\x04\x04\
    \x1e\x02\x02\x12\x04\xe3\x03\x085\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\
    \xe3\x03\x08\x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xe3\x03\x11\x17\n\
    \r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xe3\x03\x180\n\r\n\x05\x04\x1e\x02\
    \x02\x03\x12\x04\xe3\x0334\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xe4\x03\
    \x08F\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\
    \x04\x1e\x02\x03\x06\x12\x04\xe4\x03\x111\n\r\n\x05\x04\x1e\x02\x03\x01\
    \x12\x04\xe4\x032A\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xe4\x03DE\n\x0c\
    \n\x04\x04\x1e\x02\x04\x12\x04\xe5\x03\x08<\n\r\n\x05\x04\x1e\x02\x04\
    \x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04\x1e\x02\x04\x06\x12\x04\xe5\
    \x03\x11,\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xe5\x03-7\n\r\n\x05\x04\
    \x1e\x02\x04\x03\x12\x04\xe5\x03:;\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\
    \xe6\x03\x08J\n\r\n\x05\x04\x1e\x02\x05\x04\x12\x04\xe6\x03\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x05\x06\x12\x04\xe6\x03\x113\n\r\n\x05\x04\x1e\x02\
    \x05\x01\x12\x04\xe6\x034E\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xe6\x03\
    HI\n\x0c\n\x02\x04\x1f\x12\x06\xe9\x03\0\xfc\x03\x01\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\xe9\x03\x089\n\x0e\n\x04\x04\x1f\x04\0\x12\x06\xea\x03\x08\
    \xee\x03\t\n\r\n\x05\x04\x1f\x04\0\x01\x12\x04\xea\x03\r\x12\n\x0e\n\x06\
    \x04\x1f\x04\0\x02\0\x12\x04\xeb\x03\x10&\n\x0f\n\x07\x04\x1f\x04\0\x02\
    \0\x01\x12\x04\xeb\x03\x10!\n\x0f\n\x07\x04\x1f\x04\0\x02\0\x02\x12\x04\
    \xeb\x03$%\n\x0e\n\x06\x04\x1f\x04\0\x02\x01\x12\x04\xec\x03\x10$\n\x0f\
    \n\x07\x04\x1f\x04\0\x02\x01\x01\x12\x04\xec\x03\x10\x1f\n\x0f\n\x07\x04\
    \x1f\x04\0\x02\x01\x02\x12\x04\xec\x03\"#\n\x0e\n\x06\x04\x1f\x04\0\x02\
    \x02\x12\x04\xed\x03\x10*\n\x0f\n\x07\x04\x1f\x04\0\x02\x02\x01\x12\x04\
    \xed\x03\x10%\n\x0f\n\x07\x04\x1f\x04\0\x02\x02\x02\x12\x04\xed\x03()\n\
    \x0c\n\x04\x04\x1f\x02\0\x12\x04\xf0\x03\x08=\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xf0\x03\x08\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xf0\x03\
    \x114\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xf0\x0358\n\r\n\x05\x04\x1f\
    \x02\0\x03\x12\x04\xf0\x03;<\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xf1\x03\
    \x08=\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xf1\x03\x08\x10\n\r\n\x05\
    \x04\x1f\x02\x01\x06\x12\x04\xf1\x03\x114\n\r\n\x05\x04\x1f\x02\x01\x01\
    \x12\x04\xf1\x0358\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xf1\x03;<\n\x0c\
    \n\x04\x04\x1f\x02\x02\x12\x04\xf2\x03\x08'\n\r\n\x05\x04\x1f\x02\x02\
    \x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xf2\
    \x03\x11\x18\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xf2\x03\x19\"\n\r\n\
    \x05\x04\x1f\x02\x02\x03\x12\x04\xf2\x03%&\n\x0c\n\x04\x04\x1f\x02\x03\
    \x12\x04\xf3\x03\x08%\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xf3\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\xf3\x03\x11\x18\n\r\n\x05\x04\
    \x1f\x02\x03\x01\x12\x04\xf3\x03\x19\x20\n\r\n\x05\x04\x1f\x02\x03\x03\
    \x12\x04\xf3\x03#$\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\xf4\x03\x08\"\n\r\
    \n\x05\x04\x1f\x02\x04\x04\x12\x04\xf4\x03\x08\x10\n\r\n\x05\x04\x1f\x02\
    \x04\x05\x12\x04\xf4\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\
    \xf4\x03\x18\x1d\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xf4\x03\x20!\n\
    \x0c\n\x04\x04\x1f\x02\x05\x12\x04\xf5\x03\x08=\n\r\n\x05\x04\x1f\x02\
    \x05\x04\x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\
    \xf5\x03\x11\x18\n\r\n\x05\x04\x1f\x02\x05\x01\x12\x04\xf5\x03\x198\n\r\
    \n\x05\x04\x1f\x02\x05\x03\x12\x04\xf5\x03;<\n\x0c\n\x04\x04\x1f\x02\x06\
    \x12\x04\xf6\x03\x084\n\r\n\x05\x04\x1f\x02\x06\x04\x12\x04\xf6\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x06\x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\x06\x01\x12\x04\xf6\x03\x18/\n\r\n\x05\x04\x1f\x02\x06\x03\x12\
    \x04\xf6\x0323\n\x0c\n\x04\x04\x1f\x02\x07\x12\x04\xf7\x03\x088\n\r\n\
    \x05\x04\x1f\x02\x07\x04\x12\x04\xf7\x03\x08\x10\n\r\n\x05\x04\x1f\x02\
    \x07\x06\x12\x04\xf7\x03\x11,\n\r\n\x05\x04\x1f\x02\x07\x01\x12\x04\xf7\
    \x03-3\n\r\n\x05\x04\x1f\x02\x07\x03\x12\x04\xf7\x0367\n\x0c\n\x04\x04\
    \x1f\x02\x08\x12\x04\xf8\x03\x085\n\r\n\x05\x04\x1f\x02\x08\x04\x12\x04\
    \xf8\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x08\x05\x12\x04\xf8\x03\x11\x17\n\
    \r\n\x05\x04\x1f\x02\x08\x01\x12\x04\xf8\x03\x180\n\r\n\x05\x04\x1f\x02\
    \x08\x03\x12\x04\xf8\x0334\n\x0c\n\x04\x04\x1f\x02\t\x12\x04\xf9\x03\x08\
    ,\n\r\n\x05\x04\x1f\x02\t\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\t\x05\x12\x04\xf9\x03\x11\x18\n\r\n\x05\x04\x1f\x02\t\x01\x12\x04\
    \xf9\x03\x19&\n\r\n\x05\x04\x1f\x02\t\x03\x12\x04\xf9\x03)+\n\x0c\n\x04\
    \x04\x1f\x02\n\x12\x04\xfa\x03\x08)\n\r\n\x05\x04\x1f\x02\n\x04\x12\x04\
    \xfa\x03\x08\x10\n\r\n\x05\x04\x1f\x02\n\x05\x12\x04\xfa\x03\x11\x17\n\r\
    \n\x05\x04\x1f\x02\n\x01\x12\x04\xfa\x03\x18#\n\r\n\x05\x04\x1f\x02\n\
    \x03\x12\x04\xfa\x03&(\n\x0c\n\x04\x04\x1f\x02\x0b\x12\x04\xfb\x03\x08)\
    \n\r\n\x05\x04\x1f\x02\x0b\x04\x12\x04\xfb\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x0b\x05\x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x0b\x01\x12\
    \x04\xfb\x03\x18#\n\r\n\x05\x04\x1f\x02\x0b\x03\x12\x04\xfb\x03&(\n\x0c\
    \n\x02\x04\x20\x12\x06\xfe\x03\0\x94\x04\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xfe\x03\x089\n\x0e\n\x04\x04\x20\x04\0\x12\x06\xff\x03\x08\x83\x04\
    \t\n\r\n\x05\x04\x20\x04\0\x01\x12\x04\xff\x03\r\x12\n\x0e\n\x06\x04\x20\
    \x04\0\x02\0\x12\x04\x80\x04\x10&\n\x0f\n\x07\x04\x20\x04\0\x02\0\x01\
    \x12\x04\x80\x04\x10!\n\x0f\n\x07\x04\x20\x04\0\x02\0\x02\x12\x04\x80\
    \x04$%\n\x0e\n\x06\x04\x20\x04\0\x02\x01\x12\x04\x81\x04\x10$\n\x0f\n\
    \x07\x04\x20\x04\0\x02\x01\x01\x12\x04\x81\x04\x10\x1f\n\x0f\n\x07\x04\
    \x20\x04\0\x02\x01\x02\x12\x04\x81\x04\"#\n\x0e\n\x06\x04\x20\x04\0\x02\
    \x02\x12\x04\x82\x04\x10*\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x01\x12\x04\
    \x82\x04\x10%\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x02\x12\x04\x82\x04()\n\
    \x0c\n\x04\x04\x20\x02\0\x12\x04\x85\x04\x08=\n\r\n\x05\x04\x20\x02\0\
    \x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\x85\x04\
    \x114\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x85\x0458\n\r\n\x05\x04\x20\
    \x02\0\x03\x12\x04\x85\x04;<\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x86\x04\
    \x08=\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x86\x04\x08\x10\n\r\n\x05\
    \x04\x20\x02\x01\x06\x12\x04\x86\x04\x114\n\r\n\x05\x04\x20\x02\x01\x01\
    \x12\x04\x86\x0458\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x86\x04;<\n\x0c\
    \n\x04\x04\x20\x02\x02\x12\x04\x87\x04\x083\n\r\n\x05\x04\x20\x02\x02\
    \x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x87\
    \x04\x11\x17\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x87\x04\x18.\n\r\n\
    \x05\x04\x20\x02\x02\x03\x12\x04\x87\x0412\n\x0c\n\x04\x04\x20\x02\x03\
    \x12\x04\x88\x04\x080\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x88\x04\x08\
    \x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\x88\x04\x11\x18\n\r\n\x05\x04\
    \x20\x02\x03\x01\x12\x04\x88\x04\x19+\n\r\n\x05\x04\x20\x02\x03\x03\x12\
    \x04\x88\x04./\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x89\x04\x081\n\r\n\
    \x05\x04\x20\x02\x04\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04\x20\x02\
    \x04\x05\x12\x04\x89\x04\x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\
    \x89\x04\x18,\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x89\x04/0\n\x0c\n\
    \x04\x04\x20\x02\x05\x12\x04\x8a\x04\x08:\n\r\n\x05\x04\x20\x02\x05\x04\
    \x12\x04\x8a\x04\x08\x10\n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x8a\x04\
    \x11\x17\n\r\n\x05\x04\x20\x02\x05\x01\x12\x04\x8a\x04\x185\n\r\n\x05\
    \x04\x20\x02\x05\x03\x12\x04\x8a\x0489\n\x0c\n\x04\x04\x20\x02\x06\x12\
    \x04\x8b\x04\x08'\n\r\n\x05\x04\x20\x02\x06\x04\x12\x04\x8b\x04\x08\x10\
    \n\r\n\x05\x04\x20\x02\x06\x05\x12\x04\x8b\x04\x11\x18\n\r\n\x05\x04\x20\
    \x02\x06\x01\x12\x04\x8b\x04\x19\"\n\r\n\x05\x04\x20\x02\x06\x03\x12\x04\
    \x8b\x04%&\n\x0c\n\x04\x04\x20\x02\x07\x12\x04\x8c\x04\x08%\n\r\n\x05\
    \x04\x20\x02\x07\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04\x20\x02\x07\
    \x05\x12\x04\x8c\x04\x11\x18\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x8c\
    \x04\x19\x20\n\r\n\x05\x04\x20\x02\x07\x03\x12\x04\x8c\x04#$\n\x0c\n\x04\
    \x04\x20\x02\x08\x12\x04\x8d\x04\x08\"\n\r\n\x05\x04\x20\x02\x08\x04\x12\
    \x04\x8d\x04\x08\x10\n\r\n\x05\x04\x20\x02\x08\x05\x12\x04\x8d\x04\x11\
    \x17\n\r\n\x05\x04\x20\x02\x08\x01\x12\x04\x8d\x04\x18\x1d\n\r\n\x05\x04\
    \x20\x02\x08\x03\x12\x04\x8d\x04\x20!\n\x0c\n\x04\x04\x20\x02\t\x12\x04\
    \x8e\x04\x089\n\r\n\x05\x04\x20\x02\t\x04\x12\x04\x8e\x04\x08\x10\n\r\n\
    \x05\x04\x20\x02\t\x05\x12\x04\x8e\x04\x11\x17\n\r\n\x05\x04\x20\x02\t\
    \x01\x12\x04\x8e\x04\x183\n\r\n\x05\x04\x20\x02\t\x03\x12\x04\x8e\x0468\
    \n\x0c\n\x04\x04\x20\x02\n\x12\x04\x8f\x04\x089\n\r\n\x05\x04\x20\x02\n\
    \x04\x12\x04\x8f\x04\x08\x10\n\r\n\x05\x04\x20\x02\n\x06\x12\x04\x8f\x04\
    \x11,\n\r\n\x05\x04\x20\x02\n\x01\x12\x04\x8f\x04-3\n\r\n\x05\x04\x20\
    \x02\n\x03\x12\x04\x8f\x0468\n\x0c\n\x04\x04\x20\x02\x0b\x12\x04\x90\x04\
    \x086\n\r\n\x05\x04\x20\x02\x0b\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\
    \x04\x20\x02\x0b\x05\x12\x04\x90\x04\x11\x17\n\r\n\x05\x04\x20\x02\x0b\
    \x01\x12\x04\x90\x04\x180\n\r\n\x05\x04\x20\x02\x0b\x03\x12\x04\x90\x043\
    5\n\x0c\n\x04\x04\x20\x02\x0c\x12\x04\x91\x04\x08,\n\r\n\x05\x04\x20\x02\
    \x0c\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04\x20\x02\x0c\x05\x12\x04\
    \x91\x04\x11\x18\n\r\n\x05\x04\x20\x02\x0c\x01\x12\x04\x91\x04\x19&\n\r\
    \n\x05\x04\x20\x02\x0c\x03\x12\x04\x91\x04)+\n\x0c\n\x04\x04\x20\x02\r\
    \x12\x04\x92\x04\x08)\n\r\n\x05\x04\x20\x02\r\x04\x12\x04\x92\x04\x08\
    \x10\n\r\n\x05\x04\x20\x02\r\x05\x12\x04\x92\x04\x11\x17\n\r\n\x05\x04\
    \x20\x02\r\x01\x12\x04\x92\x04\x18#\n\r\n\x05\x04\x20\x02\r\x03\x12\x04\
    \x92\x04&(\n\x0c\n\x04\x04\x20\x02\x0e\x12\x04\x93\x04\x08)\n\r\n\x05\
    \x04\x20\x02\x0e\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04\x20\x02\x0e\
    \x05\x12\x04\x93\x04\x11\x17\n\r\n\x05\x04\x20\x02\x0e\x01\x12\x04\x93\
    \x04\x18#\n\r\n\x05\x04\x20\x02\x0e\x03\x12\x04\x93\x04&(\n\x0c\n\x02\
    \x04!\x12\x06\x96\x04\0\x9a\x04\x01\n\x0b\n\x03\x04!\x01\x12\x04\x96\x04\
    \x08-\n\x0c\n\x04\x04!\x02\0\x12\x04\x97\x04\x08+\n\r\n\x05\x04!\x02\0\
    \x04\x12\x04\x97\x04\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x97\x04\
    \x11\x18\n\r\n\x05\x04!\x02\0\x01\x12\x04\x97\x04\x19&\n\r\n\x05\x04!\
    \x02\0\x03\x12\x04\x97\x04)*\n\x0c\n\x04\x04!\x02\x01\x12\x04\x98\x04\
    \x08*\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04!\
    \x02\x01\x05\x12\x04\x98\x04\x11\x18\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \x98\x04\x19%\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x98\x04()\n\x0c\n\x04\
    \x04!\x02\x02\x12\x04\x99\x04\x08-\n\r\n\x05\x04!\x02\x02\x04\x12\x04\
    \x99\x04\x08\x10\n\r\n\x05\x04!\x02\x02\x05\x12\x04\x99\x04\x11\x17\n\r\
    \n\x05\x04!\x02\x02\x01\x12\x04\x99\x04\x18(\n\r\n\x05\x04!\x02\x02\x03\
    \x12\x04\x99\x04+,\n\x0c\n\x02\x04\"\x12\x06\x9c\x04\0\xa1\x04\x01\n\x0b\
    \n\x03\x04\"\x01\x12\x04\x9c\x04\x08+\n\x0c\n\x04\x04\"\x02\0\x12\x04\
    \x9d\x04\x08+\n\r\n\x05\x04\"\x02\0\x04\x12\x04\x9d\x04\x08\x10\n\r\n\
    \x05\x04\"\x02\0\x05\x12\x04\x9d\x04\x11\x18\n\r\n\x05\x04\"\x02\0\x01\
    \x12\x04\x9d\x04\x19&\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x9d\x04)*\n\x0c\
    \n\x04\x04\"\x02\x01\x12\x04\x9e\x04\x08'\n\r\n\x05\x04\"\x02\x01\x04\
    \x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x9e\x04\x11\
    \x18\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x9e\x04\x19\"\n\r\n\x05\x04\"\
    \x02\x01\x03\x12\x04\x9e\x04%&\n\x0c\n\x04\x04\"\x02\x02\x12\x04\x9f\x04\
    \x08,\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\x9f\x04\x08\x10\n\r\n\x05\x04\
    \"\x02\x02\x05\x12\x04\x9f\x04\x11\x18\n\r\n\x05\x04\"\x02\x02\x01\x12\
    \x04\x9f\x04\x19'\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x9f\x04*+\n\x0c\n\
    \x04\x04\"\x02\x03\x12\x04\xa0\x04\x08-\n\r\n\x05\x04\"\x02\x03\x04\x12\
    \x04\xa0\x04\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xa0\x04\x11\x17\
    \n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xa0\x04\x18(\n\r\n\x05\x04\"\x02\
    \x03\x03\x12\x04\xa0\x04+,\n\x0c\n\x02\x04#\x12\x06\xa3\x04\0\xac\x04\
    \x01\n\x0b\n\x03\x04#\x01\x12\x04\xa3\x04\x08+\n\x0c\n\x04\x04#\x02\0\
    \x12\x04\xa4\x04\x082\n\r\n\x05\x04#\x02\0\x04\x12\x04\xa4\x04\x08\x10\n\
    \r\n\x05\x04#\x02\0\x05\x12\x04\xa4\x04\x11\x18\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\xa4\x04\x19-\n\r\n\x05\x04#\x02\0\x03\x12\x04\xa4\x0401\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xa5\x04\x08'\n\r\n\x05\x04#\x02\x01\x04\x12\
    \x04\xa5\x04\x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xa5\x04\x11\x18\
    \n\r\n\x05\x04#\x02\x01\x01\x12\x04\xa5\x04\x19\"\n\r\n\x05\x04#\x02\x01\
    \x03\x12\x04\xa5\x04%&\n\x0c\n\x04\x04#\x02\x02\x12\x04\xa6\x04\x08-\n\r\
    \n\x05\x04#\x02\x02\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04#\x02\x02\
    \x05\x12\x04\xa6\x04\x11\x18\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xa6\x04\
    \x19(\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xa6\x04+,\n\x0c\n\x04\x04#\x02\
    \x03\x12\x04\xa7\x04\x08*\n\r\n\x05\x04#\x02\x03\x04\x12\x04\xa7\x04\x08\
    \x10\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xa7\x04\x11\x18\n\r\n\x05\x04#\
    \x02\x03\x01\x12\x04\xa7\x04\x19%\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xa7\
    \x04()\n\x0c\n\x04\x04#\x02\x04\x12\x04\xa8\x04\x08(\n\r\n\x05\x04#\x02\
    \x04\x04\x12\x04\xa8\x04\x08\x10\n\r\n\x05\x04#\x02\x04\x05\x12\x04\xa8\
    \x04\x11\x17\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xa8\x04\x18#\n\r\n\x05\
    \x04#\x02\x04\x03\x12\x04\xa8\x04&'\n\x0c\n\x04\x04#\x02\x05\x12\x04\xa9\
    \x04\x08D\n\r\n\x05\x04#\x02\x05\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\
    \x04#\x02\x05\x06\x12\x04\xa9\x04\x119\n\r\n\x05\x04#\x02\x05\x01\x12\
    \x04\xa9\x04:?\n\r\n\x05\x04#\x02\x05\x03\x12\x04\xa9\x04BC\n\x0c\n\x04\
    \x04#\x02\x06\x12\x04\xaa\x04\x08>\n\r\n\x05\x04#\x02\x06\x04\x12\x04\
    \xaa\x04\x08\x10\n\r\n\x05\x04#\x02\x06\x06\x12\x04\xaa\x04\x114\n\r\n\
    \x05\x04#\x02\x06\x01\x12\x04\xaa\x0459\n\r\n\x05\x04#\x02\x06\x03\x12\
    \x04\xaa\x04<=\n\x0c\n\x04\x04#\x02\x07\x12\x04\xab\x04\x08-\n\r\n\x05\
    \x04#\x02\x07\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04#\x02\x07\x05\x12\
    \x04\xab\x04\x11\x17\n\r\n\x05\x04#\x02\x07\x01\x12\x04\xab\x04\x18(\n\r\
    \n\x05\x04#\x02\x07\x03\x12\x04\xab\x04+,\n\x0c\n\x02\x04$\x12\x06\xae\
    \x04\0\xb7\x04\x01\n\x0b\n\x03\x04$\x01\x12\x04\xae\x04\x08&\n\x0c\n\x04\
    \x04$\x02\0\x12\x04\xaf\x04\x082\n\r\n\x05\x04$\x02\0\x04\x12\x04\xaf\
    \x04\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\x04\xaf\x04\x11\x18\n\r\n\x05\
    \x04$\x02\0\x01\x12\x04\xaf\x04\x19-\n\r\n\x05\x04$\x02\0\x03\x12\x04\
    \xaf\x0401\n\x0c\n\x04\x04$\x02\x01\x12\x04\xb0\x04\x082\n\r\n\x05\x04$\
    \x02\x01\x04\x12\x04\xb0\x04\x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\
    \xb0\x04\x11\x18\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xb0\x04\x19-\n\r\n\
    \x05\x04$\x02\x01\x03\x12\x04\xb0\x0401\n\x0c\n\x04\x04$\x02\x02\x12\x04\
    \xb1\x04\x08-\n\r\n\x05\x04$\x02\x02\x04\x12\x04\xb1\x04\x08\x10\n\r\n\
    \x05\x04$\x02\x02\x05\x12\x04\xb1\x04\x11\x18\n\r\n\x05\x04$\x02\x02\x01\
    \x12\x04\xb1\x04\x19(\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xb1\x04+,\n\x0c\
    \n\x04\x04$\x02\x03\x12\x04\xb2\x04\x08,\n\r\n\x05\x04$\x02\x03\x04\x12\
    \x04\xb2\x04\x08\x10\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xb2\x04\x11\x18\
    \n\r\n\x05\x04$\x02\x03\x01\x12\x04\xb2\x04\x19'\n\r\n\x05\x04$\x02\x03\
    \x03\x12\x04\xb2\x04*+\n\x0c\n\x04\x04$\x02\x04\x12\x04\xb3\x04\x08,\n\r\
    \n\x05\x04$\x02\x04\x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x04$\x02\x04\
    \x05\x12\x04\xb3\x04\x11\x17\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xb3\x04\
    \x18'\n\r\n\x05\x04$\x02\x04\x03\x12\x04\xb3\x04*+\n\x0c\n\x04\x04$\x02\
    \x05\x12\x04\xb4\x04\x08D\n\r\n\x05\x04$\x02\x05\x04\x12\x04\xb4\x04\x08\
    \x10\n\r\n\x05\x04$\x02\x05\x06\x12\x04\xb4\x04\x119\n\r\n\x05\x04$\x02\
    \x05\x01\x12\x04\xb4\x04:?\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xb4\x04BC\
    \n\x0c\n\x04\x04$\x02\x06\x12\x04\xb5\x04\x08>\n\r\n\x05\x04$\x02\x06\
    \x04\x12\x04\xb5\x04\x08\x10\n\r\n\x05\x04$\x02\x06\x06\x12\x04\xb5\x04\
    \x114\n\r\n\x05\x04$\x02\x06\x01\x12\x04\xb5\x0459\n\r\n\x05\x04$\x02\
    \x06\x03\x12\x04\xb5\x04<=\n\x0c\n\x04\x04$\x02\x07\x12\x04\xb6\x04\x08-\
    \n\r\n\x05\x04$\x02\x07\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x04$\x02\
    \x07\x05\x12\x04\xb6\x04\x11\x17\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xb6\
    \x04\x18(\n\r\n\x05\x04$\x02\x07\x03\x12\x04\xb6\x04+,\n\x0c\n\x02\x04%\
    \x12\x06\xb9\x04\0\xbf\x04\x01\n\x0b\n\x03\x04%\x01\x12\x04\xb9\x04\x08-\
    \n\x0c\n\x04\x04%\x02\0\x12\x04\xba\x04\x089\n\r\n\x05\x04%\x02\0\x04\
    \x12\x04\xba\x04\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\xba\x04\x11\
    \x18\n\r\n\x05\x04%\x02\0\x01\x12\x04\xba\x04\x194\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\xba\x0478\n\x0c\n\x04\x04%\x02\x01\x12\x04\xbb\x04\x08.\n\r\
    \n\x05\x04%\x02\x01\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04%\x02\x01\
    \x05\x12\x04\xbb\x04\x11\x18\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xbb\x04\
    \x19)\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xbb\x04,-\n\x0c\n\x04\x04%\x02\
    \x02\x12\x04\xbc\x04\x080\n\r\n\x05\x04%\x02\x02\x04\x12\x04\xbc\x04\x08\
    \x10\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xbc\x04\x11\x18\n\r\n\x05\x04%\
    \x02\x02\x01\x12\x04\xbc\x04\x19+\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xbc\
    \x04./\n\x0c\n\x04\x04%\x02\x03\x12\x04\xbd\x04\x08\"\n\r\n\x05\x04%\x02\
    \x03\x04\x12\x04\xbd\x04\x08\x10\n\r\n\x05\x04%\x02\x03\x05\x12\x04\xbd\
    \x04\x11\x17\n\r\n\x05\x04%\x02\x03\x01\x12\x04\xbd\x04\x18\x1d\n\r\n\
    \x05\x04%\x02\x03\x03\x12\x04\xbd\x04\x20!\n\x0c\n\x04\x04%\x02\x04\x12\
    \x04\xbe\x04\x08(\n\r\n\x05\x04%\x02\x04\x04\x12\x04\xbe\x04\x08\x10\n\r\
    \n\x05\x04%\x02\x04\x05\x12\x04\xbe\x04\x11\x17\n\r\n\x05\x04%\x02\x04\
    \x01\x12\x04\xbe\x04\x18#\n\r\n\x05\x04%\x02\x04\x03\x12\x04\xbe\x04&'\n\
    \x0c\n\x02\x04&\x12\x06\xc1\x04\0\xc5\x04\x01\n\x0b\n\x03\x04&\x01\x12\
    \x04\xc1\x04\x08)\n\x0c\n\x04\x04&\x02\0\x12\x04\xc2\x04\x089\n\r\n\x05\
    \x04&\x02\0\x04\x12\x04\xc2\x04\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\
    \xc2\x04\x11\x18\n\r\n\x05\x04&\x02\0\x01\x12\x04\xc2\x04\x194\n\r\n\x05\
    \x04&\x02\0\x03\x12\x04\xc2\x0478\n\x0c\n\x04\x04&\x02\x01\x12\x04\xc3\
    \x04\x080\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\
    \x04&\x02\x01\x05\x12\x04\xc3\x04\x11\x18\n\r\n\x05\x04&\x02\x01\x01\x12\
    \x04\xc3\x04\x19+\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc3\x04./\n\x0c\n\
    \x04\x04&\x02\x02\x12\x04\xc4\x04\x08.\n\r\n\x05\x04&\x02\x02\x04\x12\
    \x04\xc4\x04\x08\x10\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xc4\x04\x11\x18\
    \n\r\n\x05\x04&\x02\x02\x01\x12\x04\xc4\x04\x19)\n\r\n\x05\x04&\x02\x02\
    \x03\x12\x04\xc4\x04,-\n\x0c\n\x02\x04'\x12\x06\xc7\x04\0\xd4\x04\x01\n\
    \x0b\n\x03\x04'\x01\x12\x04\xc7\x04\x08\"\n\x0e\n\x04\x04'\x04\0\x12\x06\
    \xc8\x04\x08\xcb\x04\t\n\r\n\x05\x04'\x04\0\x01\x12\x04\xc8\x04\r\x12\n\
    \x0e\n\x06\x04'\x04\0\x02\0\x12\x04\xc9\x04\x10$\n\x0f\n\x07\x04'\x04\0\
    \x02\0\x01\x12\x04\xc9\x04\x10\x1f\n\x0f\n\x07\x04'\x04\0\x02\0\x02\x12\
    \x04\xc9\x04\"#\n\x0e\n\x06\x04'\x04\0\x02\x01\x12\x04\xca\x04\x10*\n\
    \x0f\n\x07\x04'\x04\0\x02\x01\x01\x12\x04\xca\x04\x10%\n\x0f\n\x07\x04'\
    \x04\0\x02\x01\x02\x12\x04\xca\x04()\n\x0c\n\x04\x04'\x02\0\x12\x04\xcd\
    \x04\x08?\n\r\n\x05\x04'\x02\0\x04\x12\x04\xcd\x04\x08\x10\n\r\n\x05\x04\
    '\x02\0\x06\x12\x04\xcd\x04\x114\n\r\n\x05\x04'\x02\0\x01\x12\x04\xcd\
    \x045:\n\r\n\x05\x04'\x02\0\x03\x12\x04\xcd\x04=>\n\x0c\n\x04\x04'\x02\
    \x01\x12\x04\xce\x04\x08%\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xce\x04\x08\
    \x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xce\x04\x11\x18\n\r\n\x05\x04'\
    \x02\x01\x01\x12\x04\xce\x04\x19\x20\n\r\n\x05\x04'\x02\x01\x03\x12\x04\
    \xce\x04#$\n\x0c\n\x04\x04'\x02\x02\x12\x04\xcf\x04\x08\"\n\r\n\x05\x04'\
    \x02\x02\x04\x12\x04\xcf\x04\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\
    \xcf\x04\x11\x17\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xcf\x04\x18\x1d\n\r\
    \n\x05\x04'\x02\x02\x03\x12\x04\xcf\x04\x20!\n\x0c\n\x04\x04'\x02\x03\
    \x12\x04\xd0\x04\x089\n\r\n\x05\x04'\x02\x03\x04\x12\x04\xd0\x04\x08\x10\
    \n\r\n\x05\x04'\x02\x03\x05\x12\x04\xd0\x04\x11\x18\n\r\n\x05\x04'\x02\
    \x03\x01\x12\x04\xd0\x04\x194\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xd0\x04\
    78\n\x0c\n\x04\x04'\x02\x04\x12\x04\xd1\x04\x08.\n\r\n\x05\x04'\x02\x04\
    \x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04'\x02\x04\x05\x12\x04\xd1\x04\
    \x11\x18\n\r\n\x05\x04'\x02\x04\x01\x12\x04\xd1\x04\x19)\n\r\n\x05\x04'\
    \x02\x04\x03\x12\x04\xd1\x04,-\n\x0c\n\x04\x04'\x02\x05\x12\x04\xd2\x04\
    \x081\n\r\n\x05\x04'\x02\x05\x04\x12\x04\xd2\x04\x08\x10\n\r\n\x05\x04'\
    \x02\x05\x05\x12\x04\xd2\x04\x11\x18\n\r\n\x05\x04'\x02\x05\x01\x12\x04\
    \xd2\x04\x19+\n\r\n\x05\x04'\x02\x05\x03\x12\x04\xd2\x04.0\n\x0c\n\x04\
    \x04'\x02\x06\x12\x04\xd3\x04\x08$\n\r\n\x05\x04'\x02\x06\x04\x12\x04\
    \xd3\x04\x08\x10\n\r\n\x05\x04'\x02\x06\x05\x12\x04\xd3\x04\x11\x17\n\r\
    \n\x05\x04'\x02\x06\x01\x12\x04\xd3\x04\x18\x1f\n\r\n\x05\x04'\x02\x06\
    \x03\x12\x04\xd3\x04\"#\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
